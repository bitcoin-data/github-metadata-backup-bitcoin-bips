{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1389",
    "id": 1124681288,
    "node_id": "PR_kwDOAN28mc5DCUZI",
    "html_url": "https://github.com/bitcoin/bips/pull/1389",
    "diff_url": "https://github.com/bitcoin/bips/pull/1389.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1389.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1389/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/d4c650bad3ac190c9106d059b1ed5b110f2660bb",
    "number": 1389,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "BIP 388: Wallet Policies for Descriptor Wallets",
    "user": {
      "login": "bigspider",
      "id": 6681844,
      "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bigspider",
      "html_url": "https://github.com/bigspider",
      "followers_url": "https://api.github.com/users/bigspider/followers",
      "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
      "organizations_url": "https://api.github.com/users/bigspider/orgs",
      "repos_url": "https://api.github.com/users/bigspider/repos",
      "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/bigspider/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Initial version posted to [bitcoin-dev in May](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html).\r\n\r\nWallet policies are implemented in the [Ledger bitcoin app](https://github.com/LedgerHQ/app-bitcoin-new) (since version 2.1.0).\r\n\r\nThe following PR experimenting with an HWI integration might provide more context and an end-to-end demo:\r\n  - https://github.com/bitcoin-core/HWI/pull/647",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2022-11-16T15:34:23Z",
    "updated_at": "2024-03-16T22:32:06Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merge_commit_sha": "35c38b8cbdba02f49e8c886b2ac8f27a0b34af2b",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "bigspider:bip-wallet-policies",
      "ref": "bip-wallet-policies",
      "sha": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 416262417,
        "node_id": "R_kgDOGM-pEQ",
        "name": "bips",
        "full_name": "bigspider/bips",
        "owner": {
          "login": "bigspider",
          "id": 6681844,
          "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
          "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bigspider",
          "html_url": "https://github.com/bigspider",
          "followers_url": "https://api.github.com/users/bigspider/followers",
          "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
          "organizations_url": "https://api.github.com/users/bigspider/orgs",
          "repos_url": "https://api.github.com/users/bigspider/repos",
          "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bigspider/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bigspider/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/bigspider/bips",
        "archive_url": "https://api.github.com/repos/bigspider/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bigspider/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bigspider/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bigspider/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bigspider/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bigspider/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bigspider/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bigspider/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bigspider/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bigspider/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bigspider/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bigspider/bips/downloads",
        "events_url": "https://api.github.com/repos/bigspider/bips/events",
        "forks_url": "https://api.github.com/repos/bigspider/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bigspider/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bigspider/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bigspider/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bigspider/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bigspider/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bigspider/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bigspider/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bigspider/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bigspider/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bigspider/bips/languages",
        "merges_url": "https://api.github.com/repos/bigspider/bips/merges",
        "milestones_url": "https://api.github.com/repos/bigspider/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bigspider/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bigspider/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bigspider/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bigspider/bips.git",
        "stargazers_url": "https://api.github.com/repos/bigspider/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bigspider/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bigspider/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bigspider/bips/subscription",
        "tags_url": "https://api.github.com/repos/bigspider/bips/tags",
        "teams_url": "https://api.github.com/repos/bigspider/bips/teams",
        "trees_url": "https://api.github.com/repos/bigspider/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bigspider/bips.git",
        "hooks_url": "https://api.github.com/repos/bigspider/bips/hooks",
        "svn_url": "https://github.com/bigspider/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 13734,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-01-08T11:18:47Z",
        "created_at": "2021-10-12T09:08:05Z",
        "updated_at": "2022-09-01T08:36:44Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "deae64bfd31f6938253c05392aa355bf6d7e7605",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5192,
        "stargazers_count": 8812,
        "watchers_count": 8812,
        "size": 14123,
        "default_branch": "master",
        "open_issues_count": 143,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-03-14T10:22:44Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2024-03-16T16:49:42Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 543,
    "deletions": 0,
    "changed_files": 2,
    "commits": 2,
    "review_comments": 50,
    "comments": 17
  },
  "events": [
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T15:39:19Z",
      "updated_at": "2022-11-16T15:39:19Z",
      "source": {
        "issue": {
          "id": 1451598094,
          "node_id": "PR_kwDOBfbkJs5DBkIX",
          "url": "https://api.github.com/repos/bitcoin-core/HWI/issues/647",
          "repository_url": "https://api.github.com/repos/bitcoin-core/HWI",
          "labels_url": "https://api.github.com/repos/bitcoin-core/HWI/issues/647/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/HWI/issues/647/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/HWI/issues/647/events",
          "html_url": "https://github.com/bitcoin-core/HWI/pull/647",
          "number": 647,
          "state": "open",
          "state_reason": null,
          "title": "[PoC] Wallet policies (and miniscript support)",
          "body": "Hello,\r\n\r\nthis in an exploratory PR as a proof of concept of how wallet policies could look like in HWI.\r\n\r\nWallet policies [were presented](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html) to the bitcoin-dev mailing list back in May.\r\nA BIP proposal is in preparation [here](https://github.com/bitcoin/bips/pull/1389).\r\n\r\nThe goals of this PR are to:\r\n- show that adding wallet policies to hwi is relatively straightforward and can be done with non-breaking changes\r\n- argue that wallet policies naturally and conveniently represent the \"accounts\" of a typical single-signature, multisignature or miniscript-based wallet accounts;\r\n- demo how a typical wallet-policy workflow could look like with hwi;\r\n- showcase specifically the implementation and UX in the Ledger bitcoin application.\r\n\r\nWallet policies are designed to be vendor-agnostic.\r\nIn fact, they are ready for miniscript wallets, and they might in my opinion be a convenient, opinionated way of adding miniscript support to HWI.\r\n\r\nThey are implemented in the Ledger bitcoin app since version 2.1.0, which uses them to support miniscript (on segwit only, at this time).\r\n\r\n# Implementation details\r\n\r\nNot production-ready!\r\n\r\nIn this PR, I attempted to add wallet policies as a first-class object, while not breaking compatibility with existing code. \r\n\r\nThe three commit add:\r\n- The wallet-policy-related methods in `HardwareWalletClient`: `can_register_wallet_policies`, `register_wallet_policy`, `display_wallet_policy_address`, `sign_tx_with_wallet_policy`.\r\n- Support in CLI within `displayaddress` and `signtx`; added `registerpolicy`.\r\n- The specific implementation of wallet policies for the Ledger client in `ledger.py`.\r\n\r\nFor subclasses not implementing wallet policies, a compatibility layer guarantees that if the policy falls back into the supported cases (single-signature, or standard multisignature), calls to functions using wallet policies are automatically converted to the corresponding single-sig or multi-sig function to show addresses or sign transactions.\r\n\r\nWith this approach, software wallets adopting wallet policies, therefore, could use them directly without using any other `HardwareWalletClient` function without wallet policies.\r\n\r\n# Demo\r\n\r\nIn the following, I'd like to walk you through an end-to-end demo of wallet policies that can be tested from this PR's branch using the [Ledger bitcoin testnet app ](https://github.com/LedgerHQ/app-bitcoin-new) version 2.1.0 in the speculos emulator; the app will be released in production within a few weeks.\r\n\r\nIn all the examples with multiple keys, internal keys are the ones with fingerprint `f5acc2fd`, which is the fingerprint for the default seed used by the speculos emulator.\r\n\r\nThe command should be run from the root folder of the HWI repository, or after installing the module from this PR (e.g. with `pip install .`).\r\n\r\nScreenshots are based on the UX for a Ledger NanoS+ device.\r\n\r\n## Single-signature\r\n\r\nIn this example, we use a wallet policy for a standard BIP-86 taproot address. Ledger devices require no registration for standard single-signature policies, so this can be used directly.\r\n\r\n```\r\n# display address for a taproot BIP-86 address\r\npython -m hwi --chain test --device-type ledger displayaddress\\\r\n       --policy \"tr(@0/**)\"\\\r\n       --keys \"[\\\"[f5acc2fd/86'/1'/0']tpubDDKYE6BREvDsSWMazgHoyQWiJwYaDDYPbCFjYxN3HFXJP5fokeiK4hwK5tTLBNEDBwrDXn8cQ4v9b2xdW62Xr5yxoQdMu1v6c7UDXYVH27U\\\"]\"\r\n```\r\nDevice screen:\r\n\r\n![out](https://user-images.githubusercontent.com/6681844/202187739-819e2652-969a-4b08-abed-825ec43da057.gif)\r\n\r\nOutput:\r\n```\r\n\r\n{\"address\": \"tb1pws8wvnj99ca6acf8kq7pjk7vyxknah0d9mexckh5s0vu2ccy68js9am6u7\"}\r\n```\r\n\r\n## Multisignature\r\n\r\n## Register policy\r\n\r\n```\r\n# register a legacy multisig policy on the device\r\npython -m hwi --chain test --device-type ledger registerpolicy\\\r\n       --policy \"sh(sortedmulti(2,@0/**,@1/**))\"\\\r\n       --name \"Cold storage\"\\\r\n       --keys \"[\\\"[5c9e228d/48'/1'/0'/0']tpubDEGquuorgFNb8bjh5kNZQMPtABJzoWwNm78FUmeoPkfRtoPF7JLrtoZeT3J3ybq1HmC3Rn1Q8wFQ8J5usanzups5rj7PJoQLNyvq8QbJruW\\\",\\\"[f5acc2fd/48'/1'/0'/0']tpubDFAqEGNyad35WQAZMmPD4vgBXnjH16RGciLdWekPe4f4d5JzoHVu1PS86Sy4Tm63vDf8rfV3UjifhrRuSUDfiZj5KPffTPyZ4ZXBKvjD8jm\\\"]\"\r\n```\r\n\r\nDevice screen:\r\n![01-register](https://user-images.githubusercontent.com/6681844/202187921-80bfb18f-40c5-4756-9e50-79a02fac9ebf.gif)\r\n\r\n\r\nOutput:\r\n```\r\n{\"proof_of_registration\": \"fa73e36119324fbe4cc1ca94aa842c6261526d44112a22164bc57c3335102b04\"}\r\n```\r\n\r\n## Display address\r\n\r\n```\r\n# display an address for a registered multisig policy\r\npython -m hwi --chain test --device-type ledger displayaddress\\\r\n       --policy \"sh(sortedmulti(2,@0/**,@1/**))\"\\\r\n       --name \"Cold storage\"\\\r\n       --keys \"[\\\"[5c9e228d/48'/1'/0'/0']tpubDEGquuorgFNb8bjh5kNZQMPtABJzoWwNm78FUmeoPkfRtoPF7JLrtoZeT3J3ybq1HmC3Rn1Q8wFQ8J5usanzups5rj7PJoQLNyvq8QbJruW\\\",\\\"[f5acc2fd/48'/1'/0'/0']tpubDFAqEGNyad35WQAZMmPD4vgBXnjH16RGciLdWekPe4f4d5JzoHVu1PS86Sy4Tm63vDf8rfV3UjifhrRuSUDfiZj5KPffTPyZ4ZXBKvjD8jm\\\"]\"\\\r\n       --extra \"{\\\"proof_of_registration\\\": \\\"fa73e36119324fbe4cc1ca94aa842c6261526d44112a22164bc57c3335102b04\\\"}\"\r\n```\r\n\r\nDevice screen:\r\n![02-receive](https://user-images.githubusercontent.com/6681844/202188026-a73330d2-0b44-476b-bbdf-da9559656d7f.gif)\r\n\r\n\r\nOutput:\r\n```\r\n{\"address\": \"2Mx69MjHC4ViZAH1koVXPvVgaazbBCdr89j\"}\r\n```\r\n\r\n## Sign a psbt with policy\r\n\r\nIt is relevant to point out that when using wallet policies, it makes sense to use a more specific action rather than \"sign a transaction\": in fact, the wallet policy specifies exactly what kind of scripts/inputs should be signed, and similarly, what outputs can match a change address.\r\nThis allows hardware wallets to correctly identify internal inputs and outputs.\r\n\r\nThe necessary information about what exact wallet policy should be used for signing is in fact typically available to the software wallet.\r\nTherefore, the action is \"sign a transaction with a certain wallet policy\".\r\n\r\n```\r\n# sign a psbt using a registered multisig policy\r\npython -m hwi --chain test --device-type ledger signtx\\\r\n       cHNidP8BAH0CAAAAATu7ic6eCZKS8ISJpxQmv/DpLPyQgxBDTD7ECvecufnvAQAAAAD9////AjkwAAAAAAAAFgAUMxjgT65sEq/LAJxpzVflslBK5rTmQQEAAAAAACIAIKgAjP1KDkIBgF3Cmo+Jj+uu9mUmnEuPjoFZDYcT5J9YAAAAAAABAJQCAAAAAdnPFpiaZHjHIp9948kMd6KSqdFfHTv74HHnrMapIZneAAAAABcWABSPMOw+gW7W+tfmjgw1zGwPbdtlvv7///8CoQ7VAAAAAAAWABRv0DCr8w8BHXhZ+5ysOZpTo3v91KCGAQAAAAAAIgAg2TvCCm8+G8E0Ds5MifVQC5rxzbKlEwHbKRkVgPCLrgMjhh4AAQEroIYBAAAAAAAiACDZO8IKbz4bwTQOzkyJ9VALmvHNsqUTAdspGRWA8IuuAwEFR1IhAlAXEIvs6o3txTALsiOGs6swNnrCYvnOXlgybrg+OiL1IQNrFujB+Xn6TMDwW2owCv//lBRZtvIN533lWwFg745MrFKuIgYCUBcQi+zqje3FMAuyI4azqzA2esJi+c5eWDJuuD46IvUcdiI6bjAAAIABAACAAAAAgAIAAIAAAAAAAAAAACIGA2sW6MH5efpMwPBbajAK//+UFFm28g3nfeVbAWDvjkysHPWswv0wAACAAQAAgAAAAIACAACAAAAAAAAAAAAAAAEBR1IhAleBu0CgoDHY9QkXQyIkVOKYC765sDDZaHeMfWd9xszJIQLdg+T/0aVgy1q/LtEqLdTb6+V2KvUPwDCqjBF5gd9eO1KuIgICV4G7QKCgMdj1CRdDIiRU4pgLvrmwMNlod4x9Z33GzMkcdiI6bjAAAIABAACAAAAAgAIAAIABAAAAAAAAACICAt2D5P/RpWDLWr8u0Sot1Nvr5XYq9Q/AMKqMEXmB3147HPWswv0wAACAAQAAgAAAAIACAACAAQAAAAAAAAAA\\\r\n       --policy \"wsh(sortedmulti(2,@0/**,@1/**))\"\\\r\n       --name \"Cold storage\"\\\r\n       --keys \"[\\\"[76223a6e/48'/1'/0'/2']tpubDE7NQymr4AFtewpAsWtnreyq9ghkzQBXpCZjWLFVRAvnbf7vya2eMTvT2fPapNqL8SuVvLQdbUbMfWLVDCZKnsEBqp6UK93QEzL8Ck23AwF\\\",\\\"[f5acc2fd/48'/1'/0'/2']tpubDFAqEGNyad35aBCKUAXbQGDjdVhNueno5ZZVEn3sQbW5ci457gLR7HyTmHBg93oourBssgUxuWz1jX5uhc1qaqFo9VsybY1J5FuedLfm4dK\\\"]\"\\\r\n       --extra \"{\\\"proof_of_registration\\\": \\\"d7c7a60b4ab4a14c1bf8901ba627d72140b2fb907f2b4e35d2e693bce9fbb371\\\"}\"\r\n```\r\n\r\nDevice screen:\r\n![03-spend](https://user-images.githubusercontent.com/6681844/202188092-54b0322d-8245-4936-bf88-136142683757.gif)\r\n\r\nOutput:\r\n```\r\n{\"psbt\": \"cHNidP8BAH0CAAAAATu7ic6eCZKS8ISJpxQmv/DpLPyQgxBDTD7ECvecufnvAQAAAAD9////AjkwAAAAAAAAFgAUMxjgT65sEq/LAJxpzVflslBK5rTmQQEAAAAAACIAIKgAjP1KDkIBgF3Cmo+Jj+uu9mUmnEuPjoFZDYcT5J9YAAAAAAABAJQCAAAAAdnPFpiaZHjHIp9948kMd6KSqdFfHTv74HHnrMapIZneAAAAABcWABSPMOw+gW7W+tfmjgw1zGwPbdtlvv7///8CoQ7VAAAAAAAWABRv0DCr8w8BHXhZ+5ysOZpTo3v91KCGAQAAAAAAIgAg2TvCCm8+G8E0Ds5MifVQC5rxzbKlEwHbKRkVgPCLrgMjhh4AAQEroIYBAAAAAAAiACDZO8IKbz4bwTQOzkyJ9VALmvHNsqUTAdspGRWA8IuuAyICA2sW6MH5efpMwPBbajAK//+UFFm28g3nfeVbAWDvjkysRzBEAiBqspfIOrZuVzcjiSBh2CfFrAFQ4gRP7X7TR0L+28+ybgIgMZzfTq3f9j/DCM31PiJeoDQCTvlt4D/Qk5tt7uoei9MBAQVHUiECUBcQi+zqje3FMAuyI4azqzA2esJi+c5eWDJuuD46IvUhA2sW6MH5efpMwPBbajAK//+UFFm28g3nfeVbAWDvjkysUq4iBgJQFxCL7OqN7cUwC7IjhrOrMDZ6wmL5zl5YMm64Pjoi9Rx2IjpuMAAAgAEAAIAAAACAAgAAgAAAAAAAAAAAIgYDaxbowfl5+kzA8FtqMAr//5QUWbbyDed95VsBYO+OTKwc9azC/TAAAIABAACAAAAAgAIAAIAAAAAAAAAAAAAAAQFHUiECV4G7QKCgMdj1CRdDIiRU4pgLvrmwMNlod4x9Z33GzMkhAt2D5P/RpWDLWr8u0Sot1Nvr5XYq9Q/AMKqMEXmB3147Uq4iAgJXgbtAoKAx2PUJF0MiJFTimAu+ubAw2Wh3jH1nfcbMyRx2IjpuMAAAgAEAAIAAAACAAgAAgAEAAAAAAAAAIgIC3YPk/9GlYMtavy7RKi3U2+vldir1D8AwqowReYHfXjsc9azC/TAAAIABAACAAAAAgAIAAIABAAAAAAAAAAA=\", \"signed\": true}\r\n```\r\n\r\n# Miniscript\r\n\r\nMiniscript policy: a 3-of-3 that becomes a 2-of-3 after 90 days: `thresh(3,pk(key_1),pk(key_2),pk(key_3),older(12960))`.\r\n\r\n## Register policy\r\n```\r\n# register the wallet policy\r\npython -m hwi --chain test --device-type ledger registerpolicy\\\r\n       --policy \"wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\"\\\r\n       --name \"Decaying 3of3\"\\\r\n       --keys \"[\\\"[f5acc2fd/48'/1'/0'/2']tpubDFAqEGNyad35aBCKUAXbQGDjdVhNueno5ZZVEn3sQbW5ci457gLR7HyTmHBg93oourBssgUxuWz1jX5uhc1qaqFo9VsybY1J5FuedLfm4dK\\\",\\\"tpubDCsD8geGfXgcBhxuvqqEGSmCR5P56f2rwxvcg51h9PL39zYXS4k4Ryn5eNdxN9H9umPbezhKZjpzS6Bjv6WbRQZqtvoHtQ29pkn1VZ3GA7k\\\",\\\"tpubDD1dWr4oGX2148MJ3WBGTCfC8i2H5juMExoSzE5nHdzRNJeVcxY1qT1WFBASTubBQpbW6Tt2KBbmy8rZNiC4oXZhEnc9BW6x33yPYizRjpc\\\"]\"\r\n```\r\n\r\nDevice screen:\r\n![01-register](https://user-images.githubusercontent.com/6681844/202188269-ecd545fe-e427-4754-bd76-dbeaeedf559f.gif)\r\n\r\nOutput:\r\n```\r\n{\"proof_of_registration\": \"bac398f60b85214815051bc89bd7f6d94097f0b53ae61a18acad6c7bc3e9f80b\"}\r\n```\r\n\r\n## Display address\r\n\r\n```\r\n# display a specific address\r\npython -m hwi --chain test --device-type ledger displayaddress\\\r\n       --policy \"wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\"\\\r\n       --name \"Decaying 3of3\"\\\r\n       --keys \"[\\\"[f5acc2fd/48'/1'/0'/2']tpubDFAqEGNyad35aBCKUAXbQGDjdVhNueno5ZZVEn3sQbW5ci457gLR7HyTmHBg93oourBssgUxuWz1jX5uhc1qaqFo9VsybY1J5FuedLfm4dK\\\",\\\"tpubDCsD8geGfXgcBhxuvqqEGSmCR5P56f2rwxvcg51h9PL39zYXS4k4Ryn5eNdxN9H9umPbezhKZjpzS6Bjv6WbRQZqtvoHtQ29pkn1VZ3GA7k\\\",\\\"tpubDD1dWr4oGX2148MJ3WBGTCfC8i2H5juMExoSzE5nHdzRNJeVcxY1qT1WFBASTubBQpbW6Tt2KBbmy8rZNiC4oXZhEnc9BW6x33yPYizRjpc\\\"]\"\\\r\n       --extra \"{\\\"proof_of_registration\\\": \\\"bac398f60b85214815051bc89bd7f6d94097f0b53ae61a18acad6c7bc3e9f80b\\\"}\"\\\r\n       --change 1\\\r\n       --index 3\r\n```\r\n\r\nDevice screen:\r\n![02-receive](https://user-images.githubusercontent.com/6681844/202188362-7a9a61ed-f99e-459c-9a7f-236b0012866b.gif)\r\n\r\nOutput:\r\n```\r\n{\"address\": \"tb1qca0tjjln3fhp3rsyg7tvmyf2x5fmvgk6lcp0zfzmmwr2y8vapllstc36ug\"}\r\n```\r\n\r\n## Sign a psbt with the policy\r\n\r\n```\r\n# sign a tx\r\npython -m hwi --chain test --device-type ledger signtx\\\r\n       cHNidP8BAH0CAAAAAUN7Z9JlC6y6LtlwbTIVzEtWHw6AiBgWuDRIkxoZCKMpAQAAAAD9////AkBCDwAAAAAAFgAUYE60U6z6Rpo5RK6oC+g6RUkxu7usTIkAAAAAACIAIESrl1+a21z6n3pLozjP4AHIQOofzJHNgz3NwDxBwASBAAAAAAABAIkCAAAAAa15z+lMT/YZ0sRDAkaL5A5tBBPIAmil+V/5AePextPvAAAAAAD+////AttabSkBAAAAIlEg0VQ1MNBHwNuDbYWtzEaEV1yANsJurWNqvZxlikhKbbKAlpgAAAAAACIAIESyacRc1GKFR/8RdvMWQ0hcAleGITHMJP6A4Kn5YBy7aQAAAAEBK4CWmAAAAAAAIgAgRLJpxFzUYoVH/xF28xZDSFwCV4YhMcwk/oDgqflgHLsBBXohAp5kb7ngRSRglE5J+IafmrnakIINpdU4Qa+eEnGjvPnOrHwhAoz4Y6xeDg72tAuWuExobc18NXLIzXVx22mvkaLEE3NIrJN8IQIOXt2k+7FDkz0OYPBWmB18LIpxqwY4t8C/kRn7SyouvqyTfGMAZwKgMrKSaJNThyIGAg5e3aT7sUOTPQ5g8FaYHXwsinGrBji3wL+RGftLKi6+DGYCRCIAAAAAAwAAACIGAoz4Y6xeDg72tAuWuExobc18NXLIzXVx22mvkaLEE3NIDKjFojkAAAAAAwAAACIGAp5kb7ngRSRglE5J+IafmrnakIINpdU4Qa+eEnGjvPnOHPWswv0wAACAAQAAgAAAAIACAACAAAAAAAMAAAAAAAEBeiEDRKw0XW+7Q+lxieEI8mjMwAlG8J//ABlTcQlFY93EOwSsfCECmEf2+BbuDI1lxfRMhvkJ2Ij5Qhy0tcpBkQ6MSrYJsCOsk3whA1hZjepNSbXWWXSb7LP7oaJkkN6gA7v/nJxbSAslYPsxrJN8YwBnAqAyspJok1OHIgICmEf2+BbuDI1lxfRMhvkJ2Ij5Qhy0tcpBkQ6MSrYJsCMMqMWiOQEAAAABAAAAIgIDRKw0XW+7Q+lxieEI8mjMwAlG8J//ABlTcQlFY93EOwQc9azC/TAAAIABAACAAAAAgAIAAIABAAAAAQAAACICA1hZjepNSbXWWXSb7LP7oaJkkN6gA7v/nJxbSAslYPsxDGYCRCIBAAAAAQAAAAA=\\\r\n       --policy \"wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\"\\\r\n       --name \"Decaying 3of3\"\\\r\n       --keys \"[\\\"[f5acc2fd/48'/1'/0'/2']tpubDFAqEGNyad35aBCKUAXbQGDjdVhNueno5ZZVEn3sQbW5ci457gLR7HyTmHBg93oourBssgUxuWz1jX5uhc1qaqFo9VsybY1J5FuedLfm4dK\\\",\\\"tpubDCsD8geGfXgcBhxuvqqEGSmCR5P56f2rwxvcg51h9PL39zYXS4k4Ryn5eNdxN9H9umPbezhKZjpzS6Bjv6WbRQZqtvoHtQ29pkn1VZ3GA7k\\\",\\\"tpubDD1dWr4oGX2148MJ3WBGTCfC8i2H5juMExoSzE5nHdzRNJeVcxY1qT1WFBASTubBQpbW6Tt2KBbmy8rZNiC4oXZhEnc9BW6x33yPYizRjpc\\\"]\"\\\r\n       --extra \"{\\\"proof_of_registration\\\": \\\"bac398f60b85214815051bc89bd7f6d94097f0b53ae61a18acad6c7bc3e9f80b\\\"}\"\r\n```\r\n\r\nDevice screen:\r\n![03-spend](https://user-images.githubusercontent.com/6681844/202188424-261cce85-5cf9-4ea5-a139-15661aa89429.gif)\r\n\r\nOutput:\r\n```\r\n{\"psbt\": \"cHNidP8BAH0CAAAAAUN7Z9JlC6y6LtlwbTIVzEtWHw6AiBgWuDRIkxoZCKMpAQAAAAD9////AkBCDwAAAAAAFgAUYE60U6z6Rpo5RK6oC+g6RUkxu7usTIkAAAAAACIAIESrl1+a21z6n3pLozjP4AHIQOofzJHNgz3NwDxBwASBAAAAAAABAIkCAAAAAa15z+lMT/YZ0sRDAkaL5A5tBBPIAmil+V/5AePextPvAAAAAAD+////AttabSkBAAAAIlEg0VQ1MNBHwNuDbYWtzEaEV1yANsJurWNqvZxlikhKbbKAlpgAAAAAACIAIESyacRc1GKFR/8RdvMWQ0hcAleGITHMJP6A4Kn5YBy7aQAAAAEBK4CWmAAAAAAAIgAgRLJpxFzUYoVH/xF28xZDSFwCV4YhMcwk/oDgqflgHLsiAgKeZG+54EUkYJROSfiGn5q52pCCDaXVOEGvnhJxo7z5zkcwRAIgTbB7mkwLeNWNMZ8KGkhAfQPlAEpDNMsMjvsgsmxX/h0CIE7q1xBjQufpIozPXcUBhR4twriYwziY5fpHvOF0SF4YAQEFeiECnmRvueBFJGCUTkn4hp+audqQgg2l1ThBr54ScaO8+c6sfCECjPhjrF4ODva0C5a4TGhtzXw1csjNdXHbaa+RosQTc0isk3whAg5e3aT7sUOTPQ5g8FaYHXwsinGrBji3wL+RGftLKi6+rJN8YwBnAqAyspJok1OHIgYCDl7dpPuxQ5M9DmDwVpgdfCyKcasGOLfAv5EZ+0sqLr4MZgJEIgAAAAADAAAAIgYCjPhjrF4ODva0C5a4TGhtzXw1csjNdXHbaa+RosQTc0gMqMWiOQAAAAADAAAAIgYCnmRvueBFJGCUTkn4hp+audqQgg2l1ThBr54ScaO8+c4c9azC/TAAAIABAACAAAAAgAIAAIAAAAAAAwAAAAAAAQF6IQNErDRdb7tD6XGJ4QjyaMzACUbwn/8AGVNxCUVj3cQ7BKx8IQKYR/b4Fu4MjWXF9EyG+QnYiPlCHLS1ykGRDoxKtgmwI6yTfCEDWFmN6k1JtdZZdJvss/uhomSQ3qADu/+cnFtICyVg+zGsk3xjAGcCoDKykmiTU4ciAgKYR/b4Fu4MjWXF9EyG+QnYiPlCHLS1ykGRDoxKtgmwIwyoxaI5AQAAAAEAAAAiAgNErDRdb7tD6XGJ4QjyaMzACUbwn/8AGVNxCUVj3cQ7BBz1rML9MAAAgAEAAIAAAACAAgAAgAEAAAABAAAAIgIDWFmN6k1JtdZZdJvss/uhomSQ3qADu/+cnFtICyVg+zEMZgJEIgEAAAABAAAAAA==\", \"signed\": true}\r\n```\r\n\r\n# Conclusions\r\n\r\nI hope this is interesting and I look forward to hearing your comments about whether (and how) wallet policies could be added to hwi.",
          "user": {
            "login": "bigspider",
            "id": 6681844,
            "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bigspider",
            "html_url": "https://github.com/bigspider",
            "followers_url": "https://api.github.com/users/bigspider/followers",
            "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
            "organizations_url": "https://api.github.com/users/bigspider/orgs",
            "repos_url": "https://api.github.com/users/bigspider/repos",
            "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/bigspider/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/HWI/pulls/647",
            "html_url": "https://github.com/bitcoin-core/HWI/pull/647",
            "diff_url": "https://github.com/bitcoin-core/HWI/pull/647.diff",
            "patch_url": "https://github.com/bitcoin-core/HWI/pull/647.patch"
          },
          "created_at": "2022-11-16T13:22:46Z",
          "updated_at": "2023-09-05T19:17:02Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1199012337,
      "node_id": "PRR_kwDOAN28mc5Hd3nx",
      "url": null,
      "actor": null,
      "commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Good to see progress on this! Just a small comment about only mentioning Bitcoin Core: i know of several projects using descriptors, and even more of them using descriptors without Miniscript.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1199012337",
      "submitted_at": "2022-11-30T10:01:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "labeled",
      "id": 8147220601,
      "node_id": "LE_lADOAN28mc5WiQDdzwAAAAHlnLh5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147220601",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T01:34:43Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8342131034,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAHxOtFa",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8342131034",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-24T09:19:45Z"
    },
    {
      "event": "commented",
      "id": 1401619046,
      "node_id": "IC_kwDOAN28mc5TiwJm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1401619046",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-24T09:25:35Z",
      "updated_at": "2023-01-24T09:25:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "In dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c, I added the possibility of using unhardened derivation steps in the key origin information (while keeping the restriction for `change`/`address_index` in the key placeholders).\r\nWhile most wallets use hardened derivations for all but the last two steps, there are deployed use cases with unhardened derivations, and this only adds negligible implementation complexity to wallet policies.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1401619046",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "referenced",
      "id": 8502859196,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAH6z1W8",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8502859196",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "873942a31c00ab2cf6a0f679b763bf053c18db2c",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/873942a31c00ab2cf6a0f679b763bf053c18db2c",
      "created_at": "2023-02-13T10:41:30Z"
    },
    {
      "event": "referenced",
      "id": 8502902787,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAH60AAD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8502902787",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "9883c6ca10fd4fdd5653cdf2281f366a9adfd1db",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/9883c6ca10fd4fdd5653cdf2281f366a9adfd1db",
      "created_at": "2023-02-13T10:46:03Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-13T11:15:32Z",
      "updated_at": "2023-02-13T11:15:32Z",
      "source": {
        "issue": {
          "id": 1582155399,
          "node_id": "PR_kwDOBawtqs5J1vJJ",
          "url": "https://api.github.com/repos/ElementsProject/libwally-core/issues/369",
          "repository_url": "https://api.github.com/repos/ElementsProject/libwally-core",
          "labels_url": "https://api.github.com/repos/ElementsProject/libwally-core/issues/369/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/ElementsProject/libwally-core/issues/369/comments",
          "events_url": "https://api.github.com/repos/ElementsProject/libwally-core/issues/369/events",
          "html_url": "https://github.com/ElementsProject/libwally-core/pull/369",
          "number": 369,
          "state": "closed",
          "state_reason": null,
          "title": "descriptor: Implement wallet-policies BIP",
          "body": "See https://github.com/bitcoin/bips/pull/1389 for details of wallet policies.\r\n\r\nNote wally implements the `/*` extension to support non-BIP44 wallets such as Blockstream Green. Additionally, we do not limit allowable policies to the whitelist in the linked BIP. We allow all valid descriptors where the solved cardinality is either 1 or 2.\r\n\r\nIncludes some extra functionality that is useful for validating descriptors/policies, primarily the ability to iterate and query the keys in the parsed expression.",
          "user": {
            "login": "jgriffiths",
            "id": 406223,
            "node_id": "MDQ6VXNlcjQwNjIyMw==",
            "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jgriffiths",
            "html_url": "https://github.com/jgriffiths",
            "followers_url": "https://api.github.com/users/jgriffiths/followers",
            "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
            "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
            "repos_url": "https://api.github.com/users/jgriffiths/repos",
            "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 0,
          "pull_request": {
            "url": "https://api.github.com/repos/ElementsProject/libwally-core/pulls/369",
            "html_url": "https://github.com/ElementsProject/libwally-core/pull/369",
            "diff_url": "https://github.com/ElementsProject/libwally-core/pull/369.diff",
            "patch_url": "https://github.com/ElementsProject/libwally-core/pull/369.patch"
          },
          "closed_at": "2023-09-25T20:06:11Z",
          "created_at": "2023-02-13T11:15:32Z",
          "updated_at": "2023-09-25T20:08:11Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1295456080,
      "node_id": "PRR_kwDOAN28mc5NNxdQ",
      "url": null,
      "actor": null,
      "commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1295456080",
      "submitted_at": "2023-02-13T11:52:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1300535952,
      "node_id": "PRR_kwDOAN28mc5NhJqQ",
      "url": null,
      "actor": null,
      "commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1300535952",
      "submitted_at": "2023-02-15T23:41:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8568161101,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAH-s8NN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568161101",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:30:09Z"
    },
    {
      "event": "commented",
      "id": 1438086314,
      "node_id": "IC_kwDOAN28mc5Vt3Sq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1438086314",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:05Z",
      "updated_at": "2023-02-21T08:55:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @jgriffiths and @bucko13 for the reviews!\r\nI addressed most of the comments in da3e117d075f4428f14d4120124d840682e5587d.\r\n\r\nIn bb98f8017a883262e03127ab718514abf4a5e5f9 I deleted the examples coming from HTLC miniscripts; they don't quite make sense as wallet policies.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1438086314",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 8568390758,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAH-t0Rm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390758",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "subscribed",
      "id": 8568390779,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAH-t0R7",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390779",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "mentioned",
      "id": 8568390809,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAH-t0SZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390809",
      "actor": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "subscribed",
      "id": 8568390849,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAH-t0TB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390849",
      "actor": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-15T03:13:22Z",
      "updated_at": "2023-04-15T03:13:22Z",
      "source": {
        "issue": {
          "id": 1616152538,
          "node_id": "PR_kwDOB0Kp2s5Lnhw-",
          "url": "https://api.github.com/repos/lightningdevkit/rust-lightning/issues/2089",
          "repository_url": "https://api.github.com/repos/lightningdevkit/rust-lightning",
          "labels_url": "https://api.github.com/repos/lightningdevkit/rust-lightning/issues/2089/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/lightningdevkit/rust-lightning/issues/2089/comments",
          "events_url": "https://api.github.com/repos/lightningdevkit/rust-lightning/issues/2089/events",
          "html_url": "https://github.com/lightningdevkit/rust-lightning/pull/2089",
          "number": 2089,
          "state": "closed",
          "state_reason": null,
          "title": "Add BumpTransaction event handler",
          "body": "This allows users to bump their commitments and HTLC transactions without having to worry about all the little details to do so. Instead, we'll just require them to implement a small shim over their wallet/UTXO source, that grants the event handler permission to spend confirmed UTXOs for the transactions it'll produce.\r\n\r\nWhile the event handler should in most cases produce valid transactions, assuming the provided confirmed UTXOs are valid, it may not produce relayable transactions due to not satisfying certain Replace-By-Fee (RBF) mempool policy requirements. Some of these require that the replacement transactions have a higher feerate and absolute fee than the conflicting transactions it aims to replace. To make sure we adhere to these requirements, we'd have to persist some state for all transactions the event handler has produced, greatly increasing its complexity. While we may consider implementing so in the future, we choose to go with a simple initial version that relies on the `OnchainTxHandler`'s bumping frequency. For each new bumping attempt, the `OnchainTxHandler` proposes a 25% feerate increase to ensure transactions can propagate under constrained mempool circumstances.",
          "user": {
            "login": "wpaulino",
            "id": 9447167,
            "node_id": "MDQ6VXNlcjk0NDcxNjc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/9447167?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wpaulino",
            "html_url": "https://github.com/wpaulino",
            "followers_url": "https://api.github.com/users/wpaulino/followers",
            "following_url": "https://api.github.com/users/wpaulino/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/wpaulino/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/wpaulino/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/wpaulino/subscriptions",
            "organizations_url": "https://api.github.com/users/wpaulino/orgs",
            "repos_url": "https://api.github.com/users/wpaulino/repos",
            "events_url": "https://api.github.com/users/wpaulino/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/wpaulino/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 4885474239,
              "node_id": "LA_kwDOB0Kp2s8AAAABIzJrvw",
              "url": "https://api.github.com/repos/lightningdevkit/rust-lightning/labels/Anchor%20Support",
              "name": "Anchor Support",
              "description": "",
              "color": "FA9362",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/lightningdevkit/rust-lightning/milestones/33",
            "html_url": "https://github.com/lightningdevkit/rust-lightning/milestone/33",
            "labels_url": "https://api.github.com/repos/lightningdevkit/rust-lightning/milestones/33/labels",
            "id": 9193181,
            "node_id": "MI_kwDOB0Kp2s4AjEbd",
            "number": 33,
            "state": "closed",
            "title": "0.0.116",
            "description": "Anchoring the Roadmap",
            "creator": {
              "login": "TheBlueMatt",
              "id": 649246,
              "node_id": "MDQ6VXNlcjY0OTI0Ng==",
              "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/TheBlueMatt",
              "html_url": "https://github.com/TheBlueMatt",
              "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
              "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
              "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
              "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
              "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 71,
            "created_at": "2023-03-22T18:26:54Z",
            "updated_at": "2023-07-22T03:03:33Z",
            "closed_at": "2023-07-22T03:03:14Z"
          },
          "locked": false,
          "comments": 7,
          "pull_request": {
            "url": "https://api.github.com/repos/lightningdevkit/rust-lightning/pulls/2089",
            "html_url": "https://github.com/lightningdevkit/rust-lightning/pull/2089",
            "diff_url": "https://github.com/lightningdevkit/rust-lightning/pull/2089.diff",
            "patch_url": "https://github.com/lightningdevkit/rust-lightning/pull/2089.patch"
          },
          "closed_at": "2023-06-19T22:45:56Z",
          "created_at": "2023-03-08T23:41:05Z",
          "updated_at": "2023-06-20T19:20:36Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-02T13:02:46Z",
      "updated_at": "2023-05-02T13:02:46Z",
      "source": {
        "issue": {
          "id": 1683144023,
          "node_id": "I_kwDOF72rbM5kUr1X",
          "url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/153",
          "repository_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new",
          "labels_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/153/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/153/comments",
          "events_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/153/events",
          "html_url": "https://github.com/LedgerHQ/app-bitcoin-new/issues/153",
          "number": 153,
          "state": "closed",
          "state_reason": "completed",
          "title": "2-of-2 multisig spends without co-signer key constraint",
          "body": "I am investigating the possibility of signing transactions of the following type using a ledger device:\r\n\r\n`multi(2, @0, <any>)` -> external destination\r\n\r\nThe user would only verify the external destination on the screen. `@0` is the ledger device key. The co-signer key `<any>` is any key, no restrictions. Because there are no outputs to a multisig address, it seems the usual security concerns do not apply here.\r\n\r\nI tend to think that this shouldn't require a registered wallet policy, but is that possible with the current version of `app-bitcoin-new`?",
          "user": {
            "login": "joostjager",
            "id": 4638168,
            "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/joostjager",
            "html_url": "https://github.com/joostjager",
            "followers_url": "https://api.github.com/users/joostjager/followers",
            "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
            "organizations_url": "https://api.github.com/users/joostjager/orgs",
            "repos_url": "https://api.github.com/users/joostjager/repos",
            "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/joostjager/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 21,
          "closed_at": "2023-11-27T11:18:21Z",
          "created_at": "2023-04-25T13:07:54Z",
          "updated_at": "2023-11-27T11:18:21Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1409290224,
      "node_id": "PRR_kwDOAN28mc5UAA_w",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1409290224",
      "submitted_at": "2023-05-02T14:54:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1409307273,
      "node_id": "PRR_kwDOAN28mc5UAFKJ",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1409307273",
      "submitted_at": "2023-05-02T15:02:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1476612443,
      "node_id": "PRR_kwDOAN28mc5YA1Fb",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1476612443",
      "submitted_at": "2023-06-13T08:49:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "referenced",
      "id": 9574418529,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rghh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574418529",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "08845763542f78f068031e66f36b5167d87b6782",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/08845763542f78f068031e66f36b5167d87b6782",
      "created_at": "2023-06-20T03:18:04Z"
    },
    {
      "event": "referenced",
      "id": 9574418538,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rghq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574418538",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "996cb79f357a7304c6ce3477c78e9726592ffc12",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/996cb79f357a7304c6ce3477c78e9726592ffc12",
      "created_at": "2023-06-20T03:18:04Z"
    },
    {
      "event": "referenced",
      "id": 9574425845,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6riT1",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574425845",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "59b047a96f92203a89e22b9cd1adc1fe648cfd43",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/59b047a96f92203a89e22b9cd1adc1fe648cfd43",
      "created_at": "2023-06-20T03:20:17Z"
    },
    {
      "event": "referenced",
      "id": 9574443465,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rmnJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574443465",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "78671aec91f39690a463835670320784815eae4c",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/78671aec91f39690a463835670320784815eae4c",
      "created_at": "2023-06-20T03:25:29Z"
    },
    {
      "event": "referenced",
      "id": 9574449109,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rn_V",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574449109",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0468931b933eb39676ca48f1e5b0a655e6054982",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/0468931b933eb39676ca48f1e5b0a655e6054982",
      "created_at": "2023-06-20T03:27:09Z"
    },
    {
      "event": "referenced",
      "id": 9583233465,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7NIm5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583233465",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0a88519fe2ad1e109278e34d20cbf8acd7a4c5ab",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/0a88519fe2ad1e109278e34d20cbf8acd7a4c5ab",
      "created_at": "2023-06-20T18:57:39Z"
    },
    {
      "event": "referenced",
      "id": 9583233496,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7NInY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583233496",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4069cb5c352c4f6007b8766972194536cbd005ea",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/4069cb5c352c4f6007b8766972194536cbd005ea",
      "created_at": "2023-06-20T18:57:40Z"
    },
    {
      "event": "referenced",
      "id": 9583687445,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7O3cV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583687445",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "808dc7c3ffb925176751129d8f3c8aa452d24f81",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/808dc7c3ffb925176751129d8f3c8aa452d24f81",
      "created_at": "2023-06-20T19:50:51Z"
    },
    {
      "event": "referenced",
      "id": 9671202515,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJActbT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9671202515",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5196443f10052be0ac4317d23f9ad3c422263368",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/5196443f10052be0ac4317d23f9ad3c422263368",
      "created_at": "2023-06-29T00:14:49Z"
    },
    {
      "event": "referenced",
      "id": 9671202524,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJActbc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9671202524",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5625aec043480ea48c9cf6e1a8d6d7ac032008d3",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/5625aec043480ea48c9cf6e1a8d6d7ac032008d3",
      "created_at": "2023-06-29T00:14:49Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-11T13:06:23Z",
      "updated_at": "2023-07-11T13:06:23Z",
      "source": {
        "issue": {
          "id": 1227630855,
          "node_id": "I_kwDOC1uO3M5JLCkH",
          "url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/911",
          "repository_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware",
          "labels_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/911/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/911/comments",
          "events_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/911/events",
          "html_url": "https://github.com/digitalbitbox/bitbox02-firmware/issues/911",
          "number": 911,
          "state": "closed",
          "state_reason": "completed",
          "title": "Output Script Descriptor (with Miniscript) support",
          "body": "[Output Script Descriptor](https://github.com/bitcoin/bips/blob/master/bip-0380.mediawiki#motivation) are a sane standard for wallet backups. They express all the information necessary to locate owned (or partially owned) outputs in an engineer-readable format, avoiding the pitfalls of previously used implicit hacks to recover only from a mnemonic.\r\n\r\n[Miniscript](https://bitcoin.sipa.be/miniscript/) is an extension to Output Script Descriptors, which defines a language to reason about a subset of Script. Miniscript allows to:\r\n1. Safely write more complicated contracts than the basic well-known templates\r\n2. Produce a valid witness for any Script that is a valid Miniscript, given the necessary material (signature, etc)\r\n3. Statically analyse the properties of any Script that is a valid Miniscript: determine the semantics of the contract, whether it is non-malleable, whether some spending paths may exceed standardness or consensus limits --in short, whether it's safe to participate in such a Script.\r\n\r\nMiniscript also guarantees consensus soundness (unless the conditions of the Miniscript are met, no witness can be created for the Script) and standardness completeness (for any Miniscript that was analysed as sane, a witness can be constructed in the bounds of the consensus and standardness rules).\r\n\r\nOutput Script Descriptors along with Miniscript are particularly appealing to signing devices, as it permits the user of this device to safely take part in more complex contracts. It also gives a framework to add support for new Scripts, instead of relying on hard-coded Script templates and footgun-y backup solutions.\r\n\r\nOutput descriptors have been in Bitcoin Core for a while now, and [Miniscript was merged into Bitcoin Core](https://github.com/bitcoin/bitcoin/pull/24147) mainline this year. The [Specter](https://github.com/cryptoadvance/specter-diy) signing device added support for Output descriptors and Miniscript more than a year ago. [Ledger added support](https://blog.ledger.com/bitcoin-2/) for (a subset of) output descriptors last year and is [currently working toward Miniscript](https://blog.ledger.com/miniscript-is-coming/) support.\r\nIs there any plan to implement to implement Output Script Descriptors (with Miniscript) for the Bitbox2?",
          "user": {
            "login": "darosior",
            "id": 22457751,
            "node_id": "MDQ6VXNlcjIyNDU3NzUx",
            "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/darosior",
            "html_url": "https://github.com/darosior",
            "followers_url": "https://api.github.com/users/darosior/followers",
            "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
            "organizations_url": "https://api.github.com/users/darosior/orgs",
            "repos_url": "https://api.github.com/users/darosior/repos",
            "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/darosior/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignee": {
            "login": "benma",
            "id": 1225267,
            "node_id": "MDQ6VXNlcjEyMjUyNjc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/benma",
            "html_url": "https://github.com/benma",
            "followers_url": "https://api.github.com/users/benma/followers",
            "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
            "organizations_url": "https://api.github.com/users/benma/orgs",
            "repos_url": "https://api.github.com/users/benma/repos",
            "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/benma/received_events",
            "type": "User",
            "site_admin": false
          },
          "assignees": [
            {
              "login": "benma",
              "id": 1225267,
              "node_id": "MDQ6VXNlcjEyMjUyNjc=",
              "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/benma",
              "html_url": "https://github.com/benma",
              "followers_url": "https://api.github.com/users/benma/followers",
              "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
              "organizations_url": "https://api.github.com/users/benma/orgs",
              "repos_url": "https://api.github.com/users/benma/repos",
              "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/benma/received_events",
              "type": "User",
              "site_admin": false
            }
          ],
          "author_association": "NONE",
          "locked": false,
          "comments": 4,
          "closed_at": "2023-10-10T11:45:44Z",
          "created_at": "2022-05-06T09:30:42Z",
          "updated_at": "2023-10-10T11:46:30Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1671755616,
      "node_id": "IC_kwDOAN28mc5jpPdg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1671755616",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:39Z",
      "updated_at": "2023-08-09T16:27:39Z",
      "author_association": "MEMBER",
      "body": "@luke-jr can this be assigned a BIP number?",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1671755616",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10049842647,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJXBG3X",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10049842647",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:40Z"
    },
    {
      "event": "subscribed",
      "id": 10049842660,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJXBG3k",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10049842660",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:40Z"
    },
    {
      "event": "referenced",
      "id": 10294491363,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJlmXjj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10294491363",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2dff714959917b44043e033469f9d876951bb81a",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/2dff714959917b44043e033469f9d876951bb81a",
      "created_at": "2023-09-06T11:08:33Z"
    },
    {
      "event": "referenced",
      "id": 10306742071,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJmVGc3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10306742071",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8e4fc85ab53883505ed7d65aee4eec25478d98bc",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/8e4fc85ab53883505ed7d65aee4eec25478d98bc",
      "created_at": "2023-09-07T12:21:48Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-08T11:45:56Z",
      "updated_at": "2023-09-08T11:45:56Z",
      "source": {
        "issue": {
          "id": 1886628940,
          "node_id": "I_kwDOC1uO3M5wc6xM",
          "url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/1126",
          "repository_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware",
          "labels_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/1126/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/1126/comments",
          "events_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/1126/events",
          "html_url": "https://github.com/digitalbitbox/bitbox02-firmware/issues/1126",
          "number": 1126,
          "state": "closed",
          "state_reason": "completed",
          "title": "Not able to sign timelocked PSBT via HWI without wallet registration",
          "body": "I know it is a feature and not a bug - but maybe there is some way to solve that, since it works for non-timelocked multisigs.\r\n\r\nWhat I get is \r\n```\r\nBitBox02 attestation check PASSED\r\n{\"error\": \"Input or change script type not recognized.\", \"code\": -7}\r\n```\r\n\r\nDescriptor is \r\n```\r\nwsh(or_i(\r\n    multi(3,\r\n            [362a0411/48h/0h/0h/2h]xpub6DnLtr7gtXNFZJcDLni2ezMrtaQRLDQTvW8rdyWn33pWUymmeocvNTaQyBZWEYPosEJehmfsbe2A8Tg9jS2YwKWjiwAkuRZ6vzVjFs52Juf/<0;1>/*,\r\n            [dbd96ebc/48h/0h/0h/2h]xpub6F8HEj83d5th3okdS2eJ4r1eNmcHw7VtLUzqnMRq6KNr7bajS8hKUUUzxjAvRMH5jdbzpR3qfBRhKfsTpBYFu6Pba1UjKLZN95sB8DEo3Ja/<0;1>/*,\r\n            [feda4d11/48h/0h/0h/2h]xpub6EgHtjXXbGmVHEuKw49fke3iqXoo5vTx2bjHaTkE9ozbo25h7eU4SuNUSAGmNnw2rD2MPxm7e5pzCxSgpyJfuzc7QwHbsNBe8vfqnEjhGW6/<0;1>/*\r\n    ), \r\n    andor(multi(1,\r\n            [362a0411/48h/0h/2h/2h]xpub6EynZEts5RmopiuAcaiF1vWnGHmNxvgrqmvvXGtyCJVRdZGP7bpRcGt7xVQUfWRQAQk8wNYdnMg5bxr38HkGYMQCkVxorUMCvphZy5HgPwU/<0;1>/*,\r\n            [dbd96ebc/48h/0h/2h/2h]xpub6EgSRG4jge1K5rdMQFe24VSHXSYzjzFF7FvPWAkz7vWs4E7abo1i34AcyZsHhXwvpDzjEv2MqTMXBcATVfH2En3YJfpvgpE25JHRxF87Sus/<0;1>/*,\r\n            [feda4d11/48h/0h/2h/2h]xpub6DkehEoVVoixuc9aqWdPvUAFy9zWbdigqcF6DPQThESgkJbU1TCS2iSXjB7BP2ToGgU5yErX2Ev1fp88b81NW3UGzyHdV3AsFGw7s2KEQRi/<0;1>/*),\r\n            older(4255897),\r\n    and_v(v:multi(2,\r\n            [362a0411/48h/0h/1h/2h]xpub6DnFr7Ff8NbjcdrN2awC164Dgz64JHFCYF6YK18fqVqjZFUwQPQRyz38LR4C6QzLkHfbnttUPqWwL4FEvoA4uzS86YssWN8emQZjXiyuPtz/<0;1>/*,\r\n            [dbd96ebc/48h/0h/1h/2h]xpub6EyjEwQ2rzHYttiTJUPW8sJxpnQhGDJCnBjK73ZGChK512fKfcdGQWhPoagrYhdJR8N1NcPKXwaTyh8tTLkj7Ej3bsZpYBNFiB2ZRQ8NyDa/<0;1>/*,\r\n            [feda4d11/48h/0h/1h/2h]xpub6EmMNcU5bZKw6Xq1wbjTwhnVkG14vjhA9mvjii2Mk3QW8byAYahqJm7qYJaT2gAANviWgSu7xs7n2rn4ndnZGbhnDWbZdT1V2PuU6uaDyMe/<0;1>/*),\r\n            after(1735689600)))))\r\n```\r\n\r\nPSBT is\r\n```\r\ncHNidP8BAFICAAAAASXBTaCNPS6qvR5GCFdjXDS5axe2fUfqsvpGV/ZGS5G7AAAAAAD9////Ac0BAAAAAAAAFgAUYLlCcpDeQDVWvogTYvXdl9WrLevmNAsATwEEiLIeBB3mM8yAAAACoI52PAvM15x1l2UN9/FXJ1IKkM8sTrhIu2uJMGDKJmwDE3k+Yo8GntAiSwsBlAqyBludB7E+uiinHVK8IK7yRWUU/tpNETAAAIAAAACAAgAAgAIAAIBPAQSIsh4EIaqojYAAAALk8s98JdgslIjNHNg8Q8LUKnEGVaOsMYq+wMpABV+IlANCRGGG/oLgrr1xGKAIWJlRlPRXXHctYlfSlNVIu+Od5xQ2KgQRMAAAgAAAAIABAACAAgAAgE8BBIiyHgQh3uopgAAAApYWSvGyPwA478hFMZASbs4ZfN3HX8PkxsLzBD6QaJstAlLRPfVyqA0UaidITf+u7AN7hmPc4y1X7KpUDNeUQs9lFDYqBBEwAACAAAAAgAAAAIACAACATwEEiLIeBJu55nKAAAACgCw2Cr9w/jZPXqziUxOUJXcG4Hok1qov9oILsTfgVe0CwJDpmbcmGLgmbZppKOR3wq9XR8o6QpristcopneM37MU/tpNETAAAIAAAACAAAAAgAIAAIBPAQSIsh4EnBItW4AAAAJdVTZLqFVQZT1XoBg6uPe4iiZM2vO8asAQTLBkY2/ouwN0HIvYJbHLPy2agVHcc1o3W1R1DxKohzKR3fWf4hCMMRTb2W68MAAAgAAAAIACAACAAgAAgE8BBIiyHgSnmHGGgAAAAkIScKz40q7/ldPXo8XTk7kIJ9Zbyuacsyct4Hd5tyjeAuJkwomsZNtHWOnOXqmjhG7I/b5qFB4EkEsDdqJru9FoFP7aTREwAACAAAAAgAEAAIACAACATwEEiLIeBMSg3YKAAAAC+pqzLMN+sCRIyUSy6joi+vAmcNT79y7TWQ+f9TGt9a8DGZZoE4Q2wT7if6PAXroDLhQX3uLnj4UUsQH6qlhRPBsU29luvDAAAIAAAACAAQAAgAIAAIBPAQSIsh4ExMMxU4AAAAKRSY8cmwKapqXPRnfaeUV7W9OGCzUBkTOeDGdahxaZYgPJY4Fps53xfoH8ZBIdGJmrhwSDiTn9hwyioVpcW6FKnhQ2KgQRMAAAgAAAAIACAACAAgAAgE8BBIiyHgTYsCYSgAAAAnCwHzlI8niTyPXJSkHhJ8tY8v95FLCbGFRCpnWsUyQTApjw5Us+xgoFIwrwFlHZi0J5sAjBEsHs3QKEeqY9h2LwFNvZbrwwAACAAAAAgAAAAIACAACAEPwJTXlDaXRhZGVsADYqBBEGYml0Ym94EPwJTXlDaXRhZGVsANvZbrwHbGVkZ2VycxD8CU15Q2l0YWRlbAD+2k0RB2xlZGdlcngAAQBeAgAAAAHbNEY1Pt0NXS2iVuHx1e1LQAEyKwr0/6B9kOyHrlMIAwAAAAAA/f///wFMAwAAAAAAACIAIMqifl87hvgRLE9CZObEFnU6ivXsg3CsyQLlblDVaKpy5jQLAAEBK0wDAAAAAAAAIgAgyqJ+XzuG+BEsT0Jk5sQWdTqK9eyDcKzJAuVuUNVoqnIBAwQBAAAAAQX9TAFjUyECe71bmLmw7veVKqQIGsIfOc+8osIePjeqnefJIv2URochA8FAk81unqFF2NZ4i/LvZqansSFSQCWzMUgM1/Pd7ifSIQIVl1AlMNr7+xEoGf0dgznJhdJV14l8S3ptvgvbf3+e5lOuZ1EhAputjaPGw3LMNNYt96mb7gyS00KaVTK3woGpoNkC2enfIQPtLK6QVtwsjQeImna88nk6WfgBpPreFhmn3ZuFYe8DmiEDUCFulwOwZ+YE+PpZ4idGXOAH9jL/+SRqTwGspRbIWttTrmRSIQMralk4UO+D7915SCZZgA2GCMSiNf23JRdUPfwP+GBDbiEDj+cYks0De3c9rsVKWrhwfP+tJVhhPrq3eR6GyfHrcXIhAx7ERqswS9MXz2iIHeFw59foRkY3Vu+KI+rUaky184rzU68EgIV0Z7FnA5nwQLJoaCIGAhWXUCUw2vv7ESgZ/R2DOcmF0lXXiXxLem2+C9t/f57mHP7aTREwAACAAAAAgAAAAIACAACAAAAAAAAAAAAiBgJ7vVuYubDu95UqpAgawh85z7yiwh4+N6qd58ki/ZRGhxw2KgQRMAAAgAAAAIAAAACAAgAAgAAAAAAAAAAAIgYCm62No8bDcsw01i33qZvuDJLTQppVMrfCgamg2QLZ6d8cNioEETAAAIAAAACAAgAAgAIAAIAAAAAAAAAAACIGAx7ERqswS9MXz2iIHeFw59foRkY3Vu+KI+rUaky184rzHP7aTREwAACAAAAAgAEAAIACAACAAAAAAAAAAAAiBgMralk4UO+D7915SCZZgA2GCMSiNf23JRdUPfwP+GBDbhw2KgQRMAAAgAAAAIABAACAAgAAgAAAAAAAAAAAIgYDUCFulwOwZ+YE+PpZ4idGXOAH9jL/+SRqTwGspRbIWtsc/tpNETAAAIAAAACAAgAAgAIAAIAAAAAAAAAAACIGA4/nGJLNA3t3Pa7FSlq4cHz/rSVYYT66t3kehsnx63FyHNvZbrwwAACAAAAAgAEAAIACAACAAAAAAAAAAAAiBgPBQJPNbp6hRdjWeIvy72amp7EhUkAlszFIDNfz3e4n0hzb2W68MAAAgAAAAIAAAACAAgAAgAAAAAAAAAAAIgYD7SyukFbcLI0HiJp2vPJ5Oln4AaT63hYZp92bhWHvA5oc29luvDAAAIAAAACAAgAAgAIAAIAAAAAAAAAAAAAA\r\n```\r\n\r\nTxid which is being spent: [`bb914b46f65746fab2ea477db6176bb9345c635708461ebdaa2e3d8da04dc125:0`](https://mempool.space/tx/bb914b46f65746fab2ea477db6176bb9345c635708461ebdaa2e3d8da04dc125)\r\n\r\nYes, that's mainnet. I do write code and debug it only on mainnet, not testnet. Because that is the way.\r\n\r\nAnd yes, I know, that is a crazy descriptor. Here is what it means:\r\n![Screenshot from 2023-09-08 00-19-39](https://github.com/digitalbitbox/bitbox02-firmware/assets/372034/cead0882-f093-4deb-9070-5bd5a36620d3)\r\n![Screenshot from 2023-09-08 00-20-22](https://github.com/digitalbitbox/bitbox02-firmware/assets/372034/3f9067d7-0006-4b2b-a94c-2166ef8494c4)\r\n\r\nFor debug purposes, here is interpretation of PSBT content:\r\n```yaml\r\npsbt_version: V0\r\ntx_version: 2\r\nfallback_locktime: 734438\r\ninputs:\r\n- index: 0\r\n  previous_outpoint: bb914b46f65746fab2ea477db6176bb9345c635708461ebdaa2e3d8da04dc125:0\r\n  sequence_number: 4294967293\r\n  required_time_locktime: null\r\n  required_height_locktime: null\r\n  non_witness_utxo:\r\n    version: 2\r\n    lock_time: 734438\r\n    input:\r\n    - previous_output: 030853ae87ec907da0fff40a2b3201404bedd5f1e156a22d5d0ddd3e354634db:0\r\n      script_sig: ''\r\n      sequence: 4294967293\r\n      witness: []\r\n    output:\r\n    - value: 844\r\n      script_pubkey: 0020caa27e5f3b86f8112c4f4264e6c416753a8af5ec8370acc902e56e50d568aa72\r\n  witness_utxo:\r\n    value: 844\r\n    script_pubkey: 0020caa27e5f3b86f8112c4f4264e6c416753a8af5ec8370acc902e56e50d568aa72\r\n  partial_sigs: {}\r\n  sighash_type:\r\n    inner: 1\r\n  redeem_script: null\r\n  witness_script: 635321027bbd5b98b9b0eef7952aa4081ac21f39cfbca2c21e3e37aa9de7c922fd9446872103c14093cd6e9ea145d8d6788bf2ef66a6a7b121524025b331480cd7f3ddee27d221021597502530dafbfb112819fd1d8339c985d255d7897c4b7a6dbe0bdb7f7f9ee653ae675121029bad8da3c6c372cc34d62df7a99bee0c92d3429a5532b7c281a9a0d902d9e9df2103ed2cae9056dc2c8d07889a76bcf2793a59f801a4fade1619a7dd9b8561ef039a210350216e9703b067e604f8fa59e227465ce007f632fff9246a4f01aca516c85adb53ae645221032b6a593850ef83efdd79482659800d8608c4a235fdb72517543dfc0ff860436e21038fe71892cd037b773daec54a5ab8707cffad2558613ebab7791e86c9f1eb717221031ec446ab304bd317cf68881de170e7d7e846463756ef8a23ead46a4cb5f38af353af0480857467b1670399f040b26868\r\n  bip32_derivation:\r\n    021597502530dafbfb112819fd1d8339c985d255d7897c4b7a6dbe0bdb7f7f9ee6:\r\n    - feda4d11\r\n    - m/48'/0'/0'/2'/0/0\r\n    027bbd5b98b9b0eef7952aa4081ac21f39cfbca2c21e3e37aa9de7c922fd944687:\r\n    - 362a0411\r\n    - m/48'/0'/0'/2'/0/0\r\n    029bad8da3c6c372cc34d62df7a99bee0c92d3429a5532b7c281a9a0d902d9e9df:\r\n    - 362a0411\r\n    - m/48'/0'/2'/2'/0/0\r\n    031ec446ab304bd317cf68881de170e7d7e846463756ef8a23ead46a4cb5f38af3:\r\n    - feda4d11\r\n    - m/48'/0'/1'/2'/0/0\r\n    032b6a593850ef83efdd79482659800d8608c4a235fdb72517543dfc0ff860436e:\r\n    - 362a0411\r\n    - m/48'/0'/1'/2'/0/0\r\n    0350216e9703b067e604f8fa59e227465ce007f632fff9246a4f01aca516c85adb:\r\n    - feda4d11\r\n    - m/48'/0'/2'/2'/0/0\r\n    038fe71892cd037b773daec54a5ab8707cffad2558613ebab7791e86c9f1eb7172:\r\n    - dbd96ebc\r\n    - m/48'/0'/1'/2'/0/0\r\n    03c14093cd6e9ea145d8d6788bf2ef66a6a7b121524025b331480cd7f3ddee27d2:\r\n    - dbd96ebc\r\n    - m/48'/0'/0'/2'/0/0\r\n    03ed2cae9056dc2c8d07889a76bcf2793a59f801a4fade1619a7dd9b8561ef039a:\r\n    - dbd96ebc\r\n    - m/48'/0'/2'/2'/0/0\r\n  final_script_sig: null\r\n  final_script_witness: null\r\n  ripemd160_preimages: {}\r\n  sha256_preimages: {}\r\n  hash160_preimages: {}\r\n  hash256_preimages: {}\r\n  tap_key_sig: null\r\n  tap_script_sigs: {}\r\n  tap_scripts: {}\r\n  tap_key_origins: {}\r\n  tap_internal_key: null\r\n  tap_merkle_root: null\r\n  proprietary: {}\r\n  unknown: {}\r\noutputs:\r\n- index: 0\r\n  amount: 461\r\n  script: 001460b9427290de403556be881362f5dd97d5ab2deb\r\n  redeem_script: null\r\n  witness_script: null\r\n  bip32_derivation: {}\r\n  tap_internal_key: null\r\n  tap_tree: null\r\n  tap_key_origins: {}\r\n  proprietary: {}\r\n  unknown: {}\r\nxpub:\r\n  xpub6DkehEoVVoixuc9aqWdPvUAFy9zWbdigqcF6DPQThESgkJbU1TCS2iSXjB7BP2ToGgU5yErX2Ev1fp88b81NW3UGzyHdV3AsFGw7s2KEQRi:\r\n  - feda4d11\r\n  - m/48'/0'/2'/2'\r\n  xpub6DnFr7Ff8NbjcdrN2awC164Dgz64JHFCYF6YK18fqVqjZFUwQPQRyz38LR4C6QzLkHfbnttUPqWwL4FEvoA4uzS86YssWN8emQZjXiyuPtz:\r\n  - 362a0411\r\n  - m/48'/0'/1'/2'\r\n  xpub6DnLtr7gtXNFZJcDLni2ezMrtaQRLDQTvW8rdyWn33pWUymmeocvNTaQyBZWEYPosEJehmfsbe2A8Tg9jS2YwKWjiwAkuRZ6vzVjFs52Juf:\r\n  - 362a0411\r\n  - m/48'/0'/0'/2'\r\n  xpub6EgHtjXXbGmVHEuKw49fke3iqXoo5vTx2bjHaTkE9ozbo25h7eU4SuNUSAGmNnw2rD2MPxm7e5pzCxSgpyJfuzc7QwHbsNBe8vfqnEjhGW6:\r\n  - feda4d11\r\n  - m/48'/0'/0'/2'\r\n  xpub6EgSRG4jge1K5rdMQFe24VSHXSYzjzFF7FvPWAkz7vWs4E7abo1i34AcyZsHhXwvpDzjEv2MqTMXBcATVfH2En3YJfpvgpE25JHRxF87Sus:\r\n  - dbd96ebc\r\n  - m/48'/0'/2'/2'\r\n  xpub6EmMNcU5bZKw6Xq1wbjTwhnVkG14vjhA9mvjii2Mk3QW8byAYahqJm7qYJaT2gAANviWgSu7xs7n2rn4ndnZGbhnDWbZdT1V2PuU6uaDyMe:\r\n  - feda4d11\r\n  - m/48'/0'/1'/2'\r\n  xpub6EyjEwQ2rzHYttiTJUPW8sJxpnQhGDJCnBjK73ZGChK512fKfcdGQWhPoagrYhdJR8N1NcPKXwaTyh8tTLkj7Ej3bsZpYBNFiB2ZRQ8NyDa:\r\n  - dbd96ebc\r\n  - m/48'/0'/1'/2'\r\n  xpub6EynZEts5RmopiuAcaiF1vWnGHmNxvgrqmvvXGtyCJVRdZGP7bpRcGt7xVQUfWRQAQk8wNYdnMg5bxr38HkGYMQCkVxorUMCvphZy5HgPwU:\r\n  - 362a0411\r\n  - m/48'/0'/2'/2'\r\n  xpub6F8HEj83d5th3okdS2eJ4r1eNmcHw7VtLUzqnMRq6KNr7bajS8hKUUUzxjAvRMH5jdbzpR3qfBRhKfsTpBYFu6Pba1UjKLZN95sB8DEo3Ja:\r\n  - dbd96ebc\r\n  - m/48'/0'/0'/2'\r\nproprietary:\r\n  ? prefix: 4d794369746164656c\r\n    subtype: 0\r\n    key: 362a0411\r\n  : 626974626f78\r\n  ? prefix: 4d794369746164656c\r\n    subtype: 0\r\n    key: dbd96ebc\r\n  : 6c656467657273\r\n  ? prefix: 4d794369746164656c\r\n    subtype: 0\r\n    key: feda4d11\r\n  : 6c656467657278\r\nunknown: {}\r\n```",
          "user": {
            "login": "dr-orlovsky",
            "id": 372034,
            "node_id": "MDQ6VXNlcjM3MjAzNA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dr-orlovsky",
            "html_url": "https://github.com/dr-orlovsky",
            "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
            "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
            "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
            "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
            "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 1393660993,
              "node_id": "MDU6TGFiZWwxMzkzNjYwOTkz",
              "url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/labels/wontfix",
              "name": "wontfix",
              "description": "This will not be worked on",
              "color": "ffffff",
              "default": true
            }
          ],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 9,
          "closed_at": "2023-09-09T17:24:04Z",
          "created_at": "2023-09-07T22:23:54Z",
          "updated_at": "2023-09-10T17:23:07Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1713259908,
      "node_id": "IC_kwDOAN28mc5mHkWE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713259908",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T06:40:59Z",
      "updated_at": "2023-09-11T06:40:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "After @benma suggestion I propose to merge my recent proposal <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-September/021946.html> with this standard. \r\n\r\nSpecifically, I think we can remove unnecessary remaining ambiguity, when multiple keys need to repeat the same data (BIP44 purpose, coin, change derivation path segments) and make descriptors even shorter, more readable and standards, removing key list as a separate structure.\r\n\r\nWhat can be done in this regard:\r\n- Descriptor is equipped with prefix and suffix containing information to reconstruct all shared key components: `wsh/testnet(...)/<0;1>/*#checksum`\r\n- Keys do not list shared components, skipping them: `[f149e757//0h]xpub` (where `0h` is the account number and \"terminal derivation\" from the suffix is appended to all keys, such that they all follow uniform derivation);\r\n- Instead of a separate key list the keys go into the descriptor referenced in full only the first time they appear;\r\n- Each key has an alphanumeric alias, separated using `@`: `alice@[f149e757//0h]xpub`; the same key can be referred to in other descriptor places as `@alice`;\r\n- Keys in different spending paths, when necessary (since in Taproot it is not necessary) are distinguished by an additional derivation path segment called \"branch\". It is a non-hardened index going before the change index: `alice@[f149e757//0h]xpub/1` (which after expansion with prefix and suffix becomes `[f149e757/89h/1h/0h]xpub/1/<0;1>/*`;\r\n\r\nOverall, with these changes, the descriptors will look like\r\n```\r\nwsh/test(or(\r\n    and(alice@[fe569a81//1']xpub1..., bob@[8871bad9//1']xpub2..., carol@[beafcafe//1']xpub3...), \r\n    and(older(1000), thresh(2, @alice, @bob, @carol))\r\n))/<0;1>/*\r\n```\r\n\r\nThe benefits of the proposal are:\r\n- Remove separate key list;\r\n- Use human-readable aliaces;\r\n- Avoid conflicting descriptors using different BIP44 purposes, networks or terminal indexes;\r\n- Separate from previous descriptor standard using new BIP44 purpose value;\r\n- Do not assign new meaning for the change index and make the standard compatible with RGB protocol (which uses change index for specifying derivations containing assigned client-side state or tapret commitments). This also makes wallet implementation easier, helping to clearly understand which indexes to use when deriving external or internal (change) addresses.\r\n\r\nI can work on a PR to this PR to put this proposals into the text.",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713259908",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10329746359,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJns2u3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10329746359",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T06:40:59Z"
    },
    {
      "event": "subscribed",
      "id": 10329746366,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJns2u-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10329746366",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T06:40:59Z"
    },
    {
      "event": "commented",
      "id": 1713337351,
      "node_id": "IC_kwDOAN28mc5mH3QH",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713337351",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T07:40:24Z",
      "updated_at": "2023-09-11T07:40:24Z",
      "author_association": "NONE",
      "body": "> Remove separate key list;\r\n\r\nThe separate key list is very nice though. On the hardware wallets, being able to verify the descriptor without all the xpub/fingerprint/path-prefix noise is much better UX and I think the main purpose of this BIP.\r\n\r\n",
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713337351",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "commented",
      "id": 1713341317,
      "node_id": "IC_kwDOAN28mc5mH4OF",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713341317",
      "actor": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T07:43:12Z",
      "updated_at": "2023-09-11T07:43:12Z",
      "author_association": "NONE",
      "body": "> * Descriptor is equipped with prefix and suffix containing information to reconstruct all shared key components: `wsh/testnet(...)/<0;1>/*#checksum`\r\n\r\nIn my mind including the network identifier outside of the xpub is good from a global pov but bad on the UX pov: you asking all signer vendors/user to change they way of export xpubs.....\r\n\r\n> * Instead of a separate key list the keys go into the descriptor referenced in full only the first time they appear;\r\n\r\nI personally feel that a separate list of keys is more clear/clean to read/use\r\n\r\n> * Each key has an alphanumeric alias, separated using `@`: `alice@[f149e757//0h]xpub`; the same key can be referred to in other descriptor places as `@alice`;\r\n\r\nIn my mind the key should have a numeric alias, this numeric alias can be replaced by some kind of alphanumeric 'mnemonic' by the hardware that handles the display\r\n\r\n> * Keys in different spending paths, when necessary (since in Taproot it is not necessary) are distinguished by an additional derivation path segment called \"branch\". It is a non-hardened index going before the change index: `alice@[f149e757//0h]xpub/1` (which after expansion with prefix and suffix becomes `[f149e757/89h/1h/0h]xpub/1/<0;1>/*`;\r\n\r\nThe 'branch' should be allowed with `@`, it's needed for actual miniscripts.\r\n\r\n\r\nLooks like you forgot to talk about  not limit (or increase limit) the number of change segments to allow you to use `<0;1;9;10>` with RGB\r\n\r\n",
      "user": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713341317",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "commented",
      "id": 1713444950,
      "node_id": "IC_kwDOAN28mc5mIRhW",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713444950",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:34Z",
      "updated_at": "2023-09-11T08:46:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "@benma:\r\n> The separate key list is very nice though. On the hardware wallets, being able to verify the descriptor without all the xpub/fingerprint/path-prefix noise is much better UX and I think the main purpose of this BIP.\r\n\r\nYou are right that displaying that in the UI is terrible. Instead, my understanding is that the descriptor will be parsed by the wallet and the keys and policy will be present in the UI in separate form\r\n\r\n\r\n@pythcoiner:\r\n> I personally feel that a separate list of keys is more clear/clean to read/use\r\n\r\nI am not insisting on merging them; however, to import/export descriptors and pass them between software wallets it will be desirable to have a joined form.\r\n\r\n> In my mind including the network identifier outside of the xpub is good from a global pov but bad on the UX pov: you asking all signer vendors/user to change they way of export xpubs.....\r\n\r\nNo, the xpubs are exported the same way. However, when they are used in the descriptor, their shared parts are moved to prefix/suffix, ensuring they can be combined into the same descriptor (i.e. do not belong to different networks, which is hard to check otherwise).\r\n\r\n> In my mind the key should have a numeric alias, this numeric alias can be replaced by some kind of alphanumeric 'mnemonic' by the hardware that handles the display\r\n\r\nPutting additional requirements on having ints and having them in a strictly incremental manner just bloats validation code with no clear benefits\r\n\r\n> The 'branch' should be allowed with @, it's needed for actual miniscripts.\r\n\r\nOptionally. If not provided with a branch, then each time the key appears the branch number is automatically incremented. This reduces the visual load and size of the descriptor validation code (you can't write it in the wrong way).\r\n",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713444950",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10331085523,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJnx9rT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10331085523",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:34Z"
    },
    {
      "event": "subscribed",
      "id": 10331085538,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJnx9ri",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10331085538",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:34Z"
    },
    {
      "event": "mentioned",
      "id": 10331086798,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJnx9_O",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10331086798",
      "actor": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:42Z"
    },
    {
      "event": "subscribed",
      "id": 10331086809,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJnx9_Z",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10331086809",
      "actor": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T08:46:42Z"
    },
    {
      "event": "commented",
      "id": 1713484825,
      "node_id": "IC_kwDOAN28mc5mIbQZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1713484825",
      "actor": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T09:11:05Z",
      "updated_at": "2023-09-11T09:11:05Z",
      "author_association": "NONE",
      "body": "> No, the xpubs are exported the same way. However, when they are used in the descriptor, their shared parts are moved to prefix/suffix, ensuring they can be combined into the same descriptor (i.e. do not belong to different networks, which is hard to check otherwise).\r\n\r\nso it's mean the key/xpub a user supply to a wallet/coordinator will look differently than the one in the descriptor, how they can check accurately?\r\n\r\n\r\n\r\n> Putting additional requirements on having ints and having them in a strictly incremental manner just bloats validation code with no clear benefits\r\n\r\nshould we allow arabic/chinese/japanese/koreans/cyrillic/.... alphabets?\r\nthe benefit i found is just KISS, let the fancy stuff optionnaly on the display side, not on the communication side.\r\n\r\n\r\n> Optionally. If not provided with a branch, then each time the key appears the branch number is automatically incremented. This reduces the visual load and size of the descriptor validation code (you can't write it in the wrong way).\r\n\r\ni wonder if the order the key are passed to the miniscript 'compiler_that_is_not_compiler' are the same order in the output descriptor?",
      "user": {
        "login": "pythcoiner",
        "id": 124568858,
        "node_id": "U_kgDOB2zFGg",
        "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pythcoiner",
        "html_url": "https://github.com/pythcoiner",
        "followers_url": "https://api.github.com/users/pythcoiner/followers",
        "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
        "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
        "repos_url": "https://api.github.com/users/pythcoiner/repos",
        "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1713484825",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "commented",
      "id": 1714641245,
      "node_id": "IC_kwDOAN28mc5mM1ld",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1714641245",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T21:58:12Z",
      "updated_at": "2023-09-11T21:59:00Z",
      "author_association": "NONE",
      "body": "@dr-orlovsky I feel like your suggestion would be better as a separate BIP as it appears to have slightly different goals and tradeoffs than this one. I don't think it would be feasible to merge these two proposals without morphing one into the other. If you do this and link it here I'd be happy to provide feedback on that issue or PR.",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1714641245",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10339353132,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJoRgIs",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339353132",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T21:58:13Z"
    },
    {
      "event": "subscribed",
      "id": 10339353142,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJoRgI2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339353142",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T21:58:13Z"
    },
    {
      "event": "comment_deleted",
      "id": 10339730001,
      "node_id": "CDE_lADOAN28mc5WiQDdzwAAAAJoS8JR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339730001",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T23:07:46Z"
    },
    {
      "event": "comment_deleted",
      "id": 10339730435,
      "node_id": "CDE_lADOAN28mc5WiQDdzwAAAAJoS8QD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339730435",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T23:07:50Z"
    },
    {
      "event": "commented",
      "id": 1715275415,
      "node_id": "IC_kwDOAN28mc5mPQaX",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1715275415",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T08:46:21Z",
      "updated_at": "2023-09-12T08:46:21Z",
      "author_association": "CONTRIBUTOR",
      "body": "> * Descriptor is equipped with prefix and suffix containing information to reconstruct all shared key components: `wsh/testnet(...)/<0;1>/*#checksum`\r\n> * Keys do not list shared components, skipping them: `[f149e757//0h]xpub` (where `0h` is the account number and \"terminal derivation\" from the suffix is appended to all keys, such that they all follow uniform derivation);\r\n> * Instead of a separate key list the keys go into the descriptor referenced in full only the first time they appear;\r\n> * Each key has an alphanumeric alias, separated using `@`: `alice@[f149e757//0h]xpub`; the same key can be referred to in other descriptor places as `@alice`;\r\n> * Keys in different spending paths, when necessary (since in Taproot it is not necessary) are distinguished by an additional derivation path segment called \"branch\". It is a non-hardened index going before the change index: `alice@[f149e757//0h]xpub/1` (which after expansion with prefix and suffix becomes `[f149e757/89h/1h/0h]xpub/1/<0;1>/*`;\r\n\r\nThe proposed changes undo most of the design choices of this BIP proposal (like separating the actual keys from the \"descriptor template\" − something I consider a core feature and benefit!), while making the resulting language a lot more incompatible with output descriptor; moreover, it would make parsing a lot more complicated, as parsing a key expression is no longer context-free, because aliases are back-references to the previously-parsed part of the string.\r\n\r\nIn wallet policies, aliases for keys could easily be introduced as additional metadata associated to the elements of the keys information vector.\r\n\r\nThis BIP proposal wants to model in the most minimal way the object that software/hardware wallets (and their users) think of as \"accounts\". Application-specific use cases could be implemented either by building on top of it (if there is a desire / need to stay compatible), or with completely independent approaches.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1715275415",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "reviewed",
      "id": 1621791213,
      "node_id": "PRR_kwDOAN28mc5gqpHt",
      "url": null,
      "actor": null,
      "commit_id": "4b1f826217ab8f99c9484fbd6f1b1f88fa0c3bc0",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1621791213",
      "submitted_at": "2023-09-12T09:40:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "commented",
      "id": 1718020670,
      "node_id": "IC_kwDOAN28mc5mZuo-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1718020670",
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:09Z",
      "updated_at": "2023-09-13T17:18:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "@jgriffiths: \r\n\r\n> I feel like your suggestion would be better as a separate BIP as it appears to have slightly different goals and tradeoffs than this one.\r\n\r\nThat was what I began with:\r\n\r\n> After @benma suggestion I propose to merge my recent proposal https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-September/021946.html with this standard.\r\n\r\nand was suggested to merge into this standard\r\n\r\nAnyway, I see that it doesn't fit the hardware wallet devs, so I rest my case. The only part which is essential is to remember that RGB and other client-side-validation may require more derivation indexes in the change segment.",
      "user": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1718020670",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10362337971,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJppLqz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10362337971",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:10Z"
    },
    {
      "event": "subscribed",
      "id": 10362337983,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJppLq_",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10362337983",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:10Z"
    },
    {
      "event": "mentioned",
      "id": 10362337997,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJppLrN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10362337997",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:10Z"
    },
    {
      "event": "subscribed",
      "id": 10362338009,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJppLrZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10362338009",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-13T17:18:10Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dr-orlovsky",
        "id": 372034,
        "node_id": "MDQ6VXNlcjM3MjAzNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dr-orlovsky",
        "html_url": "https://github.com/dr-orlovsky",
        "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
        "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
        "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
        "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
        "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-19T08:59:43Z",
      "updated_at": "2023-09-19T08:59:43Z",
      "source": {
        "issue": {
          "id": 1902522920,
          "node_id": "PR_kwDOI_0jV85ap2KB",
          "url": "https://api.github.com/repos/BP-WG/bp-std/issues/1",
          "repository_url": "https://api.github.com/repos/BP-WG/bp-std",
          "labels_url": "https://api.github.com/repos/BP-WG/bp-std/issues/1/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/BP-WG/bp-std/issues/1/comments",
          "events_url": "https://api.github.com/repos/BP-WG/bp-std/issues/1/events",
          "html_url": "https://github.com/BP-WG/bp-std/pull/1",
          "number": 1,
          "state": "closed",
          "state_reason": null,
          "title": "Refactor descriptors to match new wallet policies",
          "body": "Implements support for https://github.com/bitcoin/bips/pull/1389#issuecomment-1718020670 used by BitBox and Ledger",
          "user": {
            "login": "dr-orlovsky",
            "id": 372034,
            "node_id": "MDQ6VXNlcjM3MjAzNA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dr-orlovsky",
            "html_url": "https://github.com/dr-orlovsky",
            "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
            "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
            "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
            "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
            "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 0,
          "pull_request": {
            "url": "https://api.github.com/repos/BP-WG/bp-std/pulls/1",
            "html_url": "https://github.com/BP-WG/bp-std/pull/1",
            "diff_url": "https://github.com/BP-WG/bp-std/pull/1.diff",
            "patch_url": "https://github.com/BP-WG/bp-std/pull/1.patch"
          },
          "closed_at": "2023-09-19T15:28:35Z",
          "created_at": "2023-09-19T08:59:42Z",
          "updated_at": "2023-09-20T18:56:33Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-20T12:59:17Z",
      "updated_at": "2023-09-20T12:59:17Z",
      "source": {
        "issue": {
          "id": 1623374902,
          "node_id": "PR_kwDOABII585L_jQs",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27255",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27255/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27255/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27255/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27255",
          "number": 27255,
          "state": "closed",
          "state_reason": null,
          "title": "MiniTapscript: port Miniscript to Tapscript",
          "body": "Miniscript was targeting P2WSH, and as such can currently only be used in `wsh()` descriptors. This pull request introduces support for Tapscript in Miniscript and makes Miniscript available inside `tr()` descriptors. It adds support for both watching *and* signing TapMiniscript descriptors.\r\n\r\nThe main changes to Miniscript for Tapscript are the following:\r\n- A new `multi_a` fragment is introduced with the same semantics as `multi`. Like in other descriptors `multi` and `multi_a` can exclusively be used in respectively P2WSH and Tapscript.\r\n- The `d:` fragment has the `u` property under Tapscript, since the `MINIMALIF` rule is now consensus. See also https://github.com/bitcoin/bitcoin/pull/24906.\r\n- Keys are now serialized as 32 bytes. (Note this affects the key hashes.)\r\n- The resource consumption checks and calculation changed. Some limits were lifted in Tapscript, and signatures are now 64 bytes long.\r\n\r\nThe largest amount of complexity probably lies in the last item. Scripts under Taproot can now run into the maximum stack size while executing a fragment. For instance if you've got a stack size of `999` due to the initial witness plus some execution that happened before and try to execute a `hash256` it would `DUP` (increasing the stack size `1000`), `HASH160` and then push the hash on the stack making the script fail.\r\nTo make sure this does not happen on any of the spending paths of a sane Miniscript, we introduce a tracking of the maximum stack size during execution of a fragment. See the commits messages for details. Those commits were separated from the resource consumption change, and the fuzz target was tweaked to sometimes pad the witness so the script runs on the brink of the stack size limit to make sure the stack size was not underestimated.\r\n\r\nExisting Miniscript unit, functional and fuzz tests are extended with Tapscript logic and test cases. Care was taken for seed stability in the fuzz targets where we cared more about them.\r\n\r\nThe design of Miniscript for Tapscript is the result of discussions between various people over the past year(s). To the extent of my knowledge at least Pieter Wuille, Sanket Kanjalkar, Andrew Poelstra and Andrew Chow contributed thoughts and ideas.",
          "user": {
            "login": "darosior",
            "id": 22457751,
            "node_id": "MDQ6VXNlcjIyNDU3NzUx",
            "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/darosior",
            "html_url": "https://github.com/darosior",
            "followers_url": "https://api.github.com/users/darosior/followers",
            "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
            "organizations_url": "https://api.github.com/users/darosior/orgs",
            "repos_url": "https://api.github.com/users/darosior/repos",
            "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/darosior/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60",
            "html_url": "https://github.com/bitcoin/bitcoin/milestone/60",
            "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60/labels",
            "id": 9286970,
            "node_id": "MI_kwDOABII584AjbU6",
            "number": 60,
            "state": "closed",
            "title": "26.0",
            "description": "",
            "creator": {
              "login": "fanquake",
              "id": 863730,
              "node_id": "MDQ6VXNlcjg2MzczMA==",
              "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/fanquake",
              "html_url": "https://github.com/fanquake",
              "followers_url": "https://api.github.com/users/fanquake/followers",
              "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
              "organizations_url": "https://api.github.com/users/fanquake/orgs",
              "repos_url": "https://api.github.com/users/fanquake/repos",
              "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/fanquake/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 116,
            "created_at": "2023-04-15T11:36:05Z",
            "updated_at": "2023-12-08T10:41:40Z",
            "closed_at": "2023-12-04T13:27:46Z"
          },
          "locked": false,
          "comments": 33,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27255",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27255",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27255.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27255.patch"
          },
          "closed_at": "2023-10-08T16:10:32Z",
          "created_at": "2023-03-14T12:24:34Z",
          "updated_at": "2023-10-26T18:07:12Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1734400528,
      "node_id": "IC_kwDOAN28mc5nYNoQ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1734400528",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-25T20:15:30Z",
      "updated_at": "2023-09-25T20:15:30Z",
      "author_association": "NONE",
      "body": "> RGB and other client-side-validation may require more derivation indexes in the change segment.\r\n\r\nIf this doesn't fit the existing patterns or the single derivation case (for example if the solved cardinality of such descriptors is > 2, and/or they contain more than one multi-path expression), I think this can be added as an optional extension as the single derivation case (non-bip44-style) was. As long as every key expression in a policy has the same solved cardinality this should work (disclaimer: I'm not following RGB development).",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1734400528",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-26T19:02:29Z",
      "updated_at": "2023-09-26T19:02:29Z",
      "source": {
        "issue": {
          "id": 1913061774,
          "node_id": "I_kwDOF72rbM5yBwGO",
          "url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/197",
          "repository_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new",
          "labels_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/197/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/197/comments",
          "events_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/197/events",
          "html_url": "https://github.com/LedgerHQ/app-bitcoin-new/issues/197",
          "number": 197,
          "state": "closed",
          "state_reason": "completed",
          "title": "Allow use external public keys in walletPolicy",
          "body": "Hi, i want to register a wallet polixy with 2 xpub keys (from Ledgers) and 1 external public key (i can't get an extended public key for third key). From docs i understand that ability is not implemented yet. When this will be implemented or maybe there is another way to use such signing strategy with Ledger?",
          "user": {
            "login": "generalAO",
            "id": 2953020,
            "node_id": "MDQ6VXNlcjI5NTMwMjA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2953020?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/generalAO",
            "html_url": "https://github.com/generalAO",
            "followers_url": "https://api.github.com/users/generalAO/followers",
            "following_url": "https://api.github.com/users/generalAO/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/generalAO/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/generalAO/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/generalAO/subscriptions",
            "organizations_url": "https://api.github.com/users/generalAO/orgs",
            "repos_url": "https://api.github.com/users/generalAO/repos",
            "events_url": "https://api.github.com/users/generalAO/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/generalAO/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 8,
          "closed_at": "2023-11-27T11:18:56Z",
          "created_at": "2023-09-26T09:12:21Z",
          "updated_at": "2023-11-27T11:18:56Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T08:52:15Z",
      "updated_at": "2023-11-20T08:52:15Z",
      "source": {
        "issue": {
          "id": 2000518366,
          "node_id": "I_kwDOF72rbM53PXze",
          "url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/205",
          "repository_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new",
          "labels_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/205/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/205/comments",
          "events_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/205/events",
          "html_url": "https://github.com/LedgerHQ/app-bitcoin-new/issues/205",
          "number": 205,
          "state": "closed",
          "state_reason": "completed",
          "title": "simpleSignTxn() new method proposal",
          "body": "I suggest introducing a new method for generating signatures, which eliminates the need for a policy or information about other signers. This approach involves reading a Partially Signed Bitcoin Transaction (PSBT), utilizing the sighash type, UTXO type (determining if it's SegWit through the presence of a witness), transaction ID, value, vout, and output information. From these elements, it constructs a preimage, which is then displayed on a Ledger device. This allows the user to verify the amounts being spent and the recipients' addresses before signing and returning the signature.\r\n\r\nCrucially, this method does not require knowledge of co-signers' extended public keys (xpubs) or any similar keys. It solely ensures that the user is aware of the transaction's details they are signing. The user's software then uses this signature to reconstruct the final transaction, adding other necessary signatures for broadcasting.\r\n\r\nThis approach enables Ledger devices to sign any redeem/witness scripts without the need to support specific types (standard multi-sig or complex... it is indifferent) or requiring users to gather information from other signers that adds complexity to the user experience. The user only needs their own keys and derivation paths, enabling the wallet to sign the preimage that is the same for any kind of redeem/witness script.\r\n\r\nDo you think such a method is feasible and can be implemented?",
          "user": {
            "login": "pcfun19",
            "id": 6763346,
            "node_id": "MDQ6VXNlcjY3NjMzNDY=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6763346?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/pcfun19",
            "html_url": "https://github.com/pcfun19",
            "followers_url": "https://api.github.com/users/pcfun19/followers",
            "following_url": "https://api.github.com/users/pcfun19/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/pcfun19/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/pcfun19/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/pcfun19/subscriptions",
            "organizations_url": "https://api.github.com/users/pcfun19/orgs",
            "repos_url": "https://api.github.com/users/pcfun19/repos",
            "events_url": "https://api.github.com/users/pcfun19/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/pcfun19/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 3,
          "closed_at": "2023-11-27T11:19:09Z",
          "created_at": "2023-11-18T17:56:31Z",
          "updated_at": "2023-11-27T11:19:09Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1818792106,
      "node_id": "IC_kwDOAN28mc5saJCq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1818792106",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T10:37:58Z",
      "updated_at": "2023-11-20T10:37:58Z",
      "author_association": "NONE",
      "body": "@bigspider Policy support for the Jade HWW is now released as of firmware version 1.0.24 (https://github.com/Blockstream/Jade/releases/tag/1.0.24), if you'd like to update the `Reference Implementation` section.\r\n\r\nJade support is implemented via libwally-core (C/C++/Python/Java/JS) v1.0.0 (https://github.com/ElementsProject/libwally-core/releases/tag/release_1.0.0) if you want to link a general purpose implementation. Both Jade and wally implement the single-path derivation `/*` extension for non-bip44 wallets.\r\n\r\nFrom my POV review is otherwise complete, ACK for this to receive a BIP number and be merged.",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1818792106",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 11010003917,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAKQP1PN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11010003917",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T10:37:58Z"
    },
    {
      "event": "subscribed",
      "id": 11010003939,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAKQP1Pj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11010003939",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-20T10:37:58Z"
    },
    {
      "event": "commented",
      "id": 1820680728,
      "node_id": "IC_kwDOAN28mc5shWIY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1820680728",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:51:49Z",
      "updated_at": "2023-11-21T10:51:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for the update, @jgriffiths! I added Jade/libwally support in 3c97885, and did a couple of small improvements to the python demo.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1820680728",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 11022703640,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAKRARwY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022703640",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:51:49Z"
    },
    {
      "event": "subscribed",
      "id": 11022703661,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAKRARwt",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022703661",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:51:49Z"
    },
    {
      "event": "commented",
      "id": 1820691997,
      "node_id": "IC_kwDOAN28mc5shY4d",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1820691997",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:58:49Z",
      "updated_at": "2023-11-21T10:58:49Z",
      "author_association": "CONTRIBUTOR",
      "body": "@luke-jr, please let me know if this can be assigned a BIP number, or if something is missing.\r\n\r\nThere are now three hardware signers already using these specs in production.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1820691997",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 11022782668,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAKRAlDM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022782668",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:58:50Z"
    },
    {
      "event": "subscribed",
      "id": 11022782694,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAKRAlDm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022782694",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T10:58:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11022847855,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAKRA09v",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11022847855",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-21T11:04:42Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-27T11:14:04Z",
      "updated_at": "2023-11-27T11:14:04Z",
      "source": {
        "issue": {
          "id": 2012044314,
          "node_id": "I_kwDOF72rbM537Vwa",
          "url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/210",
          "repository_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new",
          "labels_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/210/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/210/comments",
          "events_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/210/events",
          "html_url": "https://github.com/LedgerHQ/app-bitcoin-new/issues/210",
          "number": 210,
          "state": "open",
          "state_reason": null,
          "title": "Sign transactions not fitting the wallet policy approach",
          "body": "A number of issues were opened to request signing in cases that don't fit the wallet policy model:\r\n\r\n- #153\r\n- #197\r\n- #205\r\n\r\nThis issue tries to generalize the problem. How do we safely sign transactions outside of the model of wallet policies?\r\n\r\n## Wallet policies\r\n\r\n[Wallet policies](https://github.com/bitcoin/bips/pull/1389) build on top of [Output Script Descriptors](https://github.com/bitcoin/bips/blob/master/bip-0380.mediawiki) to model in a sound way what software wallets typically call an _account_.\r\n\r\nWhether single-sig, multisig, musig, miniscript, etc, for most software wallets, an account is exactly: a list of receiving addresses, plus a list of change addresses.\r\n\r\n### Wallet policies in hardware signers\r\n\r\nWallet policies are a first class citizen in the Ledger bitcoin app (and similar specs have now been implemented in the [BitBox02](https://github.com/digitalbitbox/bitbox02-firmware/pull/1095), and in Blockstream Jade via the [Wally](https://github.com/ElementsProject/libwally-core/pull/369) library).\r\n\r\nThe signing API is currently similar to `sign(psbt, wallet_policy)` (plus the `wallet_policy_hmac`, not relevant for this discussion), which means that the \"wallet policy\" is additional information on top of just the transaction being signed, represented in the psbt. (in principle, the wallet policy itself could be added to the psbt; however, there is no standard for it).\r\n\r\nHaving precise knowledge of \"what account\" you are receiving to, or spending from, allows to strengthen the security model quite substantially, as malware in the in the software wallet can't tamper with that information. In practice, the expectation is that people will have multiple accounts, and many of them will involve multiple keys (other co-signers). Wallet policies allow you to know exactly from which account you're spending. That's important: if you have a 2-of-2 with your wife, and another 2-of-2 with your colleague at work, it's not enough to know that you're \"spending 0.1 btc and sending it to bc1pxxx..\", you want to know that you're \"spending 0.1 from your work account and sending it to bc1pxxx\". Without that, if your co-worker gets access to your computer, it's trivial for them to install malware to trick you to spend your wife's money when you think you're using the company account. Of course, this inherently requires full knowledge of the script on the hardware signer's end, including all of the cosigner's xpuOne would also have to think abs.\r\nWith wallet policies, the device can inform you that you're spending from the account named `Cold storage` (for example):\r\n\r\n![spend-wallet-policy](https://github.com/LedgerHQ/app-bitcoin-new/assets/6681844/f33ec348-3bc6-4bf4-ab3d-787dbc909334)\r\n\r\nThe hardware signer can use the information in the psbt, plus the knowledge of the wallet policy, to:\r\n- make sure that the change output is going to the right place [*];\r\n- inform what account you're receving to / spending from;\r\n- possibly, simplify the UX for known outputs. For example, if you know that you're sending to another of your accounts (or even some known external account), its descriptive name could be shown along – or instead – of the output address); this is not currently implemented.\r\n\r\nIn other words: wallet policies allow **strict account segregation**: the hardware device can _guarantee_ that you're not touching any other account (as long as you take care to register different policies under different names, of course).\r\n\r\n<sub>\r\n[*] In principle, before taproot, this doesn't strictly require wallet policies, as the descriptor could be \"decompiled\" from the witnessScript; this is no longer true in taproot trees, however, as the [PSBT](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki) does not contain enough information (knowledge of how to generate the entire taptree, for any address index, is necessary).\r\n</sub>\r\n\r\n## Safe signing outside of wallet policies\r\n\r\nWhile wallet policies themselves could possibly be generalized to cover _some_ use cases that are not currently represented by the BIP proposal, it's clear that there are other situations that just don't fit in this model of _signing for an account_: not all UTXOs are meaningfully part of an account as it can be represented in wallet policies.\r\n\r\n### UX considerations\r\nAllowing signing behaviors that go outside the model of wallet policies would likely break the strong account segregation guarantee above.\r\n\r\nThat might be fine, as long as it doesn't happen _seamlessly_: the user must know that they are stepping somewhat outside of the safe zone. Possible options:\r\n\r\n- a prominent warning with explicit user confirmation required\r\n- signing for such transaction must be explicitly enabled in the settings of the app (1 time action where the user can properly be warned).\r\n\r\nAnother option that could be worth investigating is to attach the \"unsafe signing behavior\" to specific keys. That is, one could [register](https://github.com/LedgerHQ/app-bitcoin-new/blob/develop/doc/wallet.md#policy-registration-and-usage) a special kind of \"wallet policy\" (to be defined) that means \"for these internal xpubs, allow unsafe signing\". That would allow to keep the strong account segregation guarantees for any other xpubs, as long as the user is diligent in not reusing xpubs for different purposes. The downside is, of course, that software walltes would need to be aware and explicitly opt-in to this approach, which makes integrations somewhat harder.\r\n\r\n### What's safe to sign, if you don't have wallet policies?\r\n\r\nThis is to be defined, and knowing the desired use cases would help. (Note that this is about finding general approaches to signing that work for many use cases; nothing works for _all_ use cases, and for specific applications, a separated customized app would be a better approach)\r\n\r\nFor transactions signed with SIGHASH_ALL, one case that would generally be safe (apart from not having the strong account segregation property mentioned above) is if:\r\n- there is no change output (all outputs are shown to and verified by the user)\r\n- all inputs are assumed to be internal.\r\n",
          "user": {
            "login": "bigspider",
            "id": 6681844,
            "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bigspider",
            "html_url": "https://github.com/bigspider",
            "followers_url": "https://api.github.com/users/bigspider/followers",
            "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
            "organizations_url": "https://api.github.com/users/bigspider/orgs",
            "repos_url": "https://api.github.com/users/bigspider/repos",
            "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/bigspider/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 3279926090,
              "node_id": "MDU6TGFiZWwzMjc5OTI2MDkw",
              "url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/labels/enhancement",
              "name": "enhancement",
              "description": "New feature or request",
              "color": "a2eeef",
              "default": true
            }
          ],
          "assignees": [],
          "author_association": "COLLABORATOR",
          "locked": false,
          "comments": 10,
          "created_at": "2023-11-27T11:14:03Z",
          "updated_at": "2023-12-12T10:37:02Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-11T08:35:56Z",
      "updated_at": "2023-12-11T08:35:56Z",
      "source": {
        "issue": {
          "id": 2020817952,
          "node_id": "I_kwDOIyZ3kM54czwg",
          "url": "https://api.github.com/repos/bitcoinerlab/descriptors/issues/31",
          "repository_url": "https://api.github.com/repos/bitcoinerlab/descriptors",
          "labels_url": "https://api.github.com/repos/bitcoinerlab/descriptors/issues/31/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoinerlab/descriptors/issues/31/comments",
          "events_url": "https://api.github.com/repos/bitcoinerlab/descriptors/issues/31/events",
          "html_url": "https://github.com/bitcoinerlab/descriptors/issues/31",
          "number": 31,
          "state": "open",
          "state_reason": null,
          "title": "Output descriptor with both receiving and change paths",
          "body": "Hey! I am trying to use an output descriptor with both the receiving (0) and change (1) paths, as follow: `wpkh([284bbfa8/84h/1h/0h]tpubDCe8CRwGAiQ2r3rdChcB3Fp8v4GVjYJqoyKKwBczxGVNnawaK21p7sWh8oiMRo26wmSEhQqHGPVofX7t9BnGaSZjbED9WwRxMt8UeTjF64S/<0;1>/*)`. It seems that this library does not support this expression `<0;1>`? I get a `Could not parse descriptor` error while it seems to work well with `0` instead of `<0;1>`. Please let me know if I can be of any help implementing this, or the rationale behind not supporting this.",
          "user": {
            "login": "louneskmt",
            "id": 38882571,
            "node_id": "MDQ6VXNlcjM4ODgyNTcx",
            "avatar_url": "https://avatars.githubusercontent.com/u/38882571?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/louneskmt",
            "html_url": "https://github.com/louneskmt",
            "followers_url": "https://api.github.com/users/louneskmt/followers",
            "following_url": "https://api.github.com/users/louneskmt/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/louneskmt/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/louneskmt/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/louneskmt/subscriptions",
            "organizations_url": "https://api.github.com/users/louneskmt/orgs",
            "repos_url": "https://api.github.com/users/louneskmt/repos",
            "events_url": "https://api.github.com/users/louneskmt/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/louneskmt/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 4,
          "created_at": "2023-12-01T12:47:18Z",
          "updated_at": "2023-12-11T09:58:00Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1796535592,
      "node_id": "PRR_kwDOAN28mc5rFPUo",
      "url": null,
      "actor": null,
      "commit_id": "07f0fcf5f4f2f857b03ab77fbc99a33ba1a34325",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Assigned BIP 388",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1796535592",
      "submitted_at": "2023-12-26T18:55:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "renamed",
      "id": 11340813975,
      "node_id": "RTE_lADOAN28mc5WiQDdzwAAAAKj9xaX",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11340813975",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-12-26T19:18:05Z",
      "rename": {
        "from": "[New BIP] Wallet Policies",
        "to": "BIP 388: Wallet Policies for Descriptor Wallets"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bitschmidty",
        "id": 1615772,
        "node_id": "MDQ6VXNlcjE2MTU3NzI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1615772?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitschmidty",
        "html_url": "https://github.com/bitschmidty",
        "followers_url": "https://api.github.com/users/bitschmidty/followers",
        "following_url": "https://api.github.com/users/bitschmidty/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitschmidty/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitschmidty/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitschmidty/subscriptions",
        "organizations_url": "https://api.github.com/users/bitschmidty/orgs",
        "repos_url": "https://api.github.com/users/bitschmidty/repos",
        "events_url": "https://api.github.com/users/bitschmidty/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitschmidty/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-02T15:09:19Z",
      "updated_at": "2024-01-02T15:09:19Z",
      "source": {
        "issue": {
          "id": 2062021136,
          "node_id": "PR_kwDOCCK3eM5jCCDr",
          "url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/issues/1451",
          "repository_url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io",
          "labels_url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/issues/1451/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/issues/1451/comments",
          "events_url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/issues/1451/events",
          "html_url": "https://github.com/bitcoinops/bitcoinops.github.io/pull/1451",
          "number": 1451,
          "state": "closed",
          "state_reason": null,
          "title": "Newsletters: add 283 (2024-01-03)",
          "body": "- [x] Lede, releases/RCs, topic entries @harding ",
          "user": {
            "login": "harding",
            "id": 61096,
            "node_id": "MDQ6VXNlcjYxMDk2",
            "avatar_url": "https://avatars.githubusercontent.com/u/61096?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/harding",
            "html_url": "https://github.com/harding",
            "followers_url": "https://api.github.com/users/harding/followers",
            "following_url": "https://api.github.com/users/harding/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/harding/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/harding/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/harding/subscriptions",
            "organizations_url": "https://api.github.com/users/harding/orgs",
            "repos_url": "https://api.github.com/users/harding/repos",
            "events_url": "https://api.github.com/users/harding/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/harding/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 2,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/pulls/1451",
            "html_url": "https://github.com/bitcoinops/bitcoinops.github.io/pull/1451",
            "diff_url": "https://github.com/bitcoinops/bitcoinops.github.io/pull/1451.diff",
            "patch_url": "https://github.com/bitcoinops/bitcoinops.github.io/pull/1451.patch"
          },
          "closed_at": "2024-01-03T10:55:30Z",
          "created_at": "2024-01-02T07:08:39Z",
          "updated_at": "2024-01-12T19:10:21Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-05T11:08:30Z",
      "updated_at": "2024-01-05T11:08:30Z",
      "source": {
        "issue": {
          "id": 1723165454,
          "node_id": "I_kwDOHsGWPs5mtWsO",
          "url": "https://api.github.com/repos/wizardsardine/liana/issues/539",
          "repository_url": "https://api.github.com/repos/wizardsardine/liana",
          "labels_url": "https://api.github.com/repos/wizardsardine/liana/issues/539/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/wizardsardine/liana/issues/539/comments",
          "events_url": "https://api.github.com/repos/wizardsardine/liana/issues/539/events",
          "html_url": "https://github.com/wizardsardine/liana/issues/539",
          "number": 539,
          "state": "open",
          "state_reason": null,
          "title": "Handle compatibility w/ airgapped QRCode communicant wallet",
          "body": "I open this issue for brainstorm about the optimal workflow for signing with `airgapped` wallet using communication over `QRCode` scanning (Seedsigner/Jade/SpecterDIY/???)\r\n\r\nI think for now only specter DIY handle `miniscript` ( but seedsigner also use `embit` python library who handle miniscript)\r\n\r\nAn issue also have been open on [seedsigner project](https://github.com/SeedSigner/seedsigner/issues/306) about that.\r\nI'm interested about your thought about which way to go and which way to not go.\r\n\r\ni'm doing some experimentation on a seedsigner, will try to show more about that in few days.",
          "user": {
            "login": "pythcoiner",
            "id": 124568858,
            "node_id": "U_kgDOB2zFGg",
            "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/pythcoiner",
            "html_url": "https://github.com/pythcoiner",
            "followers_url": "https://api.github.com/users/pythcoiner/followers",
            "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
            "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
            "repos_url": "https://api.github.com/users/pythcoiner/repos",
            "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "COLLABORATOR",
          "locked": false,
          "comments": 38,
          "created_at": "2023-05-24T04:45:18Z",
          "updated_at": "2024-01-12T16:00:46Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGJkNjg0YmZlZGYyY2I4YjNlOWM3MmUwZTU3MDVlNzY1MTVhYWRmNzg",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/bd684bfedf2cb8b3e9c72e0e5705e76515aadf78",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/bd684bfedf2cb8b3e9c72e0e5705e76515aadf78",
      "tree": {
        "sha": "70061b6d677c7d6f63e21efaf5945313d0c53d9e",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/70061b6d677c7d6f63e21efaf5945313d0c53d9e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 70061b6d677c7d6f63e21efaf5945313d0c53d9e\nparent deae64bfd31f6938253c05392aa355bf6d7e7605\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1662039054 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1704710800 +0100\n\nNew BIP: Wallet Policies\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmWb0pAACgkQdAYP+Bsz\n5PgPxgv+KU3sBp7iIs+YhpPBRc3/vtBu8oLtWNjLDyZ+FIT9El/GBBrEnFjfO0AN\n1/UQ4inEtGhi0ZywHtQvf4KVsHG+DAmzHS8ZaAaLPL0i8Wv7uiDbM4CKLYpW1AF9\nLcxbHuMKwPWYmryaO6j/YxuBTtdVYuzbOvJTqpb5l70lw8Ei5voFDhPM7VzOR5HM\nIIjh5GT2/MV4FeCOcq2yYFST/1tA44FtHVEtLN30zLwTlRB3S5NbGblDB1+gVZw/\nijnhLnKvGf0iodlsTeybjpS95CMs0ww4Sw/peQoOLDIISoUXF24RrB0+f7MUmms3\nPlEW8rayGymd5pUNA3Nujuv8lOxAphvQziXU0mFrDLHx6a0ML1g8BLKt2aQdSfyq\nRVS2ibOYjVT0OKMZZmgYYsDzENTyCM4NSBoYtnyO0IkIxP0u9bt39K+nDItT81hz\nm8U/DTM/cbt5H8inifVJ8QrMBXkojKMfDT0GVNvYOH/h4jceRz/i0NaBikvWXxhj\nMrX+1oQg\n=K/Mr\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/deae64bfd31f6938253c05392aa355bf6d7e7605",
          "sha": "deae64bfd31f6938253c05392aa355bf6d7e7605",
          "html_url": "https://github.com/bitcoin/bips/commit/deae64bfd31f6938253c05392aa355bf6d7e7605"
        }
      ],
      "message": "New BIP: Wallet Policies",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-01-08T10:46:40Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2022-09-01T13:30:54Z"
      },
      "sha": "bd684bfedf2cb8b3e9c72e0e5705e76515aadf78"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11416016310,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAKocpW2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11416016310",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T10:50:06Z"
    },
    {
      "event": "commented",
      "id": 1880771969,
      "node_id": "IC_kwDOAN28mc5wGk2B",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1880771969",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T10:51:56Z",
      "updated_at": "2024-01-08T11:20:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "I squashed the history, rebased and updated BIP number and type in <del>3bb2cfe4751313470b98c9aaaff9322078fb8e3c</del> d4c650bad3ac190c9106d059b1ed5b110f2660bb.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1880771969",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGQ0YzY1MGJhZDNhYzE5MGM5MTA2ZDA1OWIxZWQ1YjExMGYyNjYwYmI",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "tree": {
        "sha": "e024acf9b858b86c9d6b33374933321f31fa6f8d",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/e024acf9b858b86c9d6b33374933321f31fa6f8d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e024acf9b858b86c9d6b33374933321f31fa6f8d\nparent bd684bfedf2cb8b3e9c72e0e5705e76515aadf78\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1704710477 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1704712706 +0100\n\nUpdate assigned BIP number; change type to \"Standards Track\"\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmWb2gIACgkQdAYP+Bsz\n5Pi5pgwAkQ9NZXiiEIuVHzbWDmOzKISg70kVKUtWgQFaB/HI+rRo1iDxR+zlKCJu\nS7kh3WbSD93YzrGdrbYOGjOkK0XKkCdO8lf7bZDVQ7crE6/iPPZ83XqsLFHThQIO\n2L189V7R56RNyvsqIXeMHUsjffMwyr8zxxI51CAbsCu+ZObdtgek84+dItkH/T+/\n/y5EbwzCleX/iZsbcGBnnzz0XSHO8kKYWaQVrV5ciLg3dWJZQtRuWdf6LkVGyCa4\nW+aAj8Df5zhD4EXiXUhP80JxgN/NbVmVWHwOlYDr4IB3arO7WrereEDGnWJKuJAM\nhUAoPQBLi0IKlHotJ3yrXzgG4G1J9Oa/qT+9o80/OWCoZQ6g8kFN9ik7qO6oGCW+\n6xGssyPlpkggguyUt+cKLRFQfE7HUSVq8zH1uawM/MvIc+ncICbfeYlYYtTaRElF\nPxIaPT4C5JdqrY+jkCWkX62onpGsf0iW+pvu5LtBCo6EcQwJp99FJ7cxW7Dzp+ug\n8omNHjWD\n=rcZh\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/bd684bfedf2cb8b3e9c72e0e5705e76515aadf78",
          "sha": "bd684bfedf2cb8b3e9c72e0e5705e76515aadf78",
          "html_url": "https://github.com/bitcoin/bips/commit/bd684bfedf2cb8b3e9c72e0e5705e76515aadf78"
        }
      ],
      "message": "Update assigned BIP number; change type to \"Standards Track\"",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-01-08T11:18:26Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-01-08T10:41:17Z"
      },
      "sha": "d4c650bad3ac190c9106d059b1ed5b110f2660bb"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 11416311514,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAKodxba",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11416311514",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-08T11:18:49Z"
    },
    {
      "event": "commented",
      "id": 1927369947,
      "node_id": "IC_kwDOAN28mc5y4VTb",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1927369947",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-05T16:21:55Z",
      "updated_at": "2024-02-05T16:21:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "@luke-jr, is there any other further change that I missed?\r\n\r\nOtherwise, it would be great to have this merged so I can start linking to it in docs.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1927369947",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 11706600865,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAK5xI2h",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11706600865",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-05T16:21:55Z"
    },
    {
      "event": "subscribed",
      "id": 11706600903,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAK5xI3H",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11706600903",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-05T16:21:56Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "seedhammer",
        "id": 93251679,
        "node_id": "U_kgDOBY7oXw",
        "avatar_url": "https://avatars.githubusercontent.com/u/93251679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/seedhammer",
        "html_url": "https://github.com/seedhammer",
        "followers_url": "https://api.github.com/users/seedhammer/followers",
        "following_url": "https://api.github.com/users/seedhammer/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/seedhammer/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/seedhammer/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/seedhammer/subscriptions",
        "organizations_url": "https://api.github.com/users/seedhammer/orgs",
        "repos_url": "https://api.github.com/users/seedhammer/repos",
        "events_url": "https://api.github.com/users/seedhammer/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/seedhammer/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-02-09T10:13:58Z",
      "updated_at": "2024-02-09T10:13:58Z",
      "source": {
        "issue": {
          "id": 2110227789,
          "node_id": "PR_kwDOAN28mc5lk-to",
          "url": "https://api.github.com/repos/bitcoin/bips/issues/1548",
          "repository_url": "https://api.github.com/repos/bitcoin/bips",
          "labels_url": "https://api.github.com/repos/bitcoin/bips/issues/1548/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1548/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bips/issues/1548/events",
          "html_url": "https://github.com/bitcoin/bips/pull/1548",
          "number": 1548,
          "state": "open",
          "state_reason": null,
          "title": "Add bip-psbt-descriptors",
          "body": "A BIP 174 PSBT may contain an extended key for deriving input and output\r\naddresses. This document proposes an additional field for PSBTs to represent\r\narbitrary BIP 380 output script descriptors.\r\n\r\nTo support transfer of output descriptors outside signing flows, the proposal\r\nmakes the unsigned transaction optional.",
          "user": {
            "login": "seedhammer",
            "id": 93251679,
            "node_id": "U_kgDOBY7oXw",
            "avatar_url": "https://avatars.githubusercontent.com/u/93251679?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/seedhammer",
            "html_url": "https://github.com/seedhammer",
            "followers_url": "https://api.github.com/users/seedhammer/followers",
            "following_url": "https://api.github.com/users/seedhammer/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/seedhammer/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/seedhammer/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/seedhammer/subscriptions",
            "organizations_url": "https://api.github.com/users/seedhammer/orgs",
            "repos_url": "https://api.github.com/users/seedhammer/repos",
            "events_url": "https://api.github.com/users/seedhammer/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/seedhammer/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 6,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bips/pulls/1548",
            "html_url": "https://github.com/bitcoin/bips/pull/1548",
            "diff_url": "https://github.com/bitcoin/bips/pull/1548.diff",
            "patch_url": "https://github.com/bitcoin/bips/pull/1548.patch"
          },
          "created_at": "2024-01-31T14:30:51Z",
          "updated_at": "2024-03-16T18:34:21Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "seedhammer",
        "id": 93251679,
        "node_id": "U_kgDOBY7oXw",
        "avatar_url": "https://avatars.githubusercontent.com/u/93251679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/seedhammer",
        "html_url": "https://github.com/seedhammer",
        "followers_url": "https://api.github.com/users/seedhammer/followers",
        "following_url": "https://api.github.com/users/seedhammer/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/seedhammer/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/seedhammer/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/seedhammer/subscriptions",
        "organizations_url": "https://api.github.com/users/seedhammer/orgs",
        "repos_url": "https://api.github.com/users/seedhammer/repos",
        "events_url": "https://api.github.com/users/seedhammer/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/seedhammer/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-03-16T17:42:49Z",
      "updated_at": "2024-03-16T17:42:49Z",
      "source": {
        "issue": {
          "id": 2007460274,
          "node_id": "I_kwDOKwTGXc53p2my",
          "url": "https://api.github.com/repos/coinkite/BBQr/issues/1",
          "repository_url": "https://api.github.com/repos/coinkite/BBQr",
          "labels_url": "https://api.github.com/repos/coinkite/BBQr/issues/1/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/coinkite/BBQr/issues/1/comments",
          "events_url": "https://api.github.com/repos/coinkite/BBQr/issues/1/events",
          "html_url": "https://github.com/coinkite/BBQr/issues/1",
          "number": 1,
          "state": "open",
          "state_reason": null,
          "title": "Adding Type code for Descriptor",
          "body": "As descriptor need to be share between wallets/coordinators and airgapped signers in miniscript setups, it should be useful to have a Type for standalone descriptor, at least used at the initial descriptor registration step.",
          "user": {
            "login": "pythcoiner",
            "id": 124568858,
            "node_id": "U_kgDOB2zFGg",
            "avatar_url": "https://avatars.githubusercontent.com/u/124568858?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/pythcoiner",
            "html_url": "https://github.com/pythcoiner",
            "followers_url": "https://api.github.com/users/pythcoiner/followers",
            "following_url": "https://api.github.com/users/pythcoiner/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/pythcoiner/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/pythcoiner/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/pythcoiner/subscriptions",
            "organizations_url": "https://api.github.com/users/pythcoiner/orgs",
            "repos_url": "https://api.github.com/users/pythcoiner/repos",
            "events_url": "https://api.github.com/users/pythcoiner/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/pythcoiner/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 13,
          "created_at": "2023-11-23T04:18:22Z",
          "updated_at": "2024-03-16T17:42:49Z"
        },
        "type": "issue"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035755474",
      "pull_request_review_id": 1199012337,
      "id": 1035755474,
      "node_id": "PRRC_kwDOAN28mc49vF_S",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 30,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": null,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not only in Bitcoin Core?",
      "created_at": "2022-11-30T09:53:14Z",
      "updated_at": "2022-11-30T10:01:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1035755474",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035755474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035758113",
      "pull_request_review_id": 1199012337,
      "id": 1035758113,
      "node_id": "PRRC_kwDOAN28mc49vGoh",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": null,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":)",
      "created_at": "2022-11-30T09:55:19Z",
      "updated_at": "2022-11-30T10:01:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1035758113",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035758113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1084997183",
      "pull_request_review_id": 1267102523,
      "id": 1084997183,
      "node_id": "PRRC_kwDOAN28mc5Aq74_",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Still open to suggestions for a less-ambiguous name!",
      "created_at": "2023-01-24T09:17:59Z",
      "updated_at": "2023-01-24T09:18:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1084997183",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1084997183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1085000432",
      "pull_request_review_id": 1267106948,
      "id": 1085000432,
      "node_id": "PRRC_kwDOAN28mc5Aq8rw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 30,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035755474,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point, changed in 162c675415ef717a599cc899fc4a0b7617710a3e to \"any descriptor-based software wallet\".",
      "created_at": "2023-01-24T09:20:52Z",
      "updated_at": "2023-01-24T09:20:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1085000432",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1085000432"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341047",
      "pull_request_review_id": 1295456080,
      "id": 1104341047,
      "node_id": "PRRC_kwDOAN28mc5B0ug3",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 232,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `for a complete list.` ?\r\n",
      "created_at": "2023-02-13T11:26:40Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104341047",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341904",
      "pull_request_review_id": 1295456080,
      "id": 1104341904,
      "node_id": "PRRC_kwDOAN28mc5B0uuQ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 245,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you need to change:\r\n`key_user` -> `@0`\r\n`key_service` -> `@1`\r\n",
      "created_at": "2023-02-13T11:27:30Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104341904",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104344236",
      "pull_request_review_id": 1295456080,
      "id": 1104344236,
      "node_id": "PRRC_kwDOAN28mc5B0vSs",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(00112233445566778899aabbccddeeff00112233)))))</tt> - BOLT #3 offered HTLC policy.\n+* <tt>wsh(andor(pk(@0/**),or_i(and_v(v:pkh(@1/**),hash160(00112233445566778899aabbccddeeff00112233)),older(1008)),pk(@2/**)))</tt> - BOLT #3 received HTLC policy.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0))\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL))\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0,@1))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: BOLT #3 offered HTLC policy\n+ Descriptor template: wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(t:or_c(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),and_v(v:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),or_c(pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.\n+\n+== Backwards Compatibility ==\n+\n+The <tt>@</tt> character used for key placeholders is not part of the syntax of output script descriptors, therefore any valid descriptor template is not a valid descriptor template. Vice versa, any descriptor template with at least one key placeholder is not a valid output script descriptor.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 298,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> therefore any valid descriptor template is not a valid descriptor template\r\n\r\nI think you mean `therefore any valid descriptor is not a valid descriptor template`. Is this because a descriptor template must contain at least one key placeholder? You might want to put that into 'Additional rules' if so.",
      "created_at": "2023-02-13T11:29:48Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104344236",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104344236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104355353",
      "pull_request_review_id": 1295456080,
      "id": 1104355353,
      "node_id": "PRRC_kwDOAN28mc5B0yAZ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "While `/**` is shorter, it also looks to be easy to mistype/confuse with `/*`. Compare with something like `/+` or `/++` for example.",
      "created_at": "2023-02-13T11:40:47Z",
      "updated_at": "2023-02-13T12:14:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104355353",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104355353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104362160",
      "pull_request_review_id": 1295456080,
      "id": 1104362160,
      "node_id": "PRRC_kwDOAN28mc5B0zqw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would it not be better to avoid listing the miniscript/descriptor elements that are supported, and just define this bip in terms of :\r\n\r\n1. A change to bip32 `KEY` expressions against miniscript/descriptors; they must be replaced with `@` placeholders\r\n2. Non-bip32 keys (e.g. raw and private keys) are not allowed (not sure if this is specified here)\r\n3. `/**` (or `/+` or whatever is decided on) is used for `<0;1>/*`, and presumably multi-path is disallowed elsewhere.\r\n\r\nGiven that implementations may only support a subset of elements, you might as well open it up to future elements and avoid needing to update this bip.",
      "created_at": "2023-02-13T11:47:25Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104362160",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104362160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853609",
      "pull_request_review_id": 1300535952,
      "id": 1107853609,
      "node_id": "PRRC_kwDOAN28mc5CCIEp",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Possible typo that the last key is `@3` instead of `@2`? ",
      "created_at": "2023-02-15T23:41:04Z",
      "updated_at": "2023-02-15T23:41:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1107853609",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853773",
      "pull_request_review_id": 1300536148,
      "id": 1107853773,
      "node_id": "PRRC_kwDOAN28mc5CCIHN",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1107853609,
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\r\n```",
      "created_at": "2023-02-15T23:41:20Z",
      "updated_at": "2023-02-15T23:41:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1107853773",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112720880",
      "pull_request_review_id": 1306924111,
      "id": 1112720880,
      "node_id": "PRRC_kwDOAN28mc5CUsXw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 232,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104341047,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d with `for complete examples.`",
      "created_at": "2023-02-21T08:32:31Z",
      "updated_at": "2023-02-21T08:32:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112720880",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112720880"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112721484",
      "pull_request_review_id": 1306924894,
      "id": 1112721484,
      "node_id": "PRRC_kwDOAN28mc5CUshM",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 245,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104341904,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d.",
      "created_at": "2023-02-21T08:33:04Z",
      "updated_at": "2023-02-21T08:33:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112721484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112721484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112722764",
      "pull_request_review_id": 1306926573,
      "id": 1112722764,
      "node_id": "PRRC_kwDOAN28mc5CUs1M",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(00112233445566778899aabbccddeeff00112233)))))</tt> - BOLT #3 offered HTLC policy.\n+* <tt>wsh(andor(pk(@0/**),or_i(and_v(v:pkh(@1/**),hash160(00112233445566778899aabbccddeeff00112233)),older(1008)),pk(@2/**)))</tt> - BOLT #3 received HTLC policy.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0))\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL))\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0,@1))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: BOLT #3 offered HTLC policy\n+ Descriptor template: wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(t:or_c(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),and_v(v:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),or_c(pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.\n+\n+== Backwards Compatibility ==\n+\n+The <tt>@</tt> character used for key placeholders is not part of the syntax of output script descriptors, therefore any valid descriptor template is not a valid descriptor template. Vice versa, any descriptor template with at least one key placeholder is not a valid output script descriptor.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 298,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104344236,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed the sentence and added the additional rule in da3e117d075f4428f14d4120124d840682e5587d.",
      "created_at": "2023-02-21T08:34:10Z",
      "updated_at": "2023-02-21T08:34:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112722764",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112722764"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112737026",
      "pull_request_review_id": 1306946219,
      "id": 1112737026,
      "node_id": "PRRC_kwDOAN28mc5CUwUC",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I prefer `/**` as it has a similar meaning in other languages (and was used in [BIP-0129](https://github.com/bitcoin/bips/blob/master/bip-0129.mediawiki#user-content-Descriptor_Template) for almost the same meaning).\r\n\r\nAs the `/*` alone is invalid for wallet policies, I don't see the risk of confusing it as very dangerous.\r\n\r\nIt's been pointed out in the past that `/**` is redundant since the `/<M;N>/*` expression is already more general, but in practice my expectation is that the vast majority of the use cases will just be happy with using `/**` for all the key expressions (which makes it a lot easier to inspect).\r\nComplex taproot scripts with many leaves might find the `/<M;N>/*` notation more interesting, perhaps.",
      "created_at": "2023-02-21T08:44:18Z",
      "updated_at": "2023-02-21T08:44:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112737026",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112737026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747316",
      "pull_request_review_id": 1306960514,
      "id": 1112747316,
      "node_id": "PRRC_kwDOAN28mc5CUy00",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's an option, indeed.\r\n\r\nI opted for a bottom-up definition (explicitly whitelisting the parts of the descriptor language that we adopt) because there are some inherent incompatibilities, plus it is hard to predict if more will come in the future. For example:\r\n- The `combo` descriptor seems inherently not fitting for wallet policies\r\n- Likewise, extensions like [this](https://github.com/bitcoin/bitcoin/pull/26626) would have to be \"blacklisted\" explicitly\r\n\r\nOn the other hand, the bottom-up approach leaves the exact spec for miniscript descriptors templates in the air, until there is no corresponding BIP...",
      "created_at": "2023-02-21T08:53:08Z",
      "updated_at": "2023-02-21T08:53:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112747316",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747783",
      "pull_request_review_id": 1306961112,
      "id": 1112747783,
      "node_id": "PRRC_kwDOAN28mc5CUy8H",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1107853609,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d, thanks!",
      "created_at": "2023-02-21T08:53:31Z",
      "updated_at": "2023-02-21T08:53:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112747783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113854499",
      "pull_request_review_id": 1308551027,
      "id": 1113854499,
      "node_id": "PRRC_kwDOAN28mc5CZBIj",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, we have to hope that at some point we stop shoe-horning in descriptor extensions for obsolete cases. Doing so makes a complete implementation prohibitively difficult, makes universal descriptor support less likely, and disincentivizes the eventual/priority movement of coins to modern UTXO/key derivation schemes.\r\n\r\n`combo`, and the linked extension both have in common that they change the cardinality of the solved descriptor. I think you could get the benefit of forward compatibility for this BIP by just stating that final wildcards and multi-path are the only supported key expressions that change cardinality, and all others are forbidden. Then any future extensions to the path syntax, and any expression fragments that return multiple variants would automatically be excluded.",
      "created_at": "2023-02-22T05:30:44Z",
      "updated_at": "2023-02-22T05:30:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113854499",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113854499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113860887",
      "pull_request_review_id": 1308559709,
      "id": 1113860887,
      "node_id": "PRRC_kwDOAN28mc5CZCsX",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, that's fair enough, I wasn't aware of BIP-0129. I'm OK with `/**` in that case. Given that:\r\n\r\n>It's been pointed out in the past that /** is redundant since the /<M;N>/* expression is already more general\r\n\r\nI think you should disallow `<0;1>/*` within wallet policies and require they be expressed as `/**`. Can't recall if that's already the case.\r\n\r\nIn fact I think you should go further and mandate the hardened indicator be only `'` (or `'h`, but only one or the other) in wallet policies. At the moment, the primary source of descriptor malleability (two textually different descriptors that describe the same thing, but have different checksums) is the key paths (plus no lexicographical sorting in the source `sortedmulti` key expression order). Given that you are replacing the keys with `@n` and enforcing monotonic numbering from left to right, doing the above will make it much simpler to identify standard policies/templates by not requiring all possible variants to be stored and compared. What do you think?\r\n\r\nedit: Forgot about multi-path. You need additionally to state that multi-path extensions of length 3 and greater must be sorted in numerical order.\r\n",
      "created_at": "2023-02-22T05:42:59Z",
      "updated_at": "2023-02-22T05:58:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113860887",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113860887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113866551",
      "pull_request_review_id": 1308567444,
      "id": 1113866551,
      "node_id": "PRRC_kwDOAN28mc5CZEE3",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the suggestions below to reduce/remove malleability are taken, I'd suggest `wallet patterns` as these strings describe the pattern of derivation without including the keys.",
      "created_at": "2023-02-22T05:52:52Z",
      "updated_at": "2023-02-22T05:52:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113866551",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113866551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114137256",
      "pull_request_review_id": 1308960513,
      "id": 1114137256,
      "node_id": "PRRC_kwDOAN28mc5CaGKo",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Mandating `'` instead of `h` sounds good to me, but completely fixing malleability is probably a lost battle.\r\nFor example, impossible to make sure are not reused if descriptors are different because of `multi`/`sortedmulti`, as you pointed out. More crucially, you might or might not know the key origin info of some external xpub (although this is only within the key info vector, not in the _descriptor template_).\r\n\r\nI'm not sure about disallowing the `/<M;N>/*` notation; for one thing, it's already adopted for descriptors and used in many multisig wallets. Moreover, I suspect using `<M;N>` other than `0;1` will have use cases: you might have the same root xpub in different spending conditions, but using different values for `M;N`. One use case might be _delegation_: `or(and(Alice1,Bob),and(Alice2,Carl))`: Alice might want to allow Bob to sign, but not Carl, so she only signs with `Alice1`. If only the `/**` notations is present, then the only option for Alice is to use two different xpubs; instead, one could have `or(and(Alice/<0;1>/*,Bob),and(Alice/<2;3>/*, Carl))` and have a single xpub for Alice.",
      "created_at": "2023-02-22T10:32:14Z",
      "updated_at": "2023-02-22T10:32:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114137256",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114137256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114139394",
      "pull_request_review_id": 1308963519,
      "id": 1114139394,
      "node_id": "PRRC_kwDOAN28mc5CaGsC",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "My understanding is that the plan is for extending descriptors liberally, but then implementations can choose which subset to implement. So the bottom-up approach is imho more likely to stay well-defined (but it's certainly more work and will need updates in the future).",
      "created_at": "2023-02-22T10:34:02Z",
      "updated_at": "2023-02-22T10:34:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114139394",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114139394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114182992",
      "pull_request_review_id": 1309028734,
      "id": 1114182992,
      "node_id": "PRRC_kwDOAN28mc5CaRVQ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 182,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> but completely fixing malleability is probably a lost battle.\r\n\r\nAgreed, it wasn't baked in at the start and can't be reliably added now. My goal is just to make sure that the common cases are all represented with the same pattern as much as possible.\r\n\r\n> I'm not sure about disallowing the /<M;N>/* notation\r\n\r\nTo be clear, I'm only suggesting this when M=0 and N=1, not in the general case! its just a simple text substitution much as the hardening indicator would be, that would go a long way to making common patterns trivially identifiable. Agreed that there are use cases for other values here.",
      "created_at": "2023-02-22T11:13:33Z",
      "updated_at": "2023-02-22T11:13:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114182992",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114182992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114186793",
      "pull_request_review_id": 1309033989,
      "id": 1114186793,
      "node_id": "PRRC_kwDOAN28mc5CaSQp",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 222,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll leave the approach here to your judgement, since there are arguments for both sides. My view is that descriptors become less useful the more incompatible implementations there are. In wally I'm likely just going to accept anything that looks like a correct pattern as long as it parses and doesn't change the cardinality when solved (assuming this BIP is accepted).",
      "created_at": "2023-02-22T11:17:18Z",
      "updated_at": "2023-02-22T11:17:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114186793",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114186793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182647115",
      "pull_request_review_id": 1409257811,
      "id": 1182647115,
      "node_id": "PRRC_kwDOAN28mc5GfcNL",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I am wondering if `signing policy/pattern` as a name can be useful too. Thinking of constraining outputs to spend to a predefined wallet, which isn't necessarily the wallet that is being spend _from_.\r\n\r\nFor example a policy that only allows spending to cold storage addresses derived from a pre-registered xpub.",
      "created_at": "2023-05-02T14:38:45Z",
      "updated_at": "2023-05-02T15:05:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182647115",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182647115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182668361",
      "pull_request_review_id": 1409290224,
      "id": 1182668361,
      "node_id": "PRRC_kwDOAN28mc5GfhZJ",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 214,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could an alternative to using the `/**` suffix be to separate define the wallet policies for the inputs and outputs? The input policy can then specify `/0/*` and the output policy `/1/*`. Both would still reference the same entry in the key info vector. The added flexibility may also be useful to constrain outputs to a known-but-different wallet.",
      "created_at": "2023-05-02T14:54:22Z",
      "updated_at": "2023-05-02T14:54:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182668361",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182668361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182679318",
      "pull_request_review_id": 1409307273,
      "id": 1182679318,
      "node_id": "PRRC_kwDOAN28mc5GfkEW",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 198,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Echoing the discussion in https://github.com/LedgerHQ/app-bitcoin-new/issues/153:\r\n\r\nIt would be great if a wallet policy can support 2-of-2 multisig transactions where one of the keys is ephemeral (completely random). This is useful when using presigned transactions to simulate covenants, for example to implement time-locked vaults.",
      "created_at": "2023-05-02T15:02:34Z",
      "updated_at": "2023-05-02T15:02:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182679318",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182679318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227756655",
      "pull_request_review_id": 1476595838,
      "id": 1227756655,
      "node_id": "PRRC_kwDOAN28mc5JLhRv",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 214,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1182668361,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe I am misunderstanding you, but: inputs can be /0/* or /1/* (changes can be spent too)",
      "created_at": "2023-06-13T08:40:36Z",
      "updated_at": "2023-06-13T08:40:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1227756655",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227756655"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227768530",
      "pull_request_review_id": 1476612443,
      "id": 1227768530,
      "node_id": "PRRC_kwDOAN28mc5JLkLS",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The spec above says that the `@N` must always be followed by `/**` or `/<NUM:NUM>/*`, but some examples and test vectors don't have that suffix. \r\n\r\n```\r\n followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\r\n* ''always'' followed by either:\r\n** the string  <tt>/**</tt>, or\r\n...\r\n```\r\n\r\nIs `@0` the same as `@0/**`? Would be good to fix either the specification or the examples/test vectors. ",
      "created_at": "2023-06-13T08:49:08Z",
      "updated_at": "2023-06-13T08:49:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1227768530",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227768530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312907268",
      "pull_request_review_id": 1606764397,
      "id": 1312907268,
      "node_id": "PRRC_kwDOAN28mc5OQWAE",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We have to also allow `/*` following `@n` (i.e. a single asterisk instead of two), since not all wallets use 0/1 paths to differentiate change addresses.\r\n\r\nI'm OK with `@n` alone expanding to `@0/**` but this does add even more malleability to expressions. Regardless, the `always` section should be updated to allow single asterisks.",
      "created_at": "2023-09-01T11:23:35Z",
      "updated_at": "2023-09-01T11:23:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1312907268",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312907268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316058847",
      "pull_request_review_id": 1611317016,
      "id": 1316058847,
      "node_id": "PRRC_kwDOAN28mc5OcXbf",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The naked `@N` was an oversight, I don't think it should be allowed as it would be confusing (Ledger's implementation doesn't permit it). I will fix it.\r\n\r\n--\r\n\r\nIf we generalize the suffix to expressions other than `<0;1>/*`, then we have to make sure that no pubkey is repeated.\r\nIn practice, for `/*`, that would mean that _all_ the placeholders must be followed by the exact suffix `/*`.\r\n\r\nOut of curiosity, what software wallets use that scheme?",
      "created_at": "2023-09-05T15:22:10Z",
      "updated_at": "2023-09-05T15:22:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316058847",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316058847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316487474",
      "pull_request_review_id": 1612042278,
      "id": 1316487474,
      "node_id": "PRRC_kwDOAN28mc5OeAEy",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> If we generalize the suffix to expressions other than <0;1>/*\r\n\r\nI'm not sure I follow. I'm not suggesting generalizing the suffix, at least in the sense of allowing general path expressions to be used as suffixes. I'm saying the only key expression suffixes that should be allowed are `/**`, `/<m;n>/*` and `/*`.\r\n\r\n> If we generalize the suffix to expressions other than <0;1>/*, then we have to make sure that no pubkey is repeated.\r\n\r\nI assume you mean here that a key expression could be given as `[/a/b/c]foo/**` and then elsewhere as `[/a/b/c/0]bar/*` and/or `[/a/b/c/1]bar/*` giving rise to the same derived keys with different key identifiers.\r\n\r\n> In practice, for /*, that would mean that all the placeholders must be followed by the exact suffix /*\r\n\r\nFor a given key expression, yes. I'm fine with supporting `/*` being optional, and if present the implementation must ensure this.\r\n\r\nNote also that at present this BIP does not state that implementations must ensure that `KP` expressions refer to distinct keys when substituting them into a policy, although that appears to be a requirement. I think it would also be clearer to state that all key expressions in a policy must be replaced by `KP` expressions (i.e. that no non-`KP` keys are allowed).\r\n\r\nAlso missing are that `<m;n>` expressions should be numerically sorted, and that explicit `<0;1>` should be disallowed.\r\n\r\nI'm happy to make individual commits with suggested changes for the above for you to review/cherry-pick. Should I create a PR against your repo for this?.\r\n\r\n> Out of curiosity, what software wallets use that scheme?\r\n\r\nBlockstream Green multisig wallets do not use bip44 style paths (the wallet predates the BIP). Also descriptors themselves do not enforce bip44 derivation.",
      "created_at": "2023-09-05T22:36:40Z",
      "updated_at": "2023-09-05T22:36:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316487474",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316487474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316995686",
      "pull_request_review_id": 1612884030,
      "id": 1316995686,
      "node_id": "PRRC_kwDOAN28mc5Of8Jm",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I'm not sure I follow. I'm not suggesting generalizing the suffix, at least in the sense of allowing general path expressions to be used as suffixes. I'm saying the only key expression suffixes that should be allowed are `/**`, `/<m;n>/*` and `/*`.\r\n\r\nWhat I mean is that if we allow mixing things like  `@0/*` with `@1/<m;n>/*`, then we for the xpub of `@1` we would need to derive `@1/m` and `@1/n` and compare with the pubkey of the xpub in `@0`, which is quite expensive on a hardware wallet.\r\n\r\nWith no mixing, for any two placeholders like `@0/<m;n>/*` and `@0/<p;q>/*`, I can just check that the sets `{m, n}` and `{p, q}` are disjoint.\r\n\r\n> For a given key expression, yes. I'm fine with supporting `/*` being optional, and if present the implementation must ensure this.\r\n\r\nNot just _for a given key expression_, I mean it across the entire wallet policy. That is, either the KPs all end with `/*`, or they all end with some `/<NUM;NUM>/*`.\r\n\r\n> Note also that at present this BIP does not state that implementations must ensure that `KP` expressions refer to distinct keys when substituting them into a policy, although that appears to be a requirement.\r\n\r\nGood point, worth adding explicitly the \"Additional rules\", with the motivation that it's required in miniscript (and it's simpler to add this restriction globally, rather than on the individual miniscript parts of the policy).\r\n\r\nSo basically:\r\n- all the public keys (deserialized from the corresponding xpubs in the keys information vector) must be distinct\r\n- all the derivations in each KP expression referring to the same index in the keys information vector must be distinct\r\n\r\nIn order to allow optional extensions like `/*`, perhaps I could mention that possibility in a separate section?\r\n\r\n> I think it would also be clearer to state that all key expressions in a policy must be replaced by `KP` expressions (i.e. that no non-`KP` keys are allowed).\r\n\r\nA wallet policy is the pair `(descriptor_template, keys_information_vector)`, so not sure what you mean here. The grammar seems to specify exactly what are the allowed KP and KEY expressions, as far as I can tell.\r\n\r\n> Also missing are that `<m;n>` expressions should be numerically sorted, and that explicit `<0;1>` should be disallowed.\r\n\r\nI like suggesting to sort `<m;n>` numerically, but not sure about disallowing `<0;1>`. I expect people to prefer not mixing `@0/**` with `@0/<2;3>/*`, as it's more explicit in that case to just write `@0/<0;1>/*`.\r\n\r\n> I'm happy to make individual commits with suggested changes for the above for you to review/cherry-pick. Should I create a PR against your repo for this?.\r\n\r\nSure, feel free to propose changes, but I'll try to incorporate the comments now. I'm also hoping to find the time for a general pass over the whole document to improve the Motivation section, as that was written before the BtcPrague meeting and it can surely be improved in hindsight.",
      "created_at": "2023-09-06T09:17:22Z",
      "updated_at": "2023-09-06T09:17:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316995686",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316995686"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317001469",
      "pull_request_review_id": 1612892796,
      "id": 1317001469,
      "node_id": "PRRC_kwDOAN28mc5Of9j9",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I like suggesting to sort <m;n> numerically, but not sure about disallowing <0;1>. I expect people to prefer not mixing @0/** with @0/<2;3>/*, as it's more explicit in that case to just write @0/<0;1>/*.\r\n\r\nWhat's the reason for sorting? It's not mentioned in [BIP-389](https://github.com/bitcoin/bips/blob/master/bip-0389.mediawiki).\r\n\r\n+1 to keep allowing `<0;1>/*` for readability for the reason you stated.",
      "created_at": "2023-09-06T09:21:57Z",
      "updated_at": "2023-09-06T09:21:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317001469",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317001469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317058627",
      "pull_request_review_id": 1612981459,
      "id": 1317058627,
      "node_id": "PRRC_kwDOAN28mc5OgLhD",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Not just for a given key expression, I mean it across the entire wallet policy.\r\n\r\nOK, I understand where you are coming from now. Enforcing this across the entire policy is sensible (no-one should be mixing key expressions with different cardinalities), and its pretty easy to implement.\r\n\r\n> So basically:\r\n\r\nYes these 2 two points are whats missing IMO.\r\n\r\n> perhaps I could mention that possibility in a separate section?\r\n\r\nSure, that works, let me know if you'd like me to draft it or if you are happy to.\r\n\r\n> The grammar seems to specify exactly what are the allowed KP and KEY expressions, as far as I can tell.\r\n\r\nThis is true, I just prefer being more explicit. Feel free to ignore this if you disagree.\r\n\r\n> I expect people to prefer not mixing\r\n> +1 to keep allowing <0;1>/* for readability\r\n\r\nNo doubt its slightly better for human readability in the rare case where alternate multipath derivations are given. But its bad for comparing two such policies (or checking against a whitelist of supported policies) because it's another source of malleability. It also complicates logic to convert a descriptor to a human friendly policy automatically, because substitution of `/<0;1>/*` for `/**` as recommended in this BIP will not result in the human friendly format in this case. Complicated policies are far more likely to be automatically generated than human written, and so in practice I suspect the large majority will end up mixing `/**` and `/<M;N>/*` anyway. However its your decision.\r\n\r\n> What's the reason for sorting?\r\n\r\nMalleability and ease of comparing multipaths. Unfortunately 389 states that the meaning of all n=2 multipaths is fixed (receive addresses and change), and so sorting is probably not possible to enforce given some hypothetical wallet out there could use descending numbers for this purpose.\r\n\r\n>  It's not mentioned in BIP-389\r\n\r\nTrue, but we limit multipaths to length 2 in policies which is also not part of 389.",
      "created_at": "2023-09-06T10:10:37Z",
      "updated_at": "2023-09-06T10:12:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317058627",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317058627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317077214",
      "pull_request_review_id": 1613010541,
      "id": 1317077214,
      "node_id": "PRRC_kwDOAN28mc5OgQDe",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Unfortunately 389 states that the meaning of all n=2 multipaths is fixed (receive addresses and change), and so sorting is probably not possible \r\n\r\nI was actually thinking primarily about this case and wondered why one would restrict people from using receive and change indices to be ordered.\r\n\r\n> Malleability and ease of comparing multipaths.\r\n\r\n`/<1;2;3>*` is not the same as `<3;2;1>/*`, so why should they be compared or treated to be the same? Applications may assign meaning to the position (similar to receive and change with two elements).\r\n\r\nIn practice it probably does not matter much, but I wouldn't impose this restriction here.\r\n\r\n> Blockstream Green multisig wallets do not use bip44 style paths (the wallet predates the BIP). \r\n\r\nOut of curiosity, how does Green identify which UTXOs are change?",
      "created_at": "2023-09-06T10:28:23Z",
      "updated_at": "2023-09-06T10:28:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317077214",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317077214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317295697",
      "pull_request_review_id": 1613358030,
      "id": 1317295697,
      "node_id": "PRRC_kwDOAN28mc5OhFZR",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As per this discussion:\r\n- 3ade41fc6bc12461388f34d5aebe9ba60a008704 makes the rules on distinct pubkeys explicit;\r\n- 0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc adds a section for the optional additional derivations, pointing out the potential footguns I could think of.\r\n\r\nI didn't add any requirement/suggestion to sort `<m;n>` expressions. Thanks for the comments, and feel free to suggest further changes, of course!",
      "created_at": "2023-09-06T13:34:33Z",
      "updated_at": "2023-09-06T13:34:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317295697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317295697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317822961",
      "pull_request_review_id": 1614200216,
      "id": 1317822961,
      "node_id": "PRRC_kwDOAN28mc5OjGHx",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@bigspider Thanks!\r\n\r\nComments on the current state:\r\n1. under `** a string of the form` there should be a new bullet point stating that any path expression as listed in the `Optional derivation paths` is optionally allowed.\r\n2. There still appear to be some bare `@n` references in the test vectors (e.g. multisig).\r\n3. The `Why must public keys be distinct?` reference doesn't appear to point anywhere. Do you have a reference to any docs/discussion on pubkey reuse in miniscript this can link to?\r\n4. Some invalid test vectors would be helpful for implementors to check against (see below).\r\n\r\nI'm fully implementing the BIP in wally now, and may have some further comments once that work is complete.\r\n\r\nSuggested invalid test vectors:\r\n1. `pkh(@0)` Key with no following path\r\n2. `pkh(@0/0/*)` Key with an explicit path present\r\n3. `sh(multi(1,@1/**,@0/**))` Keys used out of order\r\n5. `sh(multi(1,@0/**,@0/**))` Repeated keys w/same path expression\r\n6. `sh(multi(1,@0/<0;1>/*,@0/<1;2>/*))` Non-disjoint multipath expressions\r\n7. `sh(multi(1,@0/**,xpub6AHA9hZDN11k2ijHMeS5QqHx2KP9aMBRhTDqANMnwVtdyw2TDYRmF8PjpvwUFcL1Et8Hj59S3gTSMcUQ5gAqTz3Wd8EsMTmF3DChhqPQBnU/<0;1>/*))` Expression with a non `KP` key present\r\n8. `pkh(@0/<0;1;2>/*)` Solved cardinality > 2\r\n9. `combo(@0/**)` Disallowed expression type/Solved cardinality > 2",
      "created_at": "2023-09-06T20:54:07Z",
      "updated_at": "2023-09-11T22:26:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317822961",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317822961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317854062",
      "pull_request_review_id": 1614248571,
      "id": 1317854062,
      "node_id": "PRRC_kwDOAN28mc5OjNtu",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@benma \r\n\r\nnote slightly O/T to this BIP.\r\n\r\n> why one would restrict people from using receive and change indices to be ordered.\r\n> /<1;2;3>* is not the same as <3;2;1>/*, so why should they be compared or treated to be the same? Applications may assign meaning to the position (similar to receive and change with two elements).\r\n\r\nThey are the same assuming no other paths appear in the same expression; they both result in the same set of solutions, just in a different order. Of course this is not true with multiple keys: `<1;2;3>` and `<4;5;6>` have different solutions to `<3;2;1>` and `<4;5;6>` due to the stepwise resolution through path elements when generating the solutions. But in the single case its a cause of expression malleability.\r\n\r\nNote that ordering of expressions is not explicitly specified anywhere other than this stepwise derivation, and no meaning can be inferred except in the n=2 case (where all n=2 cases must be considered as receive/change even if this is not the intention). Consider expressions like `combo` or new extensions like explicit key lists. In what order is `combo(<key>/<1;2;3>/*)` solved, paths iterated first or the combo variants for each path?\r\n\r\nAs per my comments on the BIP the addition of extensions that change cardinality and the non-specification of ordering for N>3 means that we have the worst of all worlds: proscribed meaning for one case that prevents general use of N=2, and no ability to state anything about all the meaning of solutions when other expressions that change cardinality are present. Enforcing ordering and describing the expansion order of expressions would not have been onerous but would have allowed implementations to process them consistently instead of needing whitelists/understanding specific patterns.\r\n\r\n> In practice it probably does not matter much, but I wouldn't impose this restriction here.\r\n\r\nAgreed, this ship along with other malleability concerns has unfortunately sailed. Although it would be nice to enforce `'` rather than `h` for hardening in policies at least, @bigspider?\r\n\r\n> Out of curiosity, how does Green identify which UTXOs are change?\r\n\r\nFor singlesig wallets we use bip44 like everyone else, although you can't rely on the internal/external paths only for change detection, since its possible to create txs using either. For multisig we don't explicitly track change, the backend computes limits etc based on the net effect on the wallet, and displaying change is based on a simple check of the txs outputs (one output only to the wallet = redeposit, non-wallet output plus wallet output = payment and change etc).",
      "created_at": "2023-09-06T21:29:15Z",
      "updated_at": "2023-09-06T21:29:16Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317854062",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317854062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1318784475",
      "pull_request_review_id": 1615717273,
      "id": 1318784475,
      "node_id": "PRRC_kwDOAN28mc5Omw3b",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Agreed, this ship along with other malleability concerns has unfortunately sailed. Although it would be nice to enforce `'` rather than `h` for hardening in policies at least, @bigspider?\r\n\r\nI agree; Ledger's implementation only allows `'` (choice mostly because it looks better on a small screen).\r\nThe current specs indeed don't mention `h`.\r\n\r\nI'll go over the other comments (and add the failure cases, thanks!) next week.",
      "created_at": "2023-09-07T15:29:48Z",
      "updated_at": "2023-09-07T15:29:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1318784475",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1318784475"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322638320",
      "pull_request_review_id": 1621616177,
      "id": 1322638320,
      "node_id": "PRRC_kwDOAN28mc5O1dvw",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4b1f826217ab8f99c9484fbd6f1b1f88fa0c3bc0 should address all the remaining comments from this thread, thanks @jgriffiths!\r\n \r\n> Suggested invalid test vectors:\r\n> \r\n> 5. `sh(multi(1,@0/<0;1>/*,@1/<1;2>/*))` Non-disjoint multipath expressions\r\n\r\nThis is actually valid as <tt>@0</tt> and <tt>@1</tt> are independent; added an example where both are <tt>@0</tt> instead.",
      "created_at": "2023-09-12T08:22:02Z",
      "updated_at": "2023-09-12T08:22:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1322638320",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322638320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322706403",
      "pull_request_review_id": 1621709359,
      "id": 1322706403,
      "node_id": "PRRC_kwDOAN28mc5O1uXj",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For the miniscript reference, I suppose https://bitcoin.sipa.be/miniscript/ is the only one, although the mention of separate keys is quite [buried in the page](https://bitcoin.sipa.be/miniscript/#:~:text=We%20restrict%20this,using%20separate%20keys.) in the section on malleability.",
      "created_at": "2023-09-12T08:56:33Z",
      "updated_at": "2023-09-12T08:56:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1322706403",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322706403"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322758217",
      "pull_request_review_id": 1621791213,
      "id": 1322758217,
      "node_id": "PRRC_kwDOAN28mc5O17BJ",
      "diff_hunk": "@@ -298,6 +301,21 @@ Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3\n \n TBD: add examples with taproot scripts and miniscript.\n \n+=== Invalid policies ===\n+\n+The following descriptor templates are invalid:\n+\n+* <tt>pkh(@0)</tt>: Key placeholder with no path following it\n+* <tt>pkh(@0/0/*)</tt>: Key placeholder with an explicit path present",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 65,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "4b1f826217ab8f99c9484fbd6f1b1f88fa0c3bc0",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This needs to change to `**` from `*` to be a valid case for the non-extended BIP (my bad, sorry).",
      "created_at": "2023-09-12T09:36:37Z",
      "updated_at": "2023-09-12T09:40:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1322758217",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322758217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322774345",
      "pull_request_review_id": 1621816086,
      "id": 1322774345,
      "node_id": "PRRC_kwDOAN28mc5O1-9J",
      "diff_hunk": "@@ -298,6 +301,21 @@ Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3\n \n TBD: add examples with taproot scripts and miniscript.\n \n+=== Invalid policies ===\n+\n+The following descriptor templates are invalid:\n+\n+* <tt>pkh(@0)</tt>: Key placeholder with no path following it\n+* <tt>pkh(@0/0/*)</tt>: Key placeholder with an explicit path present",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 65,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "4b1f826217ab8f99c9484fbd6f1b1f88fa0c3bc0",
      "in_reply_to_id": 1322758217,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right! Fixed in 6f98026a2fd27069446fdfcabdfbaad6450b3e23.",
      "created_at": "2023-09-12T09:49:49Z",
      "updated_at": "2023-09-12T09:49:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1322774345",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1322774345"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 309,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1323565174",
      "pull_request_review_id": 1623131558,
      "id": 1323565174,
      "node_id": "PRRC_kwDOAN28mc5O5AB2",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@bigspider Thanks!\r\n\r\nThe wally implementation (https://github.com/ElementsProject/libwally-core/pull/369) is now complete and is being tested for addition to Jade. Once merged it would be good to add to the implementations section. At this stage it looks like this BIP has support in 3 HWW so getting a BIP number assigned should not be an issue.\r\n\r\nIt would be good IMO to squash all commits at this stage. I'll do a final review following wally code review and Jade testing. Many thanks for your responsiveness in addressing review comments.",
      "created_at": "2023-09-12T21:01:37Z",
      "updated_at": "2023-09-12T21:01:37Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1323565174",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1323565174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1336347383",
      "pull_request_review_id": 1642922706,
      "id": 1336347383,
      "node_id": "PRRC_kwDOAN28mc5Ppwr3",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "FYI policy support has been merged into wally now and support in Jade is now being tested.",
      "created_at": "2023-09-25T20:17:11Z",
      "updated_at": "2023-09-25T20:17:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1336347383",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1336347383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1436574890",
      "pull_request_review_id": 1796535592,
      "id": 1436574890,
      "node_id": "PRRC_kwDOAN28mc5VoGSq",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 9,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "07f0fcf5f4f2f857b03ab77fbc99a33ba1a34325",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this is supposed to be Standards Track.",
      "created_at": "2023-12-26T18:50:22Z",
      "updated_at": "2023-12-26T18:55:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1436574890",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1436574890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1449133515",
      "pull_request_review_id": 1816033751,
      "id": 1449133515,
      "node_id": "PRRC_kwDOAN28mc5WYAXL",
      "diff_hunk": "@@ -0,0 +1,343 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 9,
      "commit_id": "d4c650bad3ac190c9106d059b1ed5b110f2660bb",
      "original_commit_id": "07f0fcf5f4f2f857b03ab77fbc99a33ba1a34325",
      "in_reply_to_id": 1436574890,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Changed in d4c650bad3ac190c9106d059b1ed5b110f2660bb.",
      "created_at": "2024-01-11T16:46:50Z",
      "updated_at": "2024-01-11T16:46:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1449133515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1449133515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 9,
      "side": "RIGHT"
    }
  ]
}