{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1793",
    "id": 2396778495,
    "node_id": "PR_kwDOAN28mc6O2-__",
    "html_url": "https://github.com/bitcoin/bips/pull/1793",
    "diff_url": "https://github.com/bitcoin/bips/pull/1793.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1793.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1793/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
    "number": 1793,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "BIP 443: OP_CHECKCONTRACTVERIFY",
    "user": {
      "login": "bigspider",
      "id": 6681844,
      "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bigspider",
      "html_url": "https://github.com/bigspider",
      "followers_url": "https://api.github.com/users/bigspider/followers",
      "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
      "organizations_url": "https://api.github.com/users/bigspider/orgs",
      "repos_url": "https://api.github.com/users/bigspider/repos",
      "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/bigspider/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Hi all,\r\n\r\nThis is a draft for the formal specifications of the `OP_CHECKCONTRACTVERIFY` (`CCV`) opcode.\r\n\r\n`CCV` enables to build Script-based state machines that span across multiple transactions, by providing an ergonomic tool to commit to - and introspect - the Script and possibly some _data_ that is committed inside inputs or outputs.\r\n\r\nRelated to this PR:\r\n- [Implementation in bitcoin-core](https://github.com/bitcoin/bitcoin/pull/32080)\r\n- [Post on delving bitcoin](https://delvingbitcoin.org/t/op-checkcontractverify-and-its-amount-semantic/1527), focusing on the amount logic of the opcode.\r\n\r\nNot covered in this draft:\r\n- sigops budget (benchmarks needed)\r\n- activation logic\r\n- policy considerations (if any)\r\n\r\nI recommend delving bitcoin for high level discussions about alternative implementations, applications, etc.",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2025-03-17T05:58:38Z",
    "updated_at": "2025-05-08T16:39:29Z",
    "mergeable_state": "unknown",
    "merged": false,
    "merge_commit_sha": "ea9e9feb950de7715edb40b59b36c5f8419e6bf1",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "Merkleize:ccv",
      "ref": "ccv",
      "sha": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "user": {
        "login": "Merkleize",
        "id": 116372855,
        "node_id": "O_kgDOBu-1dw",
        "avatar_url": "https://avatars.githubusercontent.com/u/116372855?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Merkleize",
        "html_url": "https://github.com/Merkleize",
        "followers_url": "https://api.github.com/users/Merkleize/followers",
        "following_url": "https://api.github.com/users/Merkleize/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Merkleize/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Merkleize/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Merkleize/subscriptions",
        "organizations_url": "https://api.github.com/users/Merkleize/orgs",
        "repos_url": "https://api.github.com/users/Merkleize/repos",
        "events_url": "https://api.github.com/users/Merkleize/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Merkleize/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 902777682,
        "node_id": "R_kgDONc9LUg",
        "name": "bips",
        "full_name": "Merkleize/bips",
        "owner": {
          "login": "Merkleize",
          "id": 116372855,
          "node_id": "O_kgDOBu-1dw",
          "avatar_url": "https://avatars.githubusercontent.com/u/116372855?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/Merkleize",
          "html_url": "https://github.com/Merkleize",
          "followers_url": "https://api.github.com/users/Merkleize/followers",
          "following_url": "https://api.github.com/users/Merkleize/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/Merkleize/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/Merkleize/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/Merkleize/subscriptions",
          "organizations_url": "https://api.github.com/users/Merkleize/orgs",
          "repos_url": "https://api.github.com/users/Merkleize/repos",
          "events_url": "https://api.github.com/users/Merkleize/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/Merkleize/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/Merkleize/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/Merkleize/bips",
        "archive_url": "https://api.github.com/repos/Merkleize/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/Merkleize/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/Merkleize/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/Merkleize/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/Merkleize/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/Merkleize/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/Merkleize/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/Merkleize/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/Merkleize/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/Merkleize/bips/contributors",
        "deployments_url": "https://api.github.com/repos/Merkleize/bips/deployments",
        "downloads_url": "https://api.github.com/repos/Merkleize/bips/downloads",
        "events_url": "https://api.github.com/repos/Merkleize/bips/events",
        "forks_url": "https://api.github.com/repos/Merkleize/bips/forks",
        "git_commits_url": "https://api.github.com/repos/Merkleize/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/Merkleize/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/Merkleize/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/Merkleize/bips.git",
        "issue_comment_url": "https://api.github.com/repos/Merkleize/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/Merkleize/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/Merkleize/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/Merkleize/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/Merkleize/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/Merkleize/bips/languages",
        "merges_url": "https://api.github.com/repos/Merkleize/bips/merges",
        "milestones_url": "https://api.github.com/repos/Merkleize/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/Merkleize/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/Merkleize/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/Merkleize/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:Merkleize/bips.git",
        "stargazers_url": "https://api.github.com/repos/Merkleize/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/Merkleize/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/Merkleize/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/Merkleize/bips/subscription",
        "tags_url": "https://api.github.com/repos/Merkleize/bips/tags",
        "teams_url": "https://api.github.com/repos/Merkleize/bips/teams",
        "trees_url": "https://api.github.com/repos/Merkleize/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/Merkleize/bips.git",
        "hooks_url": "https://api.github.com/repos/Merkleize/bips/hooks",
        "svn_url": "https://github.com/Merkleize/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 15438,
        "default_branch": "ccv",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-04-13T13:12:47Z",
        "created_at": "2024-12-13T08:49:05Z",
        "updated_at": "2025-04-13T13:12:51Z",
        "allow_forking": true
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "fade15caa2142132ff153294d5c17459d5ae6206",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5588,
        "stargazers_count": 9905,
        "watchers_count": 9905,
        "size": 16096,
        "default_branch": "master",
        "open_issues_count": 38,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-05-08T16:52:04Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2025-05-08T16:52:08Z",
        "allow_forking": true
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 409,
    "deletions": 0,
    "changed_files": 5,
    "commits": 11,
    "review_comments": 72,
    "comments": 7
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDQyNDBmYThmYjFiYTgzNGVlYTFjNTJjMGQxYzBkOWFmMTQzODg3MmM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "tree": {
        "sha": "4e4b163d72d21e02f43ff953299e38f799430e3e",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/4e4b163d72d21e02f43ff953299e38f799430e3e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4e4b163d72d21e02f43ff953299e38f799430e3e\nparent 00c13baff0dc4a3a250d9725129b0d2c8d0be6a9\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1733697520 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742191365 +0100\n\nBIP draft for OP_CHECKCONTRACTVERIFY\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmfXuwUACgkQdAYP+Bsz\n5Pi6SAv8Da4XCyEPEfeaaGia2URq5O4YyOiqIOTmkZOxWmTEa0JBq2DSrHt5M07Q\nZVYThqsudWxpVv0RLkc/h97VeArzo5OkTGE1+2dDuvL/ZQ8QlnNE6OMnpVoveWmp\nXTLqko8NRPSWroq434aKo+vPfYnfDD1FV6lmbxtgY3+p5SPAqFGDER1mpTUNj5Yi\n1Jt15aOgXvAHiQTzXQn2A5BICccwqvUkWz+5y28DIToScSmOGGL04cI5df/PkmjC\n8dJoxWVweDRCfvByu1CNHEMiSS+oOGp8hmk9sY9PmDSQGwlOS4+XERKzpovXB49w\nkDAECLgisxC1ja7PaBtmXU6+3JD9jsjD0lGpQTBdTcZ9BUGJBwk9B6XqR69Fu7/J\neenSoUkAV/TmxnRtWx2ctrBaNQlkwaSTPcgyErMM5CLJOQUKk33nyRdO8THk3hB9\nG62G6AJbfkiBH4uM0koeDQcW1jRbG5EOSZ0AA7lIRYI20fqfTS3zEHWC/e38RSZY\nxAvEE1zZ\n=O1Hl\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/00c13baff0dc4a3a250d9725129b0d2c8d0be6a9",
          "sha": "00c13baff0dc4a3a250d9725129b0d2c8d0be6a9",
          "html_url": "https://github.com/bitcoin/bips/commit/00c13baff0dc4a3a250d9725129b0d2c8d0be6a9"
        }
      ],
      "message": "BIP draft for OP_CHECKCONTRACTVERIFY",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-17T06:02:45Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-12-08T22:38:40Z"
      },
      "sha": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16795030288,
      "node_id": "HRFPE_lADOAN28mc6uRj3YzwAAAAPpD9MQ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16795030288",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": "https://api.github.com/repos/Merkleize/bips/commits/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "created_at": "2025-03-17T06:02:49Z"
    },
    {
      "event": "labeled",
      "id": 16795496149,
      "node_id": "LE_lADOAN28mc6uRj3YzwAAAAPpFu7V",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16795496149",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-17T06:37:02Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "reviewed",
      "id": 2690410810,
      "node_id": "PRR_kwDOAN28mc6gXGk6",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2690410810",
      "submitted_at": "2025-03-17T13:02:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2693778798,
      "node_id": "PRR_kwDOAN28mc6gj81u",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "jirijakes",
        "id": 1381856,
        "node_id": "MDQ6VXNlcjEzODE4NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1381856?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jirijakes",
        "html_url": "https://github.com/jirijakes",
        "followers_url": "https://api.github.com/users/jirijakes/followers",
        "following_url": "https://api.github.com/users/jirijakes/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jirijakes/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jirijakes/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jirijakes/subscriptions",
        "organizations_url": "https://api.github.com/users/jirijakes/orgs",
        "repos_url": "https://api.github.com/users/jirijakes/repos",
        "events_url": "https://api.github.com/users/jirijakes/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jirijakes/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2693778798",
      "submitted_at": "2025-03-18T10:03:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695286980,
      "node_id": "PRR_kwDOAN28mc6gptDE",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695286980",
      "submitted_at": "2025-03-18T16:21:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "commented",
      "id": 2734121346,
      "node_id": "IC_kwDOAN28mc6i92GC",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2734121346",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T17:25:05Z",
      "updated_at": "2025-03-18T17:47:09Z",
      "author_association": "MEMBER",
      "body": "Some initial questions that come to mind:\r\n\r\n1. Do you really need inputs to check other inputs? What does that enable? Otherwise my sense is that evaluating each input independently of others makes life easier (but you'll find out when implementing).\r\n\r\n2. Can you make it so the output ordering doesn't matter?\r\n\r\n3. You bring up \"vector commitments\" with no further comment, but it would be good to at least briefly explain what they're good for.\r\n\r\nAnd see inline.\r\n\r\n---\r\n\r\nupdate:\r\n1) maybe it's not too bad, because you're only checking the `scriptPubKey` other inputs are spending",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2734121346",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "reviewed",
      "id": 2695539462,
      "node_id": "PRR_kwDOAN28mc6gqqsG",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695539462",
      "submitted_at": "2025-03-18T17:25:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695547018,
      "node_id": "PRR_kwDOAN28mc6gqsiK",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695547018",
      "submitted_at": "2025-03-18T17:28:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695549014,
      "node_id": "PRR_kwDOAN28mc6gqtBW",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695549014",
      "submitted_at": "2025-03-18T17:28:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695556405,
      "node_id": "PRR_kwDOAN28mc6gqu01",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695556405",
      "submitted_at": "2025-03-18T17:30:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695572302,
      "node_id": "PRR_kwDOAN28mc6gqytO",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695572302",
      "submitted_at": "2025-03-18T17:34:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695587204,
      "node_id": "PRR_kwDOAN28mc6gq2WE",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695587204",
      "submitted_at": "2025-03-18T17:38:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGIyMTk5OTUwNTBiYTczNDQ2ZDNhZWVmMzFkYzMwNGUxNWM5YTZiNGU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b219995050ba73446d3aeef31dc304e15c9a6b4e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/b219995050ba73446d3aeef31dc304e15c9a6b4e",
      "tree": {
        "sha": "938b30d8b98d31aeeebfc7a9645375418bc03296",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/938b30d8b98d31aeeebfc7a9645375418bc03296"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 938b30d8b98d31aeeebfc7a9645375418bc03296\nparent 4240fa8fb1ba834eea1c52c0d1c0d9af1438872c\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742666885 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742666885 +0100\n\nAddress some comments from review\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmfe/IUACgkQdAYP+Bsz\n5PilSwv9HnwQJv0o7a7D8mYcc/bDrNDhMrIuUOQE65wBNzvFHxuKrUT3KSNsuh5S\nT1QixDTBgffNqBb96+GNjJEPmkaZm9M4k16KpR2tkN31A0mvxVt1Q4TQ2A7IoDud\nXEEuaKI5G7meeqtwF7+sB1zaKzWBBwwuPhsU4221WimLKUejpmc/8wFBSfb8/1Gq\ncWMtBrn7wPSoJTdAt51Jzm0/ogCmG6CTlR6M2EPvdub7qSbetSoAjv1oqka1C1k9\nF/+R1On2bQl/4YJ1MbxO7AgOysfa7mufhYXlBk93dt9go8LRtSl0tIxIQrfUO37B\n9tl8jQX5xjHg1lLjBCxfr/GyAwmIcCwWBbpeFUVYrlIdqHXMVnVUy5Qr0w0v7tzJ\n3P5rRVPSVLQ/OXkjEfklgvqXv1gVwdN7Qqq6IkWsDah481ufL6+Cn1M78DLIinv9\ncaX+FCX7AFKfRnRXql9gK71U9gJ48OGwVSqbqg/EX5upQxPU4TbTif2D+6WRJ08i\nxehZV5bn\n=xQWH\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
          "sha": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
          "html_url": "https://github.com/bitcoin/bips/commit/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c"
        }
      ],
      "message": "Address some comments from review",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-22T18:08:05Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-22T18:08:05Z"
      },
      "sha": "b219995050ba73446d3aeef31dc304e15c9a6b4e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGFhMjkxYzIzZmJkM2E0NmY4NWI5NGIwZmI4NmVkNDc1ZjBkYWY3NDY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "tree": {
        "sha": "4f1dfd2efba6b9afc40bbd5aeaa243d3269db47a",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/4f1dfd2efba6b9afc40bbd5aeaa243d3269db47a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4f1dfd2efba6b9afc40bbd5aeaa243d3269db47a\nparent b219995050ba73446d3aeef31dc304e15c9a6b4e\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742667502 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742667502 +0100\n\nFix formatting inside the blockquote\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmfe/u4ACgkQdAYP+Bsz\n5Pjragv+MoGMUIOpX8wd/e0H2IacMbvym7an6kqu4fbjSxcfKc0VcvvF4xfvPYOB\nwnFtB7d/LxlwZeA/F8y856jISo85hP4Qd/YpKsoUxukn4+eBHNlhoGd9+RCbvVHo\nXARxgMHjX/4+X1ZtKK6kif1UKdO5Ah/FkzT5kiqvFVFmnxoqXZLPYGrd9XywHtUw\nRoAgyNM8D2cgGaXjmW7SPR4N5N6Y+gYCJ6O5FyiOiR0YjuOofyty7pqMmOPAxzqn\nXwfZZqMIR17usN/S5teCX9QK6VN/EmQ7/X6ahlS9/TtACx3kbR3y6r6xg00G2ken\nTNzXKUzvK3FCWVUvf7bj4FJSvSVGuaOyTcd4q5qzxzyxqyK/adexJZRBVrJsGyMb\nUiD9BZJ9rtXFNafA1aW6axpAx+0HrA028KB3bv2DAF4qPzZcLHwkS9OtOkkzK5pX\nKCOyHPSbZye+X/gJQeM5jVVlHMFZWDgVHVgV3kn2h8fPbSXxWQV81GwycxCWFSSr\n9DUfCbmq\n=NzUa\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b219995050ba73446d3aeef31dc304e15c9a6b4e",
          "sha": "b219995050ba73446d3aeef31dc304e15c9a6b4e",
          "html_url": "https://github.com/bitcoin/bips/commit/b219995050ba73446d3aeef31dc304e15c9a6b4e"
        }
      ],
      "message": "Fix formatting inside the blockquote",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-22T18:18:22Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-22T18:18:22Z"
      },
      "sha": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746"
    },
    {
      "event": "commented",
      "id": 2745410697,
      "node_id": "IC_kwDOAN28mc6jo6SJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2745410697",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-22T18:57:44Z",
      "updated_at": "2025-03-22T18:57:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "> 1. Do you really need inputs to check other inputs? What does that enable? Otherwise my sense is that evaluating each input independently of others makes life easier (but you'll find out when implementing).\r\n\r\nI don't think it would make it easier; in fact, apart from the amount semantic (amounts are not checked when you CCV-check and input), the opcode's behavior is currently very symmetric. So in a way, I think the current formulation is simpler by not restricting to just the current input (while staying more general).\r\n\r\nIn everything I worked on so far (even in combinations with other opcodes, e.g. see [pymatt](https://github.com/Merkleize/pymatt)), checking just the current input is indeed sufficient. However, I think it's likely that it would be useful in some more advanced constructions. For example, you could create a separate _sentinel_ UTXO, and have some spending condition (possibly for many UTXOs at the same time) be only available if the sentinel UTXO is present in the transaction. Once the sentinel is spent, those spending conditions become unavailable for all the remaining. That seems similar in spirit to the _connector outputs_  used in Ark, but without presigned transactions, so I suspect it's useful.\r\n\r\n> 2. Can you make it so the output ordering doesn't matter?\r\n\r\nYou can leave flexibility as to where outputs must be by either\r\n- using -1 for the output index (meaning, the corresponding output must be in the same position as the input index); this would for example allow batching multiple 1-input-1-output CCV-encumbered spends (where each input must \"produce\" its own output, without aggregation) in the same transaction\r\n- passing the `<index>` parameter in the witness of the transaction. E.g. in the [vault example](https://github.com/bitcoin/bitcoin/pull/32080/files#diff-e796b699bc9cf1f5b7f2eb10c2d88f5c47b7701d5835ca7734fbfafd7d72e87c), the _revault index_ and the _trigger index_ of the `trigger_and_revault` clause are arbitrary in this way.\r\n\r\n> 3. You bring up \"vector commitments\" with no further comment, but it would be good to at least briefly explain what they're good for.\r\n\r\nI'll add a footnote, thanks!\r\n",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2745410697",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "reviewed",
      "id": 2711501789,
      "node_id": "PRR_kwDOAN28mc6hnjvd",
      "url": null,
      "actor": null,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2711501789",
      "submitted_at": "2025-03-24T19:51:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2711548786,
      "node_id": "PRR_kwDOAN28mc6hnvNy",
      "url": null,
      "actor": null,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2711548786",
      "submitted_at": "2025-03-24T19:59:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "commented",
      "id": 2749295131,
      "node_id": "IC_kwDOAN28mc6j3uob",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2749295131",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-24T20:17:40Z",
      "updated_at": "2025-03-24T20:19:32Z",
      "author_association": "MEMBER",
      "body": "Do you have any thoughts on what this could look like in terms of descriptors? Either in the general case of anything that can be expressed in miniscript, or more narrowly for something like a vault?\r\n\r\nE.g. fresh vault deposit addresses could be generated from something like `tr(cold,{trigger_leaf})`, where `trigger_leaf` could be something like `ccv(-1,{withdraw_leaf,recover_leaf},0,...)`, and `recover_leaf` is `tr(cold)`, etc.\r\n\r\nSince programs can take arbitrary data, e.g. a withdrawal address for a vault, I could imagine that when a wallet signs (or detects an unauthorized) a trigger transaction it generates a descriptor for that, so that it knows how to spend it (and when).\r\n\r\nFor the first part the wallet software doesn't even need to know what a vault is. For the second part it probably does need to \"understand\" it in order to know what descriptors to generate, and in order to prompt the user for the right action.\r\n\r\nBut how generalisable is that?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2749295131",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "commented",
      "id": 2751483735,
      "node_id": "IC_kwDOAN28mc6kAE9X",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2751483735",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T14:37:02Z",
      "updated_at": "2025-03-25T14:37:02Z",
      "author_association": "MEMBER",
      "body": ">> Do you really need inputs to check other inputs? What does that enable?\r\n\r\n> However, I think it's likely that it would be useful in some more advanced constructions. For example, you could create a separate sentinel UTXO,\r\n\r\nJust saw the mailinglist thread about this from 2023: https://gnusha.org/pi/bitcoindev/CALZpt+F251k7gSpogwFYHxFtGxc_tZjB4UU4SVEr=WvrsyMVMQ@mail.gmail.com/\r\n\r\nThe BIP should probably address the pros and cons of \"cross-input inspection\".",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2751483735",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "commented",
      "id": 2752789566,
      "node_id": "IC_kwDOAN28mc6kFDw-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2752789566",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T23:52:31Z",
      "updated_at": "2025-03-25T23:52:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Do you have any thoughts on what this could look like in terms of descriptors? Either in the general case of anything that can be expressed in miniscript, or more narrowly for something like a vault?\r\n\r\n@sanket1729 has given several great talks on generalizing miniscript for covenant use cases, you can look for those if you're interested.\r\n\r\nMy general take is that descriptors are the wrong tool for this purpose: a spend from UTXO X to UTXO Y where f(Y) = X needs to somehow encode the relation between X and Y as a _predicate_. While you could do that (every program is a predicate, and every program expressible in Script is a predicate that can be expressed in a tree structure like miniscript...) it quickly becomes unmanageable.\r\n\r\nFor CCV, what works well (kinda by design) is to think in terms of _states_ and _state transitions_. You can check [these docs](https://github.com/Merkleize/pymatt/blob/master/docs/contracts.md) and the code examples in the [pymatt](https://github.com/Merkleize/pymatt) repo if you're interested in more details in how I'm framing it - the PR in bitcoin-core strips most of those useful abstractions for the sake of conciseness, but that's certainly not how one would write those contracts in practice.\r\n\r\nThe framework has some nice properties: once you define the contracts, all you need to know is the contract definition, and the initial parameters. Everything else can be deterministically derived from that, and the blockchain. You can scan for the initial UTXOs matching that contract, and given a transaction spending those UTXOs, you can deterministically deduce what are the next states, parameters (and data, if any) of the new UTXOs that are produced. That's even when someone else in the contract made transactions, as it's easy to 'decode' the witness to understand what _clause_ (tapleaf) was used, and with what arguments. \r\n\r\n> Just saw the mailinglist thread about this from 2023: https://gnusha.org/pi/bitcoindev/CALZpt+F251k7gSpogwFYHxFtGxc_tZjB4UU4SVEr=WvrsyMVMQ@mail.gmail.com/\r\n> \r\n> The BIP should probably address the pros and cons of \"cross-input inspection\".\r\n\r\nI personally think speculation on all the possible ways people might use (and abuse) the opcode is out of scope, and it quickly gets unmanageable - because there is an infinite number of ways of (per-)using the opcode. For example, both [`OP_CAT`](https://github.com/bitcoin/bips/blob/master/bip-0347.mediawiki) and [`OP_TXHASH`](https://github.com/bitcoin/bips/pull/1500) both enable fine-grained introspection of other inputs, and would therefore raise the same concern - if one thinks that is a valid concern; yet the BIPs don't discuss this.\r\n\r\nIMHO that kind of discussion would be more fitting for a BIP describing a proposal to activate a certain package of opcodes as a soft-fork. OP_CCV is not meant to be activated as a stand-alone opcode (that would be kinda silly for a number of reasons). Such a BIP could in fact focus on the _capabilities_, ignoring the exact details of the opcodes (that are not interesting in that context).",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2752789566",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "mentioned",
      "id": 16983356260,
      "node_id": "MEE_lADOAN28mc6uRj3YzwAAAAP0SXNk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16983356260",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T23:52:32Z"
    },
    {
      "event": "subscribed",
      "id": 16983356271,
      "node_id": "SE_lADOAN28mc6uRj3YzwAAAAP0SXNv",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16983356271",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T23:52:32Z"
    },
    {
      "event": "commented",
      "id": 2753613916,
      "node_id": "IC_kwDOAN28mc6kINBc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2753613916",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-26T08:42:46Z",
      "updated_at": "2025-03-26T08:42:46Z",
      "author_association": "MEMBER",
      "body": "\r\n> @sanket1729 has given several great talks on generalizing miniscript for covenant use cases, you can look for those if you're interested.\r\n\r\nFound one, which I'll watch: https://www.youtube.com/watch?v=xNAn9LTzk2g\r\n\r\n> My general take is that descriptors are the wrong tool for this purpose:\r\n\r\n> You can check [these docs](https://github.com/Merkleize/pymatt/blob/master/docs/contracts.md) and the code examples in the [pymatt](https://github.com/Merkleize/pymatt) repo if you're interested in more details in how I'm framing it\r\n\r\nI'll look into that. With previous soft forks like SegWit and Taproot it took many years after activation for enough tooling to be developed to fully take advantage. I'm trying to get a sense of that in this case. It seems fine keep the actual Bitcoin Core implementation simpler.\r\n\r\n> IMHO that kind of discussion would be more fitting for a BIP describing a proposal to activate a certain package of opcodes as a soft-fork\r\n\r\nThat makes sense. My impression so far is that there exists some sort of covenant threshold beyond which we open the pandora's box, and it doesn't really matter how we cross the threshold.\r\n\r\nPerhaps there could be a BIP that discusses several combinations of op codes, explain which combinations cross the threshold, and then explain why that's fine, or not.\r\n\r\nIf it's fine to cross the threshold, I tend to think we should go for the most powerful tool(s) with simplest and safest implementation. \r\n\r\nIf it's not fine, we would be limited to extremely restricted op codes that give us desired functionality without crossing the threshold.",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2753613916",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "mentioned",
      "id": 16988157074,
      "node_id": "MEE_lADOAN28mc6uRj3YzwAAAAP0krSS",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16988157074",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-26T08:42:47Z"
    },
    {
      "event": "subscribed",
      "id": 16988157090,
      "node_id": "SE_lADOAN28mc6uRj3YzwAAAAP0krSi",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16988157090",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-26T08:42:47Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDRlZDcxODQzZTUxNzQyYjZhNjBmNDQ1YzI3MmI3M2ExZTkwZGMxMGY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4ed71843e51742b6a60f445c272b73a1e90dc10f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/4ed71843e51742b6a60f445c272b73a1e90dc10f",
      "tree": {
        "sha": "57d016758819e62517c4761cb592a038a0157fd5",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/57d016758819e62517c4761cb592a038a0157fd5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 57d016758819e62517c4761cb592a038a0157fd5\nparent aa291c23fbd3a46f85b94b0fb86ed475f0daf746\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1743242880 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1743266700 +0100\n\nRename flags -> mode\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmfoI4wACgkQdAYP+Bsz\n5PjuugwAidJjIEOvbVh+k6kuDR75UwTxKmPBuixSDdinGTc7KU7hOjhqfcBbpzcI\n0OhxQMsUNAH880UUM6rjJzRfDis8b69pjDSULA0Y3kfwZ/8QibIy6iXxe2DB7y+d\nXJ9pzzn4XcIqpfNxCmb2Xj1LGPiwF7Rg9ibs7Gz7u0Q8Ttqmgad2JqjcZ6G7Yrfn\nO6aT1DSGdmgFI8VnBslY8yBvpMXINoVnn3ARoydFXSo+hNkK2oa72fEI6DdHGQYE\ntYdaqT4Re54ckY8xUaaTrydooW/SDHwDZTu88+FfcZFoMLjGvk54GsF+S5lvuTx8\neLkcdgrZ60t6LItcG+x1f19M341Q7NlyZcJo534dZMxLMXRAf2ROhdAReYX7OJ+M\nxNnfOpzeUoLRfTaVOIurvGOns6hxPktA86VszOlpbVecpwPlfyg8yOHX6w6FvQTt\nLiAE5STSqiuOfms6oFpan8ltZsiJjZug8Oyd3vpYgPfdKOpj6s5Zw/eZ1kkqGCIh\nmnHwr3e+\n=ZqkP\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
          "sha": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
          "html_url": "https://github.com/bitcoin/bips/commit/aa291c23fbd3a46f85b94b0fb86ed475f0daf746"
        }
      ],
      "message": "Rename flags -> mode",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-29T16:45:00Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-29T10:08:00Z"
      },
      "sha": "4ed71843e51742b6a60f445c272b73a1e90dc10f"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGQxMDk3MWIwYmMzN2E4NzEwZjg5MDEyYmVjNjgxZTk4NmZhODc3OTk",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/d10971b0bc37a8710f89012bec681e986fa87799",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/d10971b0bc37a8710f89012bec681e986fa87799",
      "tree": {
        "sha": "e5466c654c5e46e52b302b9c635ee69c06b111c7",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/e5466c654c5e46e52b302b9c635ee69c06b111c7"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e5466c654c5e46e52b302b9c635ee69c06b111c7\nparent 4ed71843e51742b6a60f445c272b73a1e90dc10f\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1743248222 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1743266700 +0100\n\nAdd footnote about vector commitments\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmfoI4wACgkQdAYP+Bsz\n5Pj1Sgv8CBuUVUBpujjcznJvGb3P4+Xw+j6PKcPzWDpGdqmbNafkd89rnObZh0CW\n3cGTrDH7b4LH7AECRMKwNmlSw9yUoWHxgyz9fyn/1bc9JNNWQT7Zq5u65GRqbJ9e\nrCrJc8FW7ufxD9yE2ipRyCwF//RXjQjJMvyOzvHXMSArMawUM4nYOW+SFO+qavtO\nrN35Fbyd8lY2FAn4HFMtOqZUsqh8a5W82MeiDr03YwvWggf5wcg8Co3iCqr2dpvw\nJOxKjnkGfNPNWeOcHeoZCVmxJjGoFjNYLnZeA/WAbKzS+PXSOl1bL2jNEXtvW8mM\nr042agSqvsBDnHmiZGwcOKH1N4sXQfAgmg97Kfwx1PKZJs6ucVzVc8jIHRtcmogr\n2std+V3zLg2IchNT/KkXaAKUgEnULPnmmC8S3GMhSMr3lQ7eY9HJUsLfrFYDOY4O\nvIJHNfQcvHZ8/2uqbykhuV8wRGUpZ7nfvFfJMBDs1YpTs4d9xMrMFky0MeV++AhP\ntMmRwNf4\n=zela\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4ed71843e51742b6a60f445c272b73a1e90dc10f",
          "sha": "4ed71843e51742b6a60f445c272b73a1e90dc10f",
          "html_url": "https://github.com/bitcoin/bips/commit/4ed71843e51742b6a60f445c272b73a1e90dc10f"
        }
      ],
      "message": "Add footnote about vector commitments",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-29T16:45:00Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-29T11:37:02Z"
      },
      "sha": "d10971b0bc37a8710f89012bec681e986fa87799"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 17044585551,
      "node_id": "HRFPE_lADOAN28mc6uRj3YzwAAAAP377xP",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/17044585551",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d10971b0bc37a8710f89012bec681e986fa87799",
      "commit_url": "https://api.github.com/repos/Merkleize/bips/commits/d10971b0bc37a8710f89012bec681e986fa87799",
      "created_at": "2025-03-29T16:45:04Z"
    },
    {
      "event": "reviewed",
      "id": 2734079838,
      "node_id": "PRR_kwDOAN28mc6i9r9e",
      "url": null,
      "actor": null,
      "commit_id": "d10971b0bc37a8710f89012bec681e986fa87799",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "The formatting looks mostly good, got one nit. This seems to have some action already, so I will take a look at the content when the open feedback has been processed.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2734079838",
      "submitted_at": "2025-04-01T21:27:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDliY2NmNTQ1OTMwZjlkNGI4MjExZjExZDViZDkzZWFjMjdiNzU2OTU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "tree": {
        "sha": "0451ea6c9e3e0f50c9ec90513daf079386ceb18b",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/0451ea6c9e3e0f50c9ec90513daf079386ceb18b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 0451ea6c9e3e0f50c9ec90513daf079386ceb18b\nparent d10971b0bc37a8710f89012bec681e986fa87799\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1743629236 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1743629236 +0200\n\nAddress some comments from PR review; delete unused 'References' section\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmftq7QACgkQdAYP+Bsz\n5Pi7yAv/YG0ahnYxsKyuCz+JyB1ZrE3XvtCNbomROUyL+iDhejrMMD45Nce8I+oI\nQSHr/tEGgJa3sKpz9NLqpPRUc6xP+GLt/7whwRN7tkWeOptyR61eihGnNc0hIqlG\n//Dh9y0ZoJ0MGW/rctlVw9AeVUIX8N0dtAkgNakDiAlTgGe5mmuW+AGyI+kL9ysc\n28HYViNM2yTUnG8+sXsJiQmQ7Kh5OzA3qPGaaqUEfEeOqCB46K19yRd5GWYzPxO6\n3zm2jNymm11oyWvp23zvHNcq+gHjI1rN0wzXYTSI4qTERooJ9GIF75dAo9jP9IH6\ndLMoaDL9KB3C4SFNbfYykk3JPyj8P7TgqLYO+nJauT9gthJ0+pMbo7fDUKZ/6GvG\nRWLGoRBtINw4xcCL75rRWA1TNiS0G536KTJ6GAnVHMGeNRUKHmKawR+WpyteJY7q\nJFV5aHVL/3Mpz5ElvLipqRWayFKiO4qKoDmGcIlPUjNocOiN+CI5aBepEfh0HAlv\nt2zZlf/u\n=TQMc\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/d10971b0bc37a8710f89012bec681e986fa87799",
          "sha": "d10971b0bc37a8710f89012bec681e986fa87799",
          "html_url": "https://github.com/bitcoin/bips/commit/d10971b0bc37a8710f89012bec681e986fa87799"
        }
      ],
      "message": "Address some comments from PR review; delete unused 'References' section",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-02T21:27:16Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-02T21:27:16Z"
      },
      "sha": "9bccf545930f9d4b8211f11d5bd93eac27b75695"
    },
    {
      "event": "reviewed",
      "id": 2744075120,
      "node_id": "PRR_kwDOAN28mc6jj0Nw",
      "url": null,
      "actor": null,
      "commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "I only got up to the start of the section \"Script support for <code>OP_CHECKCONTRACTVERIFY</code>\" this time.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2744075120",
      "submitted_at": "2025-04-04T21:41:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGQyNDZhNjEyNDkxNjg3N2JlMDk4ODcwOGI5MDQwMjc2M2E2YWEwZjA",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/d246a6124916877be0988708b90402763a6aa0f0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/d246a6124916877be0988708b90402763a6aa0f0",
      "tree": {
        "sha": "705a1ddb62e66d7f32a40d5a7347f87df3eafd41",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/705a1ddb62e66d7f32a40d5a7347f87df3eafd41"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 705a1ddb62e66d7f32a40d5a7347f87df3eafd41\nparent 9bccf545930f9d4b8211f11d5bd93eac27b75695\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744495409 +0200\ncommitter GitHub <noreply@github.com> 1744495409 +0200\n\nApply suggestions from code review\n\nCo-authored-by: Mark \"Murch\" Erhardt <murch@murch.one>",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsFcBAABCAAQBQJn+uMxCRC1aQ7uu5UhlAAATLUQAAeWF1O2u2ZnYO1c0yFc7ylh\ndqxuVAeJ6sDvvDakL2SiHydA5EBJZW+wuIOxrepf/sxSjKCDggmfXjyLe7d6nk0E\nDdehOrmM1zf+RHiPv/GWE8TmrbqRcK5L9UKhjnNe0/6GAcTwttxnvwb+/FdLDrvw\npXjQ1XZTmhdJGex2PPiAwA+nn8G6qTQjKu41PTlVajq6zvEBS0OsclxxozAIkDuJ\noKsLrq47Q1Uqd1KTrXDytSybBKkyo3Wvj8LJLvQ/vPY54y6FeNh5BQYhPRpq80yr\nUofNHVfvJVGLY7jpwybo1E06nflqiCnWnznDcdrqvK/0Daxbf5m2xHYA2IA78/MJ\nTaKH+tH72PNr06idQI+NzaXwJ6WOuDHLjkJqZhVSOI0iJ8e+7EZCTbYFkzBht8+H\nCJUI41mybuBG494wA3vk1NGM60MhTUkYJ8+f6F+ZQxJnF2aU+/jx89JxnFt9qt09\nw5/bDIMIuUUBqcLTnm+pNSYqwtNQxJmOxv6etB+KUIBLYBL8y6VDek36o/Je0Dqt\nXnzhkuTbjkJySThiE7RQuc6D4QqUTLF162zgrBQkx1j3c/u0IkFPtfrQBLNs0o3J\nH4NrxrorJVIXO4BzydWRrc/GNNx6FMJS+WgYMpsnVjGYwYJbsgAvXM8wgXu5gzXP\nD1IH5g1Dz3tGkZNYt5Ro\n=eKl0\n-----END PGP SIGNATURE-----\n"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9bccf545930f9d4b8211f11d5bd93eac27b75695",
          "sha": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
          "html_url": "https://github.com/bitcoin/bips/commit/9bccf545930f9d4b8211f11d5bd93eac27b75695"
        }
      ],
      "message": "Apply suggestions from code review\n\nCo-authored-by: Mark \"Murch\" Erhardt <murch@murch.one>",
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2025-04-12T22:03:29Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-12T22:03:29Z"
      },
      "sha": "d246a6124916877be0988708b90402763a6aa0f0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGViNTZlYzVlNjBkZmU4MTU5N2FmZGFjZWNhYzQwMzI3ZTA4YzYyNDg",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/eb56ec5e60dfe81597afdacecac40327e08c6248",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/eb56ec5e60dfe81597afdacecac40327e08c6248",
      "tree": {
        "sha": "e76d01e0f294df6cf0a215467cf62ab78bf44dd2",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/e76d01e0f294df6cf0a215467cf62ab78bf44dd2"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e76d01e0f294df6cf0a215467cf62ab78bf44dd2\nparent d246a6124916877be0988708b90402763a6aa0f0\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744497851 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744497851 +0200\n\nDo not capitalize 'Script' when referring to individual scripts\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmf67LsACgkQdAYP+Bsz\n5PhusQv/asQe/cpia+7Y+xDY6QCn2TYaP/QvAMbSBRu//GRN43gd0Ukbc+kiXG4Q\nVZfpLj6rqfKQfSVg8qJBQpPAkU+ZQJ3FZC1LsUHLrjqKxwKkEcJieYezhmhnc7p5\nnhj9mUsr5mjiqGMGGmv11SifGrtEVHp9K3NunLUTOgxp4vtQyF0hJ12vsQ/cdDAx\nUqZGNaD0y4D8DJyodTtlh7xJ5768p6O6eszOnC5zUwcnhy4TILFFQ5AXpRHcN2kO\nPbLDGw/Fwkgzdg94QmhnrfvVb4u3W/FCf0n1DH/ltIV5+ofU35WIERjodZ0GsElJ\nxLUNpK4ccUgg9369zHk/1jGqSkv6JCV1kxa635MvQtP8fAStEoUVaRIp11RXEn1+\nuFeMxoEnVCAjPnmc//9B+1maqd0rwm1avVfgCFGGrdyrZOht1D9tMrs+tjtjJG4b\n2fRx00d1WufTQ7QUTQnBXbkQIcmPaXFIw1vHXZElEeOSJETMUIcr/mMgVa7kSskv\nq74STT+n\n=eGFj\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/d246a6124916877be0988708b90402763a6aa0f0",
          "sha": "d246a6124916877be0988708b90402763a6aa0f0",
          "html_url": "https://github.com/bitcoin/bips/commit/d246a6124916877be0988708b90402763a6aa0f0"
        }
      ],
      "message": "Do not capitalize 'Script' when referring to individual scripts",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-12T22:44:11Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-12T22:44:11Z"
      },
      "sha": "eb56ec5e60dfe81597afdacecac40327e08c6248"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDgwOGZhNDRhNmViZjc0OTNlNjBmNDBlNjQyYjM2N2NmMmFkYThmZTc",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/808fa44a6ebf7493e60f40e642b367cf2ada8fe7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/808fa44a6ebf7493e60f40e642b367cf2ada8fe7",
      "tree": {
        "sha": "7afc4b02a89f75787df3bf474350e9f0350df651",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/7afc4b02a89f75787df3bf474350e9f0350df651"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 7afc4b02a89f75787df3bf474350e9f0350df651\nparent eb56ec5e60dfe81597afdacecac40327e08c6248\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744498217 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744498217 +0200\n\nTypo\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmf67ikACgkQdAYP+Bsz\n5Ph+5gwAtltzKYkOntZiMKwAnEdW/XBxaCXT58RiJTsQHrytuyuwAKNhXOvlzDpm\nVUxt2CdyvZ7EG8uXElzKH/H5b9XgRlBVqUgvrGprgjOJ4Y+SiTk/dlvmTqM1SD1i\n8Wq5U1x871+OxEY/6J6JmXJOkdwBAfpGWKiijD6kN3q7sdq2/WqW0zhOdkGTZXNY\nk/ZAQEGoN+Q72VXT3yX731q7KmSvUKvqXCQLub4Be31aYytNP7qdJIYmNMqrSlie\n4RK5zldv6ZBwTisViPiZYXXoGoW5aT0Ble/PPCHRM+s2SHO6dRtYXcv8Im6b7DPK\n9UlQs12eMdOP0lBuDN7XJ4HRhtr7pSK7iA6qwZb2EsztPPZIIXmcaBapC/rjCjBq\nVPHg8JhIEZqVJU1KJ0tk9TDl+t7k4Nqngdq+vnGJ9a7KRMzWlhMTeD6Ma9n/l4Me\nNfwQIy9mGmuaICbP59ANv1GER4aG8RhghRGqMliSq6zzeAMHuBhRITaqQb6Obcdr\nU7EBxT0x\n=5+/4\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/eb56ec5e60dfe81597afdacecac40327e08c6248",
          "sha": "eb56ec5e60dfe81597afdacecac40327e08c6248",
          "html_url": "https://github.com/bitcoin/bips/commit/eb56ec5e60dfe81597afdacecac40327e08c6248"
        }
      ],
      "message": "Typo",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-12T22:50:17Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-12T22:50:17Z"
      },
      "sha": "808fa44a6ebf7493e60f40e642b367cf2ada8fe7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDFlMTI3OTUyMDUzM2YzNGQzYWRjYjIwYmY4YTFiNjI0YTAzZDNlOWE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/1e1279520533f34d3adcb20bf8a1b624a03d3e9a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/1e1279520533f34d3adcb20bf8a1b624a03d3e9a",
      "tree": {
        "sha": "b3559abb9e016161a591cbb342eca1a6649ac3f3",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/b3559abb9e016161a591cbb342eca1a6649ac3f3"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b3559abb9e016161a591cbb342eca1a6649ac3f3\nparent 808fa44a6ebf7493e60f40e642b367cf2ada8fe7\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744498554 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744498554 +0200\n\nRephrase paragraph in abstract describing the output restriction\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmf673oACgkQdAYP+Bsz\n5PgNoQv+LMDOPG1GE7aAVsPBrMkO+M59DleLJ/S6NmeLZrinD8Srmhiq8MYGiioL\nkjYvGIcP62fZnIu/6GzDZom1AeInwxpK8+M+LJ6X4k/GlRRqlwja7ES5pDhVju6f\nt4/Z8Gug/3sHj5NH+52z484S/WHI3CYOIY7FVd2QQ/7szYVrFrdg5UR7H+KOotU1\ny0ANCnH5srw/TF/TkjyVP2pEXqt7yiSKmAr0p1QghyDuZJ3HVZ6gwf+VtVkb+g8m\nFJqAvXY7Q5rPJ5YAtegeO86zocSyvXRJKmREICNkoQPqgZvifshFy4p3YooLis92\nOAMXzCaUe86QKhUMK0CY8SkRQ2pPY3uI4A6b6jU4p7KC0geDLch+eLJCOrrdf7BX\nI4szbfGlpfqb16LGXR721cW/iESA3kRXcUj/wOXlNP9/SDXjUA5Fxe4CUmSwVlxG\n9UBN0mfjxN5fVM/sN+leIF8w/CFO0zaQVi1VbtY8UJnlsMEy55vKD2cfyR1BkdK1\n9+shXRJX\n=jx1s\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/808fa44a6ebf7493e60f40e642b367cf2ada8fe7",
          "sha": "808fa44a6ebf7493e60f40e642b367cf2ada8fe7",
          "html_url": "https://github.com/bitcoin/bips/commit/808fa44a6ebf7493e60f40e642b367cf2ada8fe7"
        }
      ],
      "message": "Rephrase paragraph in abstract describing the output restriction",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-12T22:55:54Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-12T22:55:54Z"
      },
      "sha": "1e1279520533f34d3adcb20bf8a1b624a03d3e9a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDI2NTViOGI4OGYxNWFjM2VjZmFhZDkxZjJjMmMxYTdiZTM0NTRmYzM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "tree": {
        "sha": "de9caac6f80f200d4c89685c38e5572d23dc468b",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/de9caac6f80f200d4c89685c38e5572d23dc468b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree de9caac6f80f200d4c89685c38e5572d23dc468b\nparent 1e1279520533f34d3adcb20bf8a1b624a03d3e9a\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744549939 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1744549939 +0200\n\nDefine 'current input' at first use; clarify order of arguments on the stack\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmf7uDMACgkQdAYP+Bsz\n5PiRKwv9HjEeoIY/NThJaXgdtLlk3YB+CX+aFBH8GddcVO6PU6a+ZgI0S8/Dh2Pa\nlQvIzYSGnJ/Exy63xcbl+TV0yyNZgAjr1TF0n0GIUYrdvRbR6QZ7b5hWm1oaMapq\nemovv8Odh0McBeK+xBq+JFam6Jtrnfwt8B3zh9hI89WMH5ny289Hmu/CcP+4OMyC\nA0Os7WrT6I1YYuauZqzM4SlOacANlHv57yw69jEaJFFUx6bHuzJVrvo/7+7XDR0v\njOa8FG6dbFlnKyo/m0ZHqGx0d4mrzgALe/2d6Kfzi1Op+aTktjCwTsYL9EwA/sSW\ngXg/DEP7wMFBpXpyqyMBiJWcMJlZazNxuI71ALA8bXWOHOKD6/31Q7isuY7vfVH3\n+ryrvzSXAPVkVIS6HFYow+3kCCwEkkPT7aJ6KBVOAzeo/0yY2rqirJIFj+7oi7cM\nE04h9jxwc+eACLcjfAfJAQehKYhGaKcoGCkeuhBxCXTQk4LgfsDmjed+l4bZlm7w\nyVZj70WW\n=P8oD\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/1e1279520533f34d3adcb20bf8a1b624a03d3e9a",
          "sha": "1e1279520533f34d3adcb20bf8a1b624a03d3e9a",
          "html_url": "https://github.com/bitcoin/bips/commit/1e1279520533f34d3adcb20bf8a1b624a03d3e9a"
        }
      ],
      "message": "Define 'current input' at first use; clarify order of arguments on the stack",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-13T13:12:19Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-04-13T13:12:19Z"
      },
      "sha": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3"
    },
    {
      "event": "reviewed",
      "id": 2762265924,
      "node_id": "PRR_kwDOAN28mc6kpNVE",
      "url": null,
      "actor": null,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Addressed most of the comments from @murchandamus (sorry for the delay, I didn't realize the review comments were left as 'Pending').",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2762265924",
      "submitted_at": "2025-04-24T14:23:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2813234938,
      "node_id": "PRR_kwDOAN28mc6nro76",
      "url": null,
      "actor": null,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2813234938",
      "submitted_at": "2025-05-03T13:34:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2823275624,
      "node_id": "PRR_kwDOAN28mc6oR8Ro",
      "url": null,
      "actor": null,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Not a full review, more of a quick check of what has happened here lately and a skim of the changes based on my prior review.\r\n\r\nI see a few todos in the document, could you describe in a couple sentences how you see the status of this document?",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2823275624",
      "submitted_at": "2025-05-07T22:17:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "commented",
      "id": 2863664558,
      "node_id": "IC_kwDOAN28mc6qsA2u",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2863664558",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-08T16:38:42Z",
      "updated_at": "2025-05-08T16:38:42Z",
      "author_association": "CONTRIBUTOR",
      "body": "Let’s refer to this proposal as **BIP 443**. Could you please rename the file, add an entry to the table, and update the number and created date in the preamble?",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2863664558",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "renamed",
      "id": 17577288669,
      "node_id": "RTE_lADOAN28mc6uRj3YzwAAAAQXsCPd",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/17577288669",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-05-08T16:39:29Z",
      "rename": {
        "from": "BIP draft: OP_CHECKCONTRACTVERIFY",
        "to": "BIP 443: OP_CHECKCONTRACTVERIFY"
      }
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1998687605",
      "pull_request_review_id": 2690410810,
      "id": 1998687605,
      "node_id": "PRRC_kwDOAN28mc53IY11",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    return success()  # undefined flags are OP_SUCCESS\n+\n+  if index == -1:\n+    index = this_input_index\n+\n+  if flags == CCV_FLAG_CHECK_INPUT:\n+    if index < 0 or index >= n_inputs:\n+      return fail()  # input index out of bounds\n+\n+    target_script = inputs[index].scriptPubKey\n+  else:\n+    if index < 0 or index >= n_outputs:\n+      return fail()  # output index out of bounds\n+\n+    target_script = outputs[index].scriptPubKey\n+\n+  if taptree == <-1>:\n+    taptree = this_input_taptree\n+\n+  if pk == <0>:\n+    naked_key = BIP341_NUMS_KEY\n+  elif pk == <-1>:\n+    naked_key = this_input_internal_key\n+  elif len(pk) == 32:\n+    naked_key = pk\n+  else:\n+    return fail()\n+\n+  # Verify the target contract data and program\n+  _, internal_key = tweak_embed_data(naked_key, data)\n+\n+  if len(taptree) != 0:\n+    if len(taptree) != 32:\n+      return fail()\n+\n+    _, final_key = taproot_tweak_pubkey(internal_key, taptree)\n+  else:\n+    final_key = internal_key\n+\n+  if target_script != P2TR(final_key):\n+    return fail()\n+\n+  # Amount checks\n+\n+  if flags == 0:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 252,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n  if flags == CCV_FLAG_CHECK_OUTPUT:\r\n```",
      "created_at": "2025-03-17T13:02:45Z",
      "updated_at": "2025-03-17T13:02:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r1998687605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1998687605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2000644722",
      "pull_request_review_id": 2693778798,
      "id": 2000644722,
      "node_id": "PRRC_kwDOAN28mc53P2py",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 122,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "jirijakes",
        "id": 1381856,
        "node_id": "MDQ6VXNlcjEzODE4NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1381856?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jirijakes",
        "html_url": "https://github.com/jirijakes",
        "followers_url": "https://api.github.com/users/jirijakes/followers",
        "following_url": "https://api.github.com/users/jirijakes/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jirijakes/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jirijakes/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jirijakes/subscriptions",
        "organizations_url": "https://api.github.com/users/jirijakes/orgs",
        "repos_url": "https://api.github.com/users/jirijakes/repos",
        "events_url": "https://api.github.com/users/jirijakes/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jirijakes/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This [renders](https://github.com/Merkleize/bips/blob/ccv/bip-ccv.mediawiki#specification) as a code block without wrapping ⇒ have to scroll to the right to read it. Plain text (or blockquote, if you want to emphasize) might be better.",
      "created_at": "2025-03-18T10:03:16Z",
      "updated_at": "2025-03-18T10:03:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2000644722",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2000644722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001438768",
      "pull_request_review_id": 2695265611,
      "id": 2001438768,
      "node_id": "PRRC_kwDOAN28mc53S4gw",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 122,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2000644722,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The phrasing \"input/output\" followed by \"is a P2TR output\" is also confusing. Maybe just have a separate sentence to explain the input handling. And in particular whether inputs can refer to other inputs.",
      "created_at": "2025-03-18T16:17:00Z",
      "updated_at": "2025-03-18T16:19:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001438768",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001438768"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001452568",
      "pull_request_review_id": 2695286980,
      "id": 2001452568,
      "node_id": "PRRC_kwDOAN28mc53S74Y",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 146,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I assume you mean that first flags are checked. If they're different the transaction is valid. And only after that the other params are checked? In other words, params can be changed / added / removed in later soft forks by introducing a new flag?",
      "created_at": "2025-03-18T16:21:45Z",
      "updated_at": "2025-03-18T16:21:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001452568",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001452568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001583011",
      "pull_request_review_id": 2695539462,
      "id": 2001583011,
      "node_id": "PRRC_kwDOAN28mc53Tbuj",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 95,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It would be good to elaborate with an example.",
      "created_at": "2025-03-18T17:25:55Z",
      "updated_at": "2025-03-18T17:25:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001583011",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001583011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001589006",
      "pull_request_review_id": 2695547018,
      "id": 2001589006,
      "node_id": "PRRC_kwDOAN28mc53TdMO",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.",
      "path": "bip-ccv.mediawiki",
      "position": 33,
      "original_position": 33,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Having a vault example with OP_CCV would be useful, doesn't have to be perfectly identical to `OP_VAULT`.",
      "created_at": "2025-03-18T17:28:16Z",
      "updated_at": "2025-03-18T17:28:16Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001589006",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001589006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001590488",
      "pull_request_review_id": 2695549014,
      "id": 2001590488,
      "node_id": "PRRC_kwDOAN28mc53TdjY",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 34,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ditto: having an example that (roughly) replicates `OP_CTV` would be useful",
      "created_at": "2025-03-18T17:28:52Z",
      "updated_at": "2025-03-18T17:28:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001590488",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001590488"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001595938",
      "pull_request_review_id": 2695556405,
      "id": 2001595938,
      "node_id": "PRRC_kwDOAN28mc53Te4i",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.",
      "path": "bip-ccv.mediawiki",
      "position": 37,
      "original_position": 37,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Out of scope for a BIP, but maybe someone who works on BitVM can demonstrate the equivalent with `OP_CCV`? Presumably it doesn't completely replace it, but makes certain aspects more compact. Do they need additional op codes? Etc.",
      "created_at": "2025-03-18T17:30:53Z",
      "updated_at": "2025-03-18T17:30:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001595938",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001595938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001605770",
      "pull_request_review_id": 2695572302,
      "id": 2001605770,
      "node_id": "PRRC_kwDOAN28mc53ThSK",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm confused by what you mean with \"data\", as opposed to a \"program\". Does this \"party\" have to know the pre-image or just the hash? And why is that helpful. Hopefully the future examples can illustrate this.\r\n",
      "created_at": "2025-03-18T17:34:41Z",
      "updated_at": "2025-03-18T17:35:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001605770",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001605770"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001612619",
      "pull_request_review_id": 2695587204,
      "id": 2001612619,
      "node_id": "PRRC_kwDOAN28mc53Ti9L",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    return success()  # undefined flags are OP_SUCCESS\n+\n+  if index == -1:\n+    index = this_input_index\n+\n+  if flags == CCV_FLAG_CHECK_INPUT:\n+    if index < 0 or index >= n_inputs:\n+      return fail()  # input index out of bounds\n+\n+    target_script = inputs[index].scriptPubKey\n+  else:\n+    if index < 0 or index >= n_outputs:\n+      return fail()  # output index out of bounds\n+\n+    target_script = outputs[index].scriptPubKey\n+\n+  if taptree == <-1>:\n+    taptree = this_input_taptree\n+\n+  if pk == <0>:\n+    naked_key = BIP341_NUMS_KEY\n+  elif pk == <-1>:\n+    naked_key = this_input_internal_key\n+  elif len(pk) == 32:\n+    naked_key = pk\n+  else:\n+    return fail()\n+\n+  # Verify the target contract data and program\n+  _, internal_key = tweak_embed_data(naked_key, data)\n+\n+  if len(taptree) != 0:\n+    if len(taptree) != 32:\n+      return fail()\n+\n+    _, final_key = taproot_tweak_pubkey(internal_key, taptree)\n+  else:\n+    final_key = internal_key\n+\n+  if target_script != P2TR(final_key):\n+    return fail()\n+\n+  # Amount checks\n+\n+  if flags == 0:\n+    # default amount semantic\n+    if output_checked_deduct[index]:\n+      return fail()\n+\n+    output_min_amount[index] += residual_input_amount\n+    residual_input_amount = 0\n+\n+    if outputs[index].amount < output_min_amount[index]:\n+      return fail()\n+\n+    output_checked_default[index] = True\n+  elif flags == CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    # 'deduct' amount semantic\n+    if residual_input_amount < outputs[index].amount:\n+      return fail()\n+\n+    if output_checked_default[index] or output_checked_deduct[index]:\n+      return fail()\n+\n+    residual_input_amount = residual_input_amount - outputs[index].amount\n+    output_checked_deduct[index] = True\n+\n+  stack.pop(5)  # drop all 5 stack elements\n+</source>\n+\n+==== sigops budget ====\n+\n+TODO\n+\n+== Policy changes ==\n+\n+TODO\n+\n+== Implementation ==\n+\n+A reference implementation is provided here:\n+\n+TODO\n+\n+== Examples ==\n+\n+This section documents some common Script fragments that use <code>OP_CHECKCONTRACTVERIFY</code> for various common choices of the parameters. Depending on the use case, some of the parameters might be passed via the witness stack.\n+In these examples, <code><></code> (empty buffer) and <code>0</code> both refer to an empty stack element.",
      "path": "bip-ccv.mediawiki",
      "position": 295,
      "original_position": 295,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Can you frame these examples in the context of an actual application?",
      "created_at": "2025-03-18T17:38:23Z",
      "updated_at": "2025-03-18T17:38:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001612619",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001612619"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 295,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001617429",
      "pull_request_review_id": 2695595829,
      "id": 2001617429,
      "node_id": "PRRC_kwDOAN28mc53TkIV",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001605770,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The implementation uses the term \"double tweak\". Perhaps that's a helpful term to explain the concept better? \r\n\r\nAnd IIUC maybe use the term \"single tweak\" instead of \"naked\".",
      "created_at": "2025-03-18T17:40:42Z",
      "updated_at": "2025-03-18T17:42:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001617429",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001617429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001660190",
      "pull_request_review_id": 2695686169,
      "id": 2001660190,
      "node_id": "PRRC_kwDOAN28mc53Tuke",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.",
      "path": "bip-ccv.mediawiki",
      "position": 33,
      "original_position": 33,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001589006,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Just saw this: https://github.com/Merkleize/bitcoin/blob/ccv-core/test/functional/feature_checkcontractverify_vaults.py",
      "created_at": "2025-03-18T17:58:31Z",
      "updated_at": "2025-03-18T18:00:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001660190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001660190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008830091",
      "pull_request_review_id": 2708111516,
      "id": 2008830091,
      "node_id": "PRRC_kwDOAN28mc53vFCL",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    return success()  # undefined flags are OP_SUCCESS\n+\n+  if index == -1:\n+    index = this_input_index\n+\n+  if flags == CCV_FLAG_CHECK_INPUT:\n+    if index < 0 or index >= n_inputs:\n+      return fail()  # input index out of bounds\n+\n+    target_script = inputs[index].scriptPubKey\n+  else:\n+    if index < 0 or index >= n_outputs:\n+      return fail()  # output index out of bounds\n+\n+    target_script = outputs[index].scriptPubKey\n+\n+  if taptree == <-1>:\n+    taptree = this_input_taptree\n+\n+  if pk == <0>:\n+    naked_key = BIP341_NUMS_KEY\n+  elif pk == <-1>:\n+    naked_key = this_input_internal_key\n+  elif len(pk) == 32:\n+    naked_key = pk\n+  else:\n+    return fail()\n+\n+  # Verify the target contract data and program\n+  _, internal_key = tweak_embed_data(naked_key, data)\n+\n+  if len(taptree) != 0:\n+    if len(taptree) != 32:\n+      return fail()\n+\n+    _, final_key = taproot_tweak_pubkey(internal_key, taptree)\n+  else:\n+    final_key = internal_key\n+\n+  if target_script != P2TR(final_key):\n+    return fail()\n+\n+  # Amount checks\n+\n+  if flags == 0:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 252,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 1998687605,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in b2199950, thanks!",
      "created_at": "2025-03-22T18:09:17Z",
      "updated_at": "2025-03-22T18:09:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2008830091",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008830091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008832251",
      "pull_request_review_id": 2708113809,
      "id": 2008832251,
      "node_id": "PRRC_kwDOAN28mc53vFj7",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 122,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2000644722,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "b2199950\r\nI added the blockquote, and rephrased a bit - saying P2TR UTXO instead of the ambiguous 'output'. Does this make it clearer?",
      "created_at": "2025-03-22T18:22:19Z",
      "updated_at": "2025-03-22T18:22:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2008832251",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008832251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008832670",
      "pull_request_review_id": 2708114205,
      "id": 2008832670,
      "node_id": "PRRC_kwDOAN28mc53vFqe",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 146,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001452568,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, undefined flags (which is more an extension of the opcode) are left for possible future extensions, while that seems dangerous/footgun-prone for the other parameters (which could be passed via the witness)\r\nIn b2199950 I tried to make it more explicit by explicitly listing all the parameters.",
      "created_at": "2025-03-22T18:24:53Z",
      "updated_at": "2025-03-22T18:24:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2008832670",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008832670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008833828",
      "pull_request_review_id": 2708115276,
      "id": 2008833828,
      "node_id": "PRRC_kwDOAN28mc53vF8k",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001605770,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I'm confused by what you mean with \"data\", as opposed to a \"program\". Does this \"party\" have to know the pre-image or just the hash? And why is that helpful. Hopefully the future examples can illustrate this.\r\n\r\nIn b2199950 I added an additional introductory sentence in the paragraph, and also a footnote to explain how this could be used (which is anyway identical to taproot's keypath vs script spending, anyway; the point I'm trying to make is that this feature is not lost when using Scripts with CCV, despite _tampering_ with the internal key).\r\n\r\n\r\n> And IIUC maybe use the term \"single tweak\" instead of \"naked\".\r\n\r\nWhat I call the 'naked key' is the key before any tweak. So if you have no embedded data:\r\n```\r\n      naked_key ==(taptweak)==> taproot output key         (where naked_key == internal key)\r\n```\r\nInstead, if you have embedded data:\r\n```\r\n      naked_key ==(data tweak)==> internal_key ==(taptweak)==> taproot output key\r\n```\r\n",
      "created_at": "2025-03-22T18:32:25Z",
      "updated_at": "2025-03-22T18:32:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2008833828",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008833828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010815193",
      "pull_request_review_id": 2711501789,
      "id": 2010815193,
      "node_id": "PRRC_kwDOAN28mc532prZ",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 137,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Most flags in Bitcoin Core are usigned integers, which seems easier to read. But I guess this is because the script interpreter uses (variable size) signed integers? On the bright side, it means you can expand the number of bit flags easily...\r\n\r\nWhen this flag is absent, I assume you don't check the input?",
      "created_at": "2025-03-24T19:36:39Z",
      "updated_at": "2025-03-24T19:51:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010815193",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010815193"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010818123",
      "pull_request_review_id": 2711501789,
      "id": 2010818123,
      "node_id": "PRRC_kwDOAN28mc532qZL",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 138,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When this flag is absent, you don't check the output?\r\n\r\nAnd `CCV_FLAG_CHECK_INPUT` can be used in any combination with `CCV_FLAG_CHECK_INPUT`, including not checking either?",
      "created_at": "2025-03-24T19:39:07Z",
      "updated_at": "2025-03-24T19:51:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010818123",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010818123"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010828211",
      "pull_request_review_id": 2711501789,
      "id": 2010828211,
      "node_id": "PRRC_kwDOAN28mc532s2z",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.",
      "path": "bip-ccv.mediawiki",
      "position": 141,
      "original_position": 145,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Have you considered using flags for these special cases and then having fewer stack elements? That seems both more space efficient and probably makes scripts easier to read.",
      "created_at": "2025-03-24T19:47:47Z",
      "updated_at": "2025-03-24T19:51:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010828211",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010828211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 141,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010845676",
      "pull_request_review_id": 2711548786,
      "id": 2010845676,
      "node_id": "PRRC_kwDOAN28mc532xHs",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters is invalid, and makes the opcode immediately fail validation.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 211,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I assume you mean to check that no unknown flags are in use? This seems wrong though, because `CCV_FLAG_DEDUCT_OUTPUT_AMOUNT | CCV_FLAG_IGNORE_OUTPUT_AMOUNT > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT`\r\n\r\nProbably more clear to have something like `ALL_FLAGS = ... | CCV_FLAG_DEDUCT_OUTPUT_AMOUNT | CCV_FLAG_IGNORE_OUTPUT_AMOUNT | ...` and check `flags && !ALL_FLAGS == 0`",
      "created_at": "2025-03-24T19:59:31Z",
      "updated_at": "2025-03-24T19:59:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010845676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010845676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013047590",
      "pull_request_review_id": 2715387171,
      "id": 2013047590,
      "node_id": "PRRC_kwDOAN28mc53_Ksm",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 137,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010815193,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The flag can't be 'absent', as it's the value of the `flags` parameter. Note that it's not a bitmap: -1 means \"check input\", 0, 1 and 2 are the three defferent _amount_ behaviors for checking the output (default, deduct and ignore).\r\n\r\nPerhaps the confusion comes from calling it `flags` - let me know if you have suggestions for a better name.",
      "created_at": "2025-03-25T23:01:39Z",
      "updated_at": "2025-03-25T23:01:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013047590",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013047590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013048066",
      "pull_request_review_id": 2715387866,
      "id": 2013048066,
      "node_id": "PRRC_kwDOAN28mc53_K0C",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 138,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010818123,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As per [this comment](https://github.com/bitcoin/bips/pull/1793#discussion_r2013047590), the defined flags are all mutually exclusive.",
      "created_at": "2025-03-25T23:02:17Z",
      "updated_at": "2025-03-25T23:02:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013048066",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013048066"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013049325",
      "pull_request_review_id": 2715389809,
      "id": 2013049325,
      "node_id": "PRRC_kwDOAN28mc53_LHt",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters is invalid, and makes the opcode immediately fail validation.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 211,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010845676,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since flags are mutually exclusive and the defined values are -1, 0, 1, 2, this is just checking if you're out of the range (then, _SUCCESS_ as an upgrade hook to add future flags).",
      "created_at": "2025-03-25T23:04:17Z",
      "updated_at": "2025-03-25T23:04:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013049325",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013049325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013058681",
      "pull_request_review_id": 2715403904,
      "id": 2013058681,
      "node_id": "PRRC_kwDOAN28mc53_NZ5",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.",
      "path": "bip-ccv.mediawiki",
      "position": 141,
      "original_position": 145,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010828211,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "All the flags and the special parameters are encoded as 1-byte push opcodes, so I don't think you can really save much by aggregating them in the flags (e.g. using extra bits that are currently in the `OP_SUCCESS` behavior).\r\nMoreover, I think it would be very inconvenient (both in implementation and in Script readability) if the number of stack arguments is different for different use cases of CCV.",
      "created_at": "2025-03-25T23:15:53Z",
      "updated_at": "2025-03-25T23:15:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013058681",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013058681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 141,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013590479",
      "pull_request_review_id": 2716229480,
      "id": 2013590479,
      "node_id": "PRRC_kwDOAN28mc54BPPP",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 137,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010815193,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "At least to me flags imply a bitmap.\r\n\r\nSince they're all mututally exclusive, I would probably call it \"mode\".\r\n\r\nAnd to prevent confusion, maybe rename the last two: `CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT` and `CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT`\r\n\r\nTerminology aside, why not use a bitmap?\r\n\r\nA bitmap based scheme could do something like:\r\n\r\n```\r\nCCV_FLAG_INPUT = 0; // default behavior is to check output\r\nCCV_FLAG_IGNORE_AMOUNT = 1; // default is to preserve, can't be combined with CCV_FLAG_INPUT or CCV_FLAG_DEDUCT_AMOUNT\r\nCCV_FLAG_DEDUCT_AMOUNT = 2; // default is to preserve, can't be combined with CCV_FLAG_INPUT or CCV_FLAG_IGNORE_AMOUNT\r\nCCV_FLAG_CURRENT_INPUT_TAPTREE = 4; // Merkle root of the current input's tapscript tree. Omit taptree from witness)\r\nCCV_FLAG_CURRENT_INPUT_INTERNAL_KEY = 8; // taproot internal key of the current input. Omit pk from witness. Mutually exclusive with CCV_FLAG_NUMS_KEY\r\nCCV_FLAG_NUMS_KEY = 16; // use NUMS point. Mutually exclusive with CCV_FLAG_CURRENT_INPUT_INTERNAL_KEY.\r\n...\r\n```\r\n\r\nI tend to agree it's not pretty. Too many mutually exclusive flags, and often times you really need 3 modalities, e.g. NUMS, current input key or custom key.",
      "created_at": "2025-03-26T08:12:33Z",
      "updated_at": "2025-03-26T08:27:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013590479",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013590479"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013614622",
      "pull_request_review_id": 2716268694,
      "id": 2013614622,
      "node_id": "PRRC_kwDOAN28mc54BVIe",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters is invalid, and makes the opcode immediately fail validation.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 211,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010845676,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "See above comment, I think calling it \"mode\" would make this code clear:\r\n\r\n```\r\nif mode < CCV_FLAG_CHECK_INPUT or mode > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\r\n```",
      "created_at": "2025-03-26T08:29:34Z",
      "updated_at": "2025-03-26T08:29:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013614622",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013614622"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2019845012",
      "pull_request_review_id": 2727435015,
      "id": 2019845012,
      "node_id": "PRRC_kwDOAN28mc54ZGOU",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters is invalid, and makes the opcode immediately fail validation.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 211,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010845676,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Changed to `mode` instead of `flags` in 4ed71843e51742b6a60f445c272b73a1e90dc10f.",
      "created_at": "2025-03-29T16:48:40Z",
      "updated_at": "2025-03-29T16:48:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2019845012",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2019845012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2023698851",
      "pull_request_review_id": 2734079838,
      "id": 2023698851,
      "node_id": "PRRC_kwDOAN28mc54nzGj",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 16,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "d10971b0bc37a8710f89012bec681e986fa87799",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: Missing \"Abstract\" section.",
      "created_at": "2025-04-01T21:25:32Z",
      "updated_at": "2025-04-01T21:27:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2023698851",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2023698851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025189979",
      "pull_request_review_id": 2736897777,
      "id": 2025189979,
      "node_id": "PRRC_kwDOAN28mc54tfJb",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.",
      "path": "bip-ccv.mediawiki",
      "position": 33,
      "original_position": 33,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001589006,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah, I was a bit on the fence whether to put the code of the vault implementation in the BIP or in the bitcoin-core implementation, and ultimately I went for the latter, as functional tests are a lot more readable than dangling python scripts, or bare bitcoin Script fragments.\r\n\r\nIn general, I'm a bit concerned about focusing on the applications in the BIP, as that's extremely open-ended. I tried to focus on the _programming tool_ that CCV introduces. It will be mostly devs reading it, after all.\r\n\r\nI feel the CCV-only vault is in a sweet spot as it's probably the smallest interesting construction that uses all the three modes (all except the _IGNORE_AMOUNT_ one)\r\n\r\nAdvise on the approach is welcome, though - please let me know if you would like a different approach, or some things to be covered more.",
      "created_at": "2025-04-02T16:23:17Z",
      "updated_at": "2025-04-02T16:23:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2025189979",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025189979"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025246292",
      "pull_request_review_id": 2736992074,
      "id": 2025246292,
      "node_id": "PRRC_kwDOAN28mc54ts5U",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.",
      "path": "bip-ccv.mediawiki",
      "position": 33,
      "original_position": 33,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001589006,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I found it a very useful example. Perhaps it's still useful to have a brief overview in the BIP itself, e.g. with the state transitions and perhaps even the taptrees and witness at each state.",
      "created_at": "2025-04-02T17:00:38Z",
      "updated_at": "2025-04-02T17:01:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2025246292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025246292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025317314",
      "pull_request_review_id": 2737110055,
      "id": 2025317314,
      "node_id": "PRRC_kwDOAN28mc54t-PC",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 34,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001590488,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "CCV alone doesn't replicate CTV, as it misses the 'exact amounts'. It could do it with `OP_AMOUNT` (although, of course, CTV is extremely efficient when you just want to commit to all the outputs - plus it has txid stability, if that's needed).\r\n\r\nIn this paragraph, my intention is to just set the context and hint that 'additional output restrictions are generally useful' - not compare proposals.",
      "created_at": "2025-04-02T17:53:49Z",
      "updated_at": "2025-04-02T17:53:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2025317314",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025317314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025631726",
      "pull_request_review_id": 2737643185,
      "id": 2025631726,
      "node_id": "PRRC_kwDOAN28mc54vK_u",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 95,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001583011,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I didn't add an example (perhaps if I add a section explaining the vault construction, it could also serve for that purpose); but I elaborated slightly more on the fact that the amount is malleable without further checks in 9bccf545930f9d4b8211f11d5bd93eac27b75695.",
      "created_at": "2025-04-02T21:29:46Z",
      "updated_at": "2025-04-02T21:29:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2025631726",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025631726"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025634016",
      "pull_request_review_id": 2737646764,
      "id": 2025634016,
      "node_id": "PRRC_kwDOAN28mc54vLjg",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    return success()  # undefined flags are OP_SUCCESS\n+\n+  if index == -1:\n+    index = this_input_index\n+\n+  if flags == CCV_FLAG_CHECK_INPUT:\n+    if index < 0 or index >= n_inputs:\n+      return fail()  # input index out of bounds\n+\n+    target_script = inputs[index].scriptPubKey\n+  else:\n+    if index < 0 or index >= n_outputs:\n+      return fail()  # output index out of bounds\n+\n+    target_script = outputs[index].scriptPubKey\n+\n+  if taptree == <-1>:\n+    taptree = this_input_taptree\n+\n+  if pk == <0>:\n+    naked_key = BIP341_NUMS_KEY\n+  elif pk == <-1>:\n+    naked_key = this_input_internal_key\n+  elif len(pk) == 32:\n+    naked_key = pk\n+  else:\n+    return fail()\n+\n+  # Verify the target contract data and program\n+  _, internal_key = tweak_embed_data(naked_key, data)\n+\n+  if len(taptree) != 0:\n+    if len(taptree) != 32:\n+      return fail()\n+\n+    _, final_key = taproot_tweak_pubkey(internal_key, taptree)\n+  else:\n+    final_key = internal_key\n+\n+  if target_script != P2TR(final_key):\n+    return fail()\n+\n+  # Amount checks\n+\n+  if flags == 0:\n+    # default amount semantic\n+    if output_checked_deduct[index]:\n+      return fail()\n+\n+    output_min_amount[index] += residual_input_amount\n+    residual_input_amount = 0\n+\n+    if outputs[index].amount < output_min_amount[index]:\n+      return fail()\n+\n+    output_checked_default[index] = True\n+  elif flags == CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    # 'deduct' amount semantic\n+    if residual_input_amount < outputs[index].amount:\n+      return fail()\n+\n+    if output_checked_default[index] or output_checked_deduct[index]:\n+      return fail()\n+\n+    residual_input_amount = residual_input_amount - outputs[index].amount\n+    output_checked_deduct[index] = True\n+\n+  stack.pop(5)  # drop all 5 stack elements\n+</source>\n+\n+==== sigops budget ====\n+\n+TODO\n+\n+== Policy changes ==\n+\n+TODO\n+\n+== Implementation ==\n+\n+A reference implementation is provided here:\n+\n+TODO\n+\n+== Examples ==\n+\n+This section documents some common Script fragments that use <code>OP_CHECKCONTRACTVERIFY</code> for various common choices of the parameters. Depending on the use case, some of the parameters might be passed via the witness stack.\n+In these examples, <code><></code> (empty buffer) and <code>0</code> both refer to an empty stack element.",
      "path": "bip-ccv.mediawiki",
      "position": 295,
      "original_position": 295,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001612619,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 9bccf545930f9d4b8211f11d5bd93eac27b75695 I added one- or two-sentence explainers after each example (and deleted the example with just the _deduct_ mode, as the one right after already has a _deduct_ check followed by a _default_ one - which is the correct way of using it anyway).",
      "created_at": "2025-04-02T21:32:11Z",
      "updated_at": "2025-04-02T21:32:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2025634016",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025634016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 295,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025635431",
      "pull_request_review_id": 2737648981,
      "id": 2025635431,
      "node_id": "PRRC_kwDOAN28mc54vL5n",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 16,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "d10971b0bc37a8710f89012bec681e986fa87799",
      "in_reply_to_id": 2023698851,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "9bccf545930f9d4b8211f11d5bd93eac27b75695: I renamed the `Introduction` to `Abstract`.",
      "created_at": "2025-04-02T21:33:42Z",
      "updated_at": "2025-04-02T21:33:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2025635431",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2025635431"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029416206",
      "pull_request_review_id": 2744075120,
      "id": 2029416206,
      "node_id": "PRRC_kwDOAN28mc549m8O",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 18,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"proposes opcode that adds support for opcode\" sounds weird. How about:\r\n\r\n```suggestion\r\nThis BIP proposes to add consensus support for a new tapscript opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\r\n```",
      "created_at": "2025-04-04T20:46:31Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029416206",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029416206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029424502",
      "pull_request_review_id": 2744075120,
      "id": 2029424502,
      "node_id": "PRRC_kwDOAN28mc549o92",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 20,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Given that the programming language is also called \"Script\", I find the capitalization here confusing. Also, did you mean to be more specific? Do you mean an input script, output script, leaf script, etc.?\r\n\r\n```suggestion\r\nThis opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the program (internal public key and taptree) and the data of one or more outputs.\r\n```\r\n\r\nAlso, in the final sentence, what do you mean with \"the program\"? How would an opcode that appears in a leaf script be able to affect the \"internal public key\"? The content of those parentheses throws up more questions than it answers, perhaps this could be clarified by defining what \"the program\" refers to in this context, or by using a different term for \"the program\" and dropping the parentheses.",
      "created_at": "2025-04-04T20:55:25Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029424502",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029424502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029428269",
      "pull_request_review_id": 2744075120,
      "id": 2029428269,
      "node_id": "PRRC_kwDOAN28mc549p4t",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 22,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nIn conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via a single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (scripts in the taptree).\r\n```",
      "created_at": "2025-04-04T20:59:31Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029428269",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029428269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029429369",
      "pull_request_review_id": 2744075120,
      "id": 2029429369,
      "node_id": "PRRC_kwDOAN28mc549qJ5",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 22,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029428269,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It would be easier to provide detailed suggestions if the lines were broken to a shorter length, e.g., 120 characters, instead of whole paragraphs in one line.",
      "created_at": "2025-04-04T21:00:52Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029429369",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029429369"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029431477",
      "pull_request_review_id": 2744075120,
      "id": 2029431477,
      "node_id": "PRRC_kwDOAN28mc549qq1",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 34,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain a transaction to a ''template'' with a fixed set of outputs.\r\n```\r\n\r\n\"The transaction\" begs the question \"which transaction\", but I think you simply mean \"a transaction\".",
      "created_at": "2025-04-04T21:03:26Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029431477",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029431477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029433007",
      "pull_request_review_id": 2744075120,
      "id": 2029433007,
      "node_id": "PRRC_kwDOAN28mc549rCv",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 43,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "re: Capitalized \"Script\" see above.",
      "created_at": "2025-04-04T21:05:23Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029433007",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029433007"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 43,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029434023",
      "pull_request_review_id": 2744075120,
      "id": 2029434023,
      "node_id": "PRRC_kwDOAN28mc549rSn",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 45,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It seems to me that this is the definition for \"program\" that I was missing above. I would suggest either moving the definition to the first use, or sidestepping the use of the term above.",
      "created_at": "2025-04-04T21:06:41Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029434023",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029434023"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029436443",
      "pull_request_review_id": 2744075120,
      "id": 2029436443,
      "node_id": "PRRC_kwDOAN28mc549r4b",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 51,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data’s hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\r\n```",
      "created_at": "2025-04-04T21:09:26Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029436443",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029436443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029437240",
      "pull_request_review_id": 2744075120,
      "id": 2029437240,
      "node_id": "PRRC_kwDOAN28mc549sE4",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 52,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Is it possible that \"Script\" always refers to a leaf script?\r\n\r\n```suggestion\r\n* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\r\n```",
      "created_at": "2025-04-04T21:10:22Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029437240",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029437240"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029439166",
      "pull_request_review_id": 2744075120,
      "id": 2029439166,
      "node_id": "PRRC_kwDOAN28mc549si-",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 58,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What is \"the current UTXO\"? Is this referring to an input that spends an OP_CHECKCONTRACTVERIFY-encumbered TXO?",
      "created_at": "2025-04-04T21:12:54Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029439166",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029439166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029441820",
      "pull_request_review_id": 2744075120,
      "id": 2029441820,
      "node_id": "PRRC_kwDOAN28mc549tMc",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:",
      "path": "bip-ccv.mediawiki",
      "position": 60,
      "original_position": 60,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Where does the opcode that is being checked stand? Is it in the output itself, or are we talking about a previous encumbrance?",
      "created_at": "2025-04-04T21:13:54Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029441820",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029441820"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 60,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029444828",
      "pull_request_review_id": 2744075120,
      "id": 2029444828,
      "node_id": "PRRC_kwDOAN28mc549t7c",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);",
      "path": "bip-ccv.mediawiki",
      "position": 61,
      "original_position": 61,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Does current input refer to the input at the same index as this output or what makes it \"current\"? What happens when there are multiple inputs spending TXOs that were encumbered with `OP_CHECKCONTRACTVERIFY`?\r\n\r\n```suggestion\r\n* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\r\n```",
      "created_at": "2025-04-04T21:14:54Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029444828",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029444828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 61,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029447387",
      "pull_request_review_id": 2744075120,
      "id": 2029447387,
      "node_id": "PRRC_kwDOAN28mc549ujb",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 65,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This seems to assign a strange sense of agency to the input. Do I understand that you mean something like:\r\n\r\n```suggestion\r\nThe ''default'' logic covers the common case where a UTXO’s full amount is required to be sent to a specific output.\r\n```",
      "created_at": "2025-04-04T21:17:15Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029447387",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029447387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029448116",
      "pull_request_review_id": 2744075120,
      "id": 2029448116,
      "node_id": "PRRC_kwDOAN28mc549uu0",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.",
      "path": "bip-ccv.mediawiki",
      "position": 67,
      "original_position": 67,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If there are multiple UTXOs, what happens with the change? If there is only one UTXO, how do you spend the entire amount without bringing more funds to pay for fees?",
      "created_at": "2025-04-04T21:18:05Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029448116",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029448116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029454813",
      "pull_request_review_id": 2744075120,
      "id": 2029454813,
      "node_id": "PRRC_kwDOAN28mc549wXd",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.",
      "path": "bip-ccv.mediawiki",
      "position": 73,
      "original_position": 73,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I must have failed to pick up on some part of the logic above, but how are contracts tied to specific outputs? What happens if you have two UTXOs tied to the same contract that requires an equal split of the funds between A and B? Let’s say 50% is deducted to A and then the rest is defaulted to B. Would you need two outputs to A and one to B to achieve this?",
      "created_at": "2025-04-04T21:26:14Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029454813",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029454813"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": 71,
      "original_start_line": 71,
      "start_side": "RIGHT",
      "line": 73,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029455419",
      "pull_request_review_id": 2744075120,
      "id": 2029455419,
      "node_id": "PRRC_kwDOAN28mc549wg7",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 97,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nNote that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\r\n```",
      "created_at": "2025-04-04T21:26:57Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029455419",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029455419"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029456605",
      "pull_request_review_id": 2744075120,
      "id": 2029456605,
      "node_id": "PRRC_kwDOAN28mc549wzd",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.",
      "path": "bip-ccv.mediawiki",
      "position": 101,
      "original_position": 101,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Note that [BIP 345: OP_VAULT](https://github.com/bitcoin/bips/blob/3ccc59dbdbca13fa5cc4ebeba9180946fa122003/bip-0345.mediawiki#L225) also proposes to use OP_SUCCESS187.",
      "created_at": "2025-04-04T21:28:30Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029456605",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029456605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029461164",
      "pull_request_review_id": 2744075120,
      "id": 2029461164,
      "node_id": "PRRC_kwDOAN28mc549x6s",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<mode>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 112,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "AFAIA, the content of the [stack](https://en.bitcoin.it/wiki/Script#Stack) is usually written in one line bottom to top:\r\n\r\n```suggestion\r\n<source>\r\n<data> <index> <pk> <taptree> <mode> \r\n</source>\r\n```",
      "created_at": "2025-04-04T21:32:22Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029461164",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029461164"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 112,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029462887",
      "pull_request_review_id": 2744075120,
      "id": 2029462887,
      "node_id": "PRRC_kwDOAN28mc549yVn",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<mode>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 134,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"Current input\" was used above without an introduction of the term. Please introduce the term on first use.",
      "created_at": "2025-04-04T21:34:43Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029462887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029462887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029464000",
      "pull_request_review_id": 2744075120,
      "id": 2029464000,
      "node_id": "PRRC_kwDOAN28mc549ynA",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<mode>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><mode></code> are defined:\n+* <code>CCV_MODE_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_MODE_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><mode></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><mode></code>. As the mode would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 146,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n* If the <code><pk></code> is 0, it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\r\n```",
      "created_at": "2025-04-04T21:36:20Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029464000",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029464000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029466060",
      "pull_request_review_id": 2744075120,
      "id": 2029466060,
      "node_id": "PRRC_kwDOAN28mc549zHM",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<mode>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><mode></code> are defined:\n+* <code>CCV_MODE_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_MODE_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><mode></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><mode></code>. As the mode would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters is invalid, and makes the opcode immediately fail validation.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 154,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe specification is divided into three parts:\r\n```",
      "created_at": "2025-04-04T21:39:03Z",
      "updated_at": "2025-04-04T21:41:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2029466060",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2029466060"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040751773",
      "pull_request_review_id": 2762265826,
      "id": 2040751773,
      "node_id": "PRRC_kwDOAN28mc55o2ad",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.",
      "path": "bip-ccv.mediawiki",
      "position": 67,
      "original_position": 67,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029448116,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What is 'change'? The amount has to be entirely assigned to the outputs.\r\nFor applications like vaults, you can do use the _deduct_ logic with an output that has the same script as the input; most contracts are non-recursive, so they always 'move forward', and there is no meaningful definition of change.\r\n\r\nFees have to be paid exogenously, with a separate input (or by spending an output, if that applies). I think this is necessary in any kind of covenant, as the fee is by definition an amount that is not encumbered by the covenant.",
      "created_at": "2025-04-12T22:17:11Z",
      "updated_at": "2025-04-12T22:17:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2040751773",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040751773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040751850",
      "pull_request_review_id": 2762265924,
      "id": 2040751850,
      "node_id": "PRRC_kwDOAN28mc55o2bq",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:",
      "path": "bip-ccv.mediawiki",
      "position": 60,
      "original_position": 60,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029441820,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "CCV can check the Script of either an input or an output of the transaction. Amount checking is only relevant when the mode is one that refers to an output (0, 1 or 2). Here 'checking an output' refers to the checks that are done in the interpreter when a CCV opcode is executed in one of the modes referring to an output.",
      "created_at": "2025-04-12T22:18:12Z",
      "updated_at": "2025-04-24T14:23:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2040751850",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040751850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 60,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040754036",
      "pull_request_review_id": 2762265924,
      "id": 2040754036,
      "node_id": "PRRC_kwDOAN28mc55o290",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.",
      "path": "bip-ccv.mediawiki",
      "position": 73,
      "original_position": 73,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029454813,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It make more sense with CCV to consider each UTXO as an instance of a contract; so any logic to make multiple UTXOs behave _as if_ they belong to the same logical 'wallet' needs to be explicitly programmed, and each UTXO/input explicitly specifies what must happen to its amount.\r\n\r\nNote that CCV cannot enforce a specific proportion of the amount, but only that the amount of the inputs is accounted for in the output. So you cannot force an equal split without additional introspection opcodes (e.g. combine with a future `OP_AMOUNT` opcode, or `OP_CTV/TXHASH`, etc.).\r\n\r\nWithout additional opcodes, not sure if the _deduct_ semantic is useful outside of vault/recovery use cases. Together with OP_AMOUNT, it could for example be used to withdraw a certain amount from a shared UTXO, leaving the rest in a new shared UTXO.",
      "created_at": "2025-04-12T22:34:01Z",
      "updated_at": "2025-04-24T14:23:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2040754036",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040754036"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": 71,
      "original_start_line": 71,
      "start_side": "RIGHT",
      "line": 73,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040755042",
      "pull_request_review_id": 2762265924,
      "id": 2040755042,
      "node_id": "PRRC_kwDOAN28mc55o3Ni",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.",
      "path": "bip-ccv.mediawiki",
      "position": 101,
      "original_position": 101,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029456605,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Functionality-wise, OP_CCV is strictly more general than OP_VAULT/OP_VAULT_RECOVER*, so I don't think there is possibility of deployment conflict.\r\n\r\n[*] this statement assumes that an opcode suitable for vector commitments (like OP_CAT or OP_PAIRCOMMIT)  is deployed together with OP_CCV; there might be dirty tricks to make it true (inefficiently) with CCV alone, but that's not an interesting thing to do.\r\nSimilar ugly tricks would allow to inefficiently simulate CCV's functionality with OP_VAULT - so if one foregoes efficiency considerations, they are equivalent.",
      "created_at": "2025-04-12T22:42:12Z",
      "updated_at": "2025-04-24T14:23:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2040755042",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040755042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040756004",
      "pull_request_review_id": 2762265924,
      "id": 2040756004,
      "node_id": "PRRC_kwDOAN28mc55o3ck",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 22,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029428269,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "eb56ec5e60dfe81597afdacecac40327e08c6248: fixed capitalization of 'script', and fixed typo in 808fa44a6ebf7493e60f40e642b367cf2ada8fe7.\r\n\r\nIs it standard to split to 120 characters? That would make it harder to adapt the text to different layouts.",
      "created_at": "2025-04-12T22:50:49Z",
      "updated_at": "2025-04-24T14:23:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2040756004",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040756004"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040757218",
      "pull_request_review_id": 2762265924,
      "id": 2040757218,
      "node_id": "PRRC_kwDOAN28mc55o3vi",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 20,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029424502,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Capitalization of script fixed in eb56ec5e60dfe81597afdacecac40327e08c6248.\r\nI rephrased in 1e1279520533f34d3adcb20bf8a1b624a03d3e9a, dropping the usage of the word 'program' and removing the parentheses.",
      "created_at": "2025-04-12T22:58:18Z",
      "updated_at": "2025-04-24T14:23:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2040757218",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040757218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040757294",
      "pull_request_review_id": 2762265924,
      "id": 2040757294,
      "node_id": "PRRC_kwDOAN28mc55o3wu",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 43,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029433007,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed in eb56ec5e60dfe81597afdacecac40327e08c6248.",
      "created_at": "2025-04-12T22:59:05Z",
      "updated_at": "2025-04-24T14:23:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2040757294",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2040757294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 43,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2041123132",
      "pull_request_review_id": 2762265924,
      "id": 2041123132,
      "node_id": "PRRC_kwDOAN28mc55qRE8",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<mode>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 112,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029461164,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in 2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3 (I was incorrectly saying 'top to bottom' when it was already 'bottom to top'. `<data>` is the top (as it's the most convenient place for something that is usually either forwarded through the witness, or computed).",
      "created_at": "2025-04-13T13:14:43Z",
      "updated_at": "2025-04-24T14:23:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2041123132",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2041123132"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": 106,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 112,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2041123288",
      "pull_request_review_id": 2762265924,
      "id": 2041123288,
      "node_id": "PRRC_kwDOAN28mc55qRHY",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with a future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<mode>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 134,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029462887,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in 2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3.",
      "created_at": "2025-04-13T13:15:33Z",
      "updated_at": "2025-04-24T14:23:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2041123288",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2041123288"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2045289706",
      "pull_request_review_id": 2769493293,
      "id": 2045289706,
      "node_id": "PRRC_kwDOAN28mc556KTq",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.",
      "path": "bip-ccv.mediawiki",
      "position": 67,
      "original_position": 67,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029448116,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I may have not realized then yet that the fees are always paid exogenously.",
      "created_at": "2025-04-15T19:11:53Z",
      "updated_at": "2025-04-15T19:11:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2045289706",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2045289706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 67,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2072396648",
      "pull_request_review_id": 2813234938,
      "id": 2072396648,
      "node_id": "PRRC_kwDOAN28mc57hkNo",
      "diff_hunk": "@@ -0,0 +1,409 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes to add consensus support for a new tapscript opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the internal public key and taptree of one or more outputs, and possibly the committed data.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via a single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain a transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data’s hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the UTXO being spent, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current input (that is, the UTXO being spent) is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where a UTXO’s full amount is required to be sent to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown bottom to top, is:\n+\n+<source>\n+<mode> <taptree> <pk> <index> <data>\n+</source>\n+\n+where:\n+\n+* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose script is being executed.\n+\n+The following value of the <code><mode></code> are defined:\n+* <code>CCV_MODE_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_MODE_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><mode></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><mode></code>. As the mode would always be hard-coded via a push in the script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.",
      "path": "bip-ccv.mediawiki",
      "position": 143,
      "original_position": 143,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "in_reply_to_id": null,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't like the usage of `-1` as default arguments for several reasons\r\n\r\n1. It opens up malleability vectors. IIUC this proposal correctly, we have 3 different usages of `-1` on the witness stack. This means we have 8 different combinations of potential valid values on the witness stack. I've pasted a table below of the different malleability combinations\r\n2. Its not composable with other index based opcodes. Other index based opcodes would need to adopt your `-1` semantic to be composable with `OP_CCV`. \r\n\r\nCombination # | Taptree | PK | IDX\r\n-- | -- | -- | --\r\n1 | taptree | pk | idx\r\n2 | taptree | pk | -1\r\n3 | taptree | -1 | idx\r\n4 | taptree | -1 | -1\r\n5 | -1 | pk | idx\r\n6 | -1 | pk | -1\r\n7 | -1 | -1 | idx\r\n8 | -1 | -1 | -1\r\n\r\nIf you remove the `-1` semantic you would get rid of malleability potential and make OP_CCV more composable with future index based opcodes ([`OP_INOUT_AMOUNT`](https://delvingbitcoin.org/t/op-inout-amount/549/4), and [various elements project opcodes](https://github.com/ElementsProject/elements/blob/7ed597f4a5f713e33aac04c87c1a9da5ecd7d52c/src/script/interpreter.cpp#L1925))\r\n\r\nThis has the tradeoff of increasing witness size, but I think the tradeoff is worth it for the benefit of composability. These values can be useful for other opcodes other than `OP_CCV` during script validation! :-)",
      "created_at": "2025-05-03T13:34:37Z",
      "updated_at": "2025-05-03T13:37:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2072396648",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2072396648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 143,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2072477748",
      "pull_request_review_id": 2813315257,
      "id": 2072477748,
      "node_id": "PRRC_kwDOAN28mc57h4A0",
      "diff_hunk": "@@ -0,0 +1,409 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes to add consensus support for a new tapscript opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the internal public key and taptree of one or more outputs, and possibly the committed data.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via a single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain a transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data’s hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the UTXO being spent, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current input (that is, the UTXO being spent) is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where a UTXO’s full amount is required to be sent to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown bottom to top, is:\n+\n+<source>\n+<mode> <taptree> <pk> <index> <data>\n+</source>\n+\n+where:\n+\n+* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose script is being executed.\n+\n+The following value of the <code><mode></code> are defined:\n+* <code>CCV_MODE_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_MODE_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><mode></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><mode></code>. As the mode would always be hard-coded via a push in the script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.",
      "path": "bip-ccv.mediawiki",
      "position": 143,
      "original_position": 143,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "in_reply_to_id": 2072396648,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> 1. It opens up malleability vectors. IIUC this proposal correctly, we have 3 different usages of `-1` on the witness stack. This means we have 8 different combinations of potential valid values on the witness stack. I've pasted a table below of the different malleability combinations\r\n\r\nIn the vast majority of usages, all those arguments would not be passed via the witness stack. The only case where I used an index passed via the witness stack, so far, was for `index` argument in vaults, in order to make them more ergonomic (in that you have more freedom in how to compose your transactions).\r\n\r\nIf a script takes those arguments from the witness, then it's up to the script designer to deal with malleability, possibly by adding additional constraints (like a `CHECKSIG`) in order to avoid it.\r\n\r\n**Remark**: I don't it would ever make sense for `pk` or `taptree` to directly come from the witness; in some case, it could come from a computation that depends on the witness arguments - for example, as the result of opening a commitment, which implicitly deals with malleability,\r\n\r\n> 2. Its not composable with other index based opcodes. Other index based opcodes would need to adopt your `-1` semantic to be composable with `OP_CCV`.\r\n\r\nDo you have a concrete example of lack of composability?\r\n\r\n> If you remove the `-1` semantic you would get rid of malleability potential and make OP_CCV more composable with future index based opcodes ([`OP_INOUT_AMOUNT`](https://delvingbitcoin.org/t/op-inout-amount/549/4), and [various elements project opcodes](https://github.com/ElementsProject/elements/blob/7ed597f4a5f713e33aac04c87c1a9da5ecd7d52c/src/script/interpreter.cpp#L1925))\r\n> This has the tradeoff of increasing witness size, but I think the tradeoff is worth it for the benefit of composability. These values can be useful for other opcodes other than `OP_CCV` during script validation! :-)\r\n\r\nThe `-1` semantic is extremely common and dramatically optimizes the script sizes.\r\n\r\nThe `CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT` mode is there precisely to future-proof the opcode and make it composable with any other amount introspection - even if I don't currently have a use case for it.\r\n\r\nIt's unclear to me how removing a feature could make the opcode more composable. If you don't need the feature for your script, you can simply not use it.",
      "created_at": "2025-05-03T22:37:31Z",
      "updated_at": "2025-05-03T22:37:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2072477748",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2072477748"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 143,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2072493872",
      "pull_request_review_id": 2813330218,
      "id": 2072493872,
      "node_id": "PRRC_kwDOAN28mc57h78w",
      "diff_hunk": "@@ -0,0 +1,409 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes to add consensus support for a new tapscript opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the internal public key and taptree of one or more outputs, and possibly the committed data.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via a single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain a transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data’s hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the UTXO being spent, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current input (that is, the UTXO being spent) is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where a UTXO’s full amount is required to be sent to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown bottom to top, is:\n+\n+<source>\n+<mode> <taptree> <pk> <index> <data>\n+</source>\n+\n+where:\n+\n+* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose script is being executed.\n+\n+The following value of the <code><mode></code> are defined:\n+* <code>CCV_MODE_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_MODE_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><mode></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><mode></code>. As the mode would always be hard-coded via a push in the script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.",
      "path": "bip-ccv.mediawiki",
      "position": 143,
      "original_position": 143,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "in_reply_to_id": 2072396648,
      "user": {
        "login": "Christewart",
        "id": 3514957,
        "node_id": "MDQ6VXNlcjM1MTQ5NTc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3514957?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Christewart",
        "html_url": "https://github.com/Christewart",
        "followers_url": "https://api.github.com/users/Christewart/followers",
        "following_url": "https://api.github.com/users/Christewart/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Christewart/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Christewart/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Christewart/subscriptions",
        "organizations_url": "https://api.github.com/users/Christewart/orgs",
        "repos_url": "https://api.github.com/users/Christewart/repos",
        "events_url": "https://api.github.com/users/Christewart/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Christewart/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'll reply on delving or the mailing list as this probably isn't the best place for posting long form results and to start the conversation about potentially use design changes. Apologies for starting the conversation here and not a more appropriate venue. I should have something ready in the next few days.",
      "created_at": "2025-05-04T01:03:38Z",
      "updated_at": "2025-05-04T01:03:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2072493872",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2072493872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 143,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2078535229",
      "pull_request_review_id": 2823275624,
      "id": 2078535229,
      "node_id": "PRRC_kwDOAN28mc574-49",
      "diff_hunk": "@@ -0,0 +1,409 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes to add consensus support for a new tapscript opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the internal public key and taptree of one or more outputs, and possibly the committed data.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via a single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain a transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data’s hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the UTXO being spent, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current input (that is, the UTXO being spent) is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.",
      "path": "bip-ccv.mediawiki",
      "position": 58,
      "original_position": 58,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Nit: \r\n```suggestion\r\nWhen checking the script of one or more outputs with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current input (that is, the UTXO being spent) is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\r\n```",
      "created_at": "2025-05-07T21:41:42Z",
      "updated_at": "2025-05-07T22:17:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2078535229",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2078535229"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2078540269",
      "pull_request_review_id": 2823275624,
      "id": 2078540269,
      "node_id": "PRRC_kwDOAN28mc575AHt",
      "diff_hunk": "@@ -0,0 +1,409 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes to add consensus support for a new tapscript opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the internal public key and taptree of one or more outputs, and possibly the committed data.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via a single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain a transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data’s hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the UTXO being spent, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current input (that is, the UTXO being spent) is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are three supported modes for the opcode when checking an output, depending on the value of the <code>mode</code> parameter:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''ignore'': the output amount is ignored.\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+\n+The ''default'' logic covers the common case where a UTXO’s full amount is required to be sent to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts should be constrained either with a signature, or with future introspection opcodes that allow fixing the amount. In lack of that, amounts would be malleable.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown bottom to top, is:\n+\n+<source>\n+<mode> <taptree> <pk> <index> <data>\n+</source>\n+\n+where:\n+\n+* <code><mode></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose script is being executed.\n+\n+The following value of the <code><mode></code> are defined:\n+* <code>CCV_MODE_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_MODE_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_MODE_CHECK_OUTPUT_IGNORE_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_MODE_CHECK_OUTPUT_DEDUCT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><mode></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><mode></code>. As the mode would always be hard-coded via a push in the script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters is invalid, and makes the opcode immediately fail validation.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided into three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.",
      "path": "bip-ccv.mediawiki",
      "position": 202,
      "original_position": 202,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\nThe following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evaluation of a taproot script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\r\n```",
      "created_at": "2025-05-07T21:47:00Z",
      "updated_at": "2025-05-07T22:17:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2078540269",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2078540269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 202,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2078542457",
      "pull_request_review_id": 2823275624,
      "id": 2078542457,
      "node_id": "PRRC_kwDOAN28mc575Ap5",
      "diff_hunk": "@@ -0,0 +1,409 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes to add consensus support for a new tapscript opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the script, allowing introspection to the committed data. Moreover, a script can constrain the internal public key and taptree of one or more outputs, and possibly the committed data.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via a single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain a transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data’s hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;",
      "path": "bip-ccv.mediawiki",
      "position": 51,
      "original_position": 51,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least the data’s hash)<ref>For example, in a multi-party contract, the naked key could be an aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO — albeit not always possible in practice.</ref>;\r\n```",
      "created_at": "2025-05-07T21:49:14Z",
      "updated_at": "2025-05-07T22:17:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2078542457",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2078542457"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 51,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2078550072",
      "pull_request_review_id": 2823275624,
      "id": 2078550072,
      "node_id": "PRRC_kwDOAN28mc575Cg4",
      "diff_hunk": "@@ -0,0 +1,413 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Abstract ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments''<ref>''Vector commitments'' are cryptographic primitives that allow to commit to a vector of values via single short value. Hashing and concatenation trivially allow to commit to an entire vector, and later reveal all of its elements. Merkle trees are among the simplest efficient vector commitments, allowing to reveal individual elements with logarithmically-sized proofs.</ref>, this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 22,
      "commit_id": "2655b8b88f15ac3ecfaad91f2c2c1a7be3454fc3",
      "original_commit_id": "9bccf545930f9d4b8211f11d5bd93eac27b75695",
      "in_reply_to_id": 2029428269,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was suggesting that the \"MediaWiki source code\" of your document should be line broken. This would not affect the formatting of the rendered document, but just the presentation of diffs between changes to this pull request and the amount of text that suggestions need to work with.\r\n\r\nI’ve explained my suggestion in [more detail](https://github.com/bitcoin/bips/pull/1670#issuecomment-2523737288) on another PR [before](https://github.com/bitcoin/bips/pull/1670#discussion_r1896085309)",
      "created_at": "2025-05-07T21:57:17Z",
      "updated_at": "2025-05-07T22:17:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2078550072",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2078550072"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    }
  ]
}