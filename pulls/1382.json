{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1382",
    "id": 1086673964,
    "node_id": "PR_kwDOAN28mc5AxVQs",
    "html_url": "https://github.com/bitcoin/bips/pull/1382",
    "diff_url": "https://github.com/bitcoin/bips/pull/1382.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1382.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1382/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
    "number": 1382,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "BIP 331: Ancestor Package Relay",
    "user": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "ML thread: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html\r\n\r\nSupersedes #1324.",
    "labels": [],
    "created_at": "2022-10-13T21:40:08Z",
    "updated_at": "2024-04-17T11:11:19Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merge_commit_sha": "e39052f1274f61b79dddb3345148b7a5d23ab5a0",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "glozow:2022-10-package-relay",
      "ref": "2022-10-package-relay",
      "sha": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 481603389,
        "node_id": "R_kgDOHLSvPQ",
        "name": "bips",
        "full_name": "glozow/bips",
        "owner": {
          "login": "glozow",
          "id": 25183001,
          "node_id": "MDQ6VXNlcjI1MTgzMDAx",
          "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/glozow",
          "html_url": "https://github.com/glozow",
          "followers_url": "https://api.github.com/users/glozow/followers",
          "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
          "organizations_url": "https://api.github.com/users/glozow/orgs",
          "repos_url": "https://api.github.com/users/glozow/repos",
          "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/glozow/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/glozow/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/glozow/bips",
        "archive_url": "https://api.github.com/repos/glozow/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/glozow/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/glozow/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/glozow/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/glozow/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/glozow/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/glozow/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/glozow/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/glozow/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/glozow/bips/contributors",
        "deployments_url": "https://api.github.com/repos/glozow/bips/deployments",
        "downloads_url": "https://api.github.com/repos/glozow/bips/downloads",
        "events_url": "https://api.github.com/repos/glozow/bips/events",
        "forks_url": "https://api.github.com/repos/glozow/bips/forks",
        "git_commits_url": "https://api.github.com/repos/glozow/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/glozow/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/glozow/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/glozow/bips.git",
        "issue_comment_url": "https://api.github.com/repos/glozow/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/glozow/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/glozow/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/glozow/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/glozow/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/glozow/bips/languages",
        "merges_url": "https://api.github.com/repos/glozow/bips/merges",
        "milestones_url": "https://api.github.com/repos/glozow/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/glozow/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/glozow/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/glozow/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:glozow/bips.git",
        "stargazers_url": "https://api.github.com/repos/glozow/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/glozow/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/glozow/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/glozow/bips/subscription",
        "tags_url": "https://api.github.com/repos/glozow/bips/tags",
        "teams_url": "https://api.github.com/repos/glozow/bips/teams",
        "trees_url": "https://api.github.com/repos/glozow/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/glozow/bips.git",
        "hooks_url": "https://api.github.com/repos/glozow/bips/hooks",
        "svn_url": "https://github.com/glozow/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 1,
        "stargazers_count": 2,
        "watchers_count": 2,
        "size": 15356,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-04-17T10:57:54Z",
        "created_at": "2022-04-14T12:52:36Z",
        "updated_at": "2023-06-12T10:57:22Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "b3701faef2bdb98a0d7ace4eedbeefa2da4c89ed",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5223,
        "stargazers_count": 8894,
        "watchers_count": 8894,
        "size": 14123,
        "default_branch": "master",
        "open_issues_count": 147,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-04-17T10:57:58Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2024-04-17T10:48:43Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 436,
    "deletions": 0,
    "changed_files": 9,
    "commits": 1,
    "review_comments": 196,
    "comments": 26
  },
  "events": [
    {
      "event": "renamed",
      "id": 7640288025,
      "node_id": "RTE_lADOAN28mc5T81tmzwAAAAHHZYsZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7640288025",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T12:36:41Z",
      "rename": {
        "from": "Ancestor Package Relay",
        "to": "BIP 331: Ancestor Package Relay"
      }
    },
    {
      "event": "commented",
      "id": 1286905672,
      "node_id": "IC_kwDOAN28mc5MtJ9I",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1286905672",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-21T12:37:13Z",
      "updated_at": "2022-10-21T12:37:13Z",
      "author_association": "MEMBER",
      "body": "Assigned BIP # 331",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1286905672",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7654047146,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAHIN32q",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7654047146",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-24T13:33:17Z"
    },
    {
      "event": "commented",
      "id": 1289043846,
      "node_id": "IC_kwDOAN28mc5M1T-G",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1289043846",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-24T13:33:36Z",
      "updated_at": "2022-10-24T13:33:36Z",
      "author_association": "MEMBER",
      "body": "Updated for number",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1289043846",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7654399934,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAHIPN--",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7654399934",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-24T14:08:46Z"
    },
    {
      "event": "reviewed",
      "id": 1166185447,
      "node_id": "PRR_kwDOAN28mc5FgpPn",
      "url": null,
      "actor": null,
      "commit_id": "112f8cc859d34b72f42708832172b09b70edfc05",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1166185447",
      "submitted_at": "2022-11-03T01:25:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7730328847,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAHMw3UP",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7730328847",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-03T09:30:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7742537586,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAHNfb9y",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7742537586",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T17:03:51Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-13T15:59:53Z",
      "updated_at": "2022-12-13T15:59:53Z",
      "source": {
        "issue": {
          "id": 1494538331,
          "node_id": "I_kwDOHVjEp85ZFNhb",
          "url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/issues/11",
          "repository_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/issues/11/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/issues/11/comments",
          "events_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/issues/11/events",
          "html_url": "https://github.com/bitcoin-inquisition/bitcoin/issues/11",
          "number": 11,
          "state": "open",
          "state_reason": null,
          "title": "Package Relay / V3 package RBF deployment",
          "body": "i.e. port https://github.com/bitcoin/bitcoin/pull/25038\r\n\r\nand implementation of https://github.com/bitcoin/bips/pull/1382",
          "user": {
            "login": "instagibbs",
            "id": 5767891,
            "node_id": "MDQ6VXNlcjU3Njc4OTE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/instagibbs",
            "html_url": "https://github.com/instagibbs",
            "followers_url": "https://api.github.com/users/instagibbs/followers",
            "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
            "organizations_url": "https://api.github.com/users/instagibbs/orgs",
            "repos_url": "https://api.github.com/users/instagibbs/repos",
            "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/instagibbs/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 0,
          "created_at": "2022-12-13T15:48:34Z",
          "updated_at": "2023-08-08T12:09:31Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1363816436,
      "node_id": "IC_kwDOAN28mc5RSi_0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1363816436",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-23T10:16:08Z",
      "updated_at": "2022-12-23T10:16:39Z",
      "author_association": "MEMBER",
      "body": "I'm not a big mempool expert, but this seems like a good direction.\r\n\r\n---------------\r\n\r\n1. There are obvious typos and misalignments you're probably aware of, i assume we shouldn't merge them?\r\n\r\n2.\r\n> Package Information Only\r\n\r\nThis example seems confusing: it violates the following rule `A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.`\r\nIt will likely work if you expand the example to 3 transactions?\r\n\r\n3. Unclear what to do when transactions are replaced in the middle of this process. Should that be covered? Probably will become clearer when you prototype.\r\n\r\n4. Same about timestamping concerns i guess.\r\n\r\n5. As a style comment, I'd suggest doing some compression of the text :)\r\n\r\n6. `Is Package Erlay possible?`\r\n6a) I actually made some attempt to handle parent/child within Erlay, do you think we should exercise the overlap between the two better? E.g., for those packages flowing through the network (not the IBD case, but fee-bump or something) Erlay might do the batching you need.\r\n6b) One might also think about \"what if we reconcile packages\"? Probably bad idea, because the sets (packages) are too small? My point is that this should not be confused with what you describing.\r\n\r\n7. MSG_ANCPKGINFO and getpkgtxns have some redundancy in the data... The latter could refer to the hash of the former + the indexes, for example? Not sure savings worth the complexity (how often this will be used? every lightning closure?) but maybe worth making it into q/a :)",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1363816436",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "commented",
      "id": 1375501351,
      "node_id": "IC_kwDOAN28mc5R_Hwn",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1375501351",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-09T11:41:33Z",
      "updated_at": "2023-01-09T11:41:33Z",
      "author_association": "MEMBER",
      "body": "Thanks for the review @naumenkogs! yes, I think it's best to talk specifics with the actual implementation but I'll throw some quick answers for now:\r\n\r\n> Unclear what to do when transactions are replaced in the middle of this process. Should that be covered? Probably will become clearer when you prototype.\r\n\r\nOne should treat this situation the same way we do for transactions that get replaced in between inv and getdata (I don't see any reason it should be different). Currently, we send \"notfound\". If in the future we decide to relay recently-replaced transactions, then package relay would include recently-replaced transactions as well. Though I agree this seems more like an implementation question than a spec question. In the spec, I would leave it as \"the receiver may respond with notfound.\"\r\n\r\n> I actually made some attempt to handle parent/child within Erlay, do you think we should exercise the overlap between the two better? E.g., for those packages flowing through the network (not the IBD case, but fee-bump or something) Erlay might do the batching you need.\r\n\r\nYes it's great that Erlay orders them correctly. Note below-fee-filter transactions to the reconciliation bucket so not every case is handled. I plan to have a rebase-on-top-of-Erlay version so we can exercise the two together.\r\n\r\n> One might also think about \"what if we reconcile packages\"? Probably bad idea, because the sets (packages) are too small? My point is that this should not be confused with what you describing.\r\n\r\nMostly the \"Is Package Erlay possible\" section was to clarify that they aren't mutually exclusive.\r\nReconciling packages is I think something that may come up when we get to sender-initiated package relay. I'm thinking, after reconciliation, it may be useful to send a package inv instead of individual tx invs if there are fee-bumps... But for now, since packages must be requested by the receiver, we don't need to think about that yet.\r\n\r\n> MSG_ANCPKGINFO and getpkgtxns have some redundancy in the data... The latter could refer to the hash of the former + the indexes, for example? \r\n\r\nYeah that's an interesting idea, we could do a bitfield of 4 bytes (should cover any package since max count is 25). However this means you can only request getpkgtxns from somebody who sent an ancpkginfo (currently this is not a requirement). It also requires the sender to keep track of (allocate memory for, remember to expire) what they announced so they know what \"the ith transaction from this package\" means. Thoughts?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1375501351",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 8180902028,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAHnnqiM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8180902028",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-09T11:41:33Z"
    },
    {
      "event": "subscribed",
      "id": 8180902041,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAHnnqiZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8180902041",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-09T11:41:33Z"
    },
    {
      "event": "commented",
      "id": 1375652233,
      "node_id": "IC_kwDOAN28mc5R_smJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1375652233",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-09T13:49:45Z",
      "updated_at": "2023-01-09T13:49:45Z",
      "author_association": "MEMBER",
      "body": ">Though I agree this seems more like an implementation question than a spec question. In the spec, I would leave it as \"the receiver may respond with notfound.\"\r\n\r\nThe thing with current `notfound` is that it's atomic I guess — makes it easy to consider every announcement independent and our code treats it as such (in a poor way but there are also no expectations). With packages, I imagine a CPFP transaction gets replaced and dropped from the package due. A package recipient would then do what, drop the entire package, or consider it invalid?\r\n\r\nA requestor will get this package which doesn't pass the fees, and drop it on the floor? Or should it re-request the package? At the moment, I'm not interested in the final answer — but interested in making sure we don't miss such questions.\r\n\r\n> Reconciling packages is I think something that may come up when we get to sender-initiated package relay. I'm thinking, after reconciliation, it may be useful to send a package inv instead of individual tx invs if there are fee-bumps... But for now, since packages must be requested by the receiver, we don't need to think about that yet.\r\n\r\nNot sure this anything to do with who initiates packages. Let's think about the current proposal. Imagine, upon the announcement of C, the receiver sends getdata(MSG_ANCPKGINFO, C), along with some compressed data saying that he already has 1 parent and 1 child of C (by just looking at the wtxid). Then it would save us announcing these 2 wtxids in the reverse direction.\r\n\r\n>Yeah that's an interesting idea, we could do a bitfield of 4 bytes (should cover any package since max count is 25). However this means you can only request getpkgtxns from somebody who sent an ancpkginfo (currently this is not a requirement). It also requires the sender to keep track of (allocate memory for, remember to expire) what they announced so they know what \"the ith transaction from this package\" means. Thoughts?\r\n\r\nI don't think memory allocation and stuff is a show-stopper, but it might be too much complexity if the gain is low. We should measure how much savings it allows... I think saving 28 byte per announced tx might be worthy. As for the \"same peer\", do you ever expect packages to be requested from a different peer from the one announced them?",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1375652233",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8602774780,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAIAw-z8",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8602774780",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T15:00:33Z"
    },
    {
      "event": "reviewed",
      "id": 1352700273,
      "node_id": "PRR_kwDOAN28mc5QoJFx",
      "url": null,
      "actor": null,
      "commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1352700273",
      "submitted_at": "2023-03-22T14:35:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8863314367,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAIQS3G_",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8863314367",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-28T10:04:20Z"
    },
    {
      "event": "commented",
      "id": 1486572013,
      "node_id": "IC_kwDOAN28mc5Ym0nt",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1486572013",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-28T10:05:32Z",
      "updated_at": "2023-03-28T10:07:54Z",
      "author_association": "MEMBER",
      "body": "@jnewbery thanks, took all suggestions\r\n\r\nCI seems to be failing on bip-0327 title being too long, so will ignore for now.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1486572013",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 8863326727,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIQS6IH",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8863326727",
      "actor": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-28T10:05:32Z"
    },
    {
      "event": "subscribed",
      "id": 8863326760,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIQS6Io",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8863326760",
      "actor": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-28T10:05:32Z"
    },
    {
      "event": "commented",
      "id": 1489536115,
      "node_id": "IC_kwDOAN28mc5YyIRz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1489536115",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T01:00:12Z",
      "updated_at": "2023-03-30T01:00:12Z",
      "author_association": "MEMBER",
      "body": "Sorry about that, the BIP-327 title issue has been fixed, so please rebase.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1489536115",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8886114220,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAIRp1es",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8886114220",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T10:58:53Z"
    },
    {
      "event": "reviewed",
      "id": 1368605053,
      "node_id": "PRR_kwDOAN28mc5Rk0F9",
      "url": null,
      "actor": null,
      "commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1368605053",
      "submitted_at": "2023-04-03T10:40:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "reviewed",
      "id": 1369166545,
      "node_id": "PRR_kwDOAN28mc5Rm9LR",
      "url": null,
      "actor": null,
      "commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1369166545",
      "submitted_at": "2023-04-03T18:50:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "reviewed",
      "id": 1370565687,
      "node_id": "PRR_kwDOAN28mc5RsSw3",
      "url": null,
      "actor": null,
      "commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1370565687",
      "submitted_at": "2023-04-04T13:37:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "commented",
      "id": 1497732032,
      "node_id": "IC_kwDOAN28mc5ZRZPA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1497732032",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T15:55:15Z",
      "updated_at": "2023-04-05T15:55:15Z",
      "author_association": "MEMBER",
      "body": "Thanks @jnewbery @stickies-v @willcl-ark for the feedback. I'm working on incorporating the suggestions, apologies for the delay.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1497732032",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 8936846107,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIUrXMb",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8936846107",
      "actor": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T15:55:16Z"
    },
    {
      "event": "subscribed",
      "id": 8936846122,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIUrXMq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8936846122",
      "actor": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T15:55:16Z"
    },
    {
      "event": "mentioned",
      "id": 8936846150,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIUrXNG",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8936846150",
      "actor": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T15:55:16Z"
    },
    {
      "event": "subscribed",
      "id": 8936846168,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIUrXNY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8936846168",
      "actor": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T15:55:16Z"
    },
    {
      "event": "mentioned",
      "id": 8936846198,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIUrXN2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8936846198",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T15:55:16Z"
    },
    {
      "event": "subscribed",
      "id": 8936846215,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIUrXOH",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8936846215",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T15:55:16Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8947297601,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAIVTO1B",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8947297601",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-06T15:33:05Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-14T11:14:50Z",
      "updated_at": "2023-04-14T11:14:50Z",
      "source": {
        "issue": {
          "id": 1668056618,
          "node_id": "I_kwDOABII585jbIYq",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27463",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27463/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27463/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27463/events",
          "html_url": "https://github.com/bitcoin/bitcoin/issues/27463",
          "number": 27463,
          "state": "open",
          "state_reason": null,
          "title": "Package Relay Project Tracking",
          "body": "This issue will be edited frequently to reflect the current status of the project.\r\n\r\n### What is ready for review now?\r\n:point_down: :point_down: :point_down: :point_down: :point_down: :point_down: :point_down:\r\np2p: #28970\r\nmempool: #28984\r\n:point_up: :point_up: :point_up: :point_up: :point_up: :point_up: :point_up: \r\n\r\n### Why does the roadmap look like this?\r\n:point_right: #29319 :point_left: \r\n\r\n### Tasks and PRs\r\n**(1) multi-parent-1-child package validation**\r\n\r\nWhat we get: the ability to validate multiple transactions, including CPFP of transactions below the mempool minimum feerate. An RPC to submit things locally.\r\n\r\n<details><summary>See PRs</summary>\r\n\r\n- Enable validation of multiple transactions in MemPoolAccept\r\n  - [x] Dependency: #21062\r\n  - [x] Dependency: #23381\r\n  - [x] Main feature 1/2: #20833\r\n  - [x] Main feature 2/2: #21800\r\n  - [x] Followup: #22084\r\n- Enable package CPFP\r\n  - [x] Main feature 1/2: #22674\r\n  - [x] Followup: #24310\r\n  - [x] Followup: #23804\r\n  - [x] Main feature 2/2: #24152\r\n  - [x] short term bug fix: avoid the risk of below-minrelaytxfee transactions hanging around forever in the mempool  #26933\r\n- RPC access\r\n  - [x] #24836\r\n  - [x] #26646\r\n  - [x] #27609\r\n  - [x] #28848\r\n  - [x] #28950\r\n  - [x] Followup: #29722\r\n  - [x] Followup: #29735 \r\n- Fuzzing and bug fixes\r\n  - [x] #28450\r\n  - [x] #28764\r\n  - [x] #28825 \r\n  - [x] Bug fix: #28251\r\n  - [x] Bug fix: #28471\r\n  - [x] Bug fix: #28472\r\n</details>\r\n\r\n**(2a) Topologically Restricted Until Confirmation (v3) transaction policy**\r\n\r\nWhat we get: an opt-in policy for anti-pinning in single transaction or 1-parent-1-child package scenarios. Also, package CPFP of 0-fee parent and package RBF for restricted topologies prior to cluster mempool.\r\n- Topologically Restricted Until Confirmation (v3) transaction policy\r\n  - [x] Main feature: #28948\r\n  - [x] Followup: #29424\r\n  - [x] Sibling Eviction: #29306\r\n  - [ ] Enable v3 on mainnet: #29496\r\n- Also see: #29873\r\n- Also see: #29427\r\n\r\n**(2b) Package RBF for cluster size 2**\r\n- Enable Package RBF for 1-parent-1-child situations\r\n   - [x] Dependency: #22796 \r\n   - [x] Dependency: #22675 \r\n   - [x] Dependency: #22855\r\n   - [x] Dependency: #29242\r\n     - [x] Followup: #29724\r\n     - [ ] #29757\r\n   - [ ] Main feature: #28984\r\n\r\n**(3) 1-parent-1-child package relay**\r\n\r\nWhat we get: package relay of 1-parent-1-child packages.\r\nProtocols like LN can use this to create 0-fee presigned transactions with a single, 0-value anchor output; 0-fee commitment transactions can replace each other using the fees of the child attached to the anchor.\r\nThis should provide an adequate replacement for CPFP carve out, which is helpful for the next step (see #29319).\r\n\r\n- Opportunistically submit 1-parent-1-child packages\r\n  - [x] Dependency: #28785\r\n  - [ ] WIP #28970\r\n- Try multiple peers for orphan resolution, make orphanage more robust\r\n  - [x] Dependency: #28785\r\n  - [x] Dependency: #28199\r\n  - [x] Dependency: #28364\r\n  - [ ] Main feature: #28031 \r\n  - [ ] WIP: token bucket orphanage protection\r\n\r\n**(4) cluster mempool**\r\n\r\nWhat we get: the ability to quickly assess the incentive compatibility of transactions, safer eviction, more incentive-compatible and pinning-free RBF rules.\r\n\r\n- [ ] Cluster Mempool #27677\r\n  - [ ] #28676\r\n\r\n\r\n**(5) more general package relay**\r\n\r\nGoals: propagate incentive-compatible packages that are more compelx than 1p1c, safely evaluate replacements within packages, handle orphans better.\r\n\r\n- WIP: Package RBF with less restrictive topologies\r\n- WIP: Package validation of less restrictive topologies\r\n- Ephemeral Anchors\r\n  - #29001\r\n  - bitcoin/bips/pull/1524\r\n- [ ] use BIP 331 ancestor package relay for orphan-handling\r\n  - [ ] bitcoin/bips/pull/1382\r\n  - [ ] #27742 \r\n- [ ] Some sender-initiated package relay protocol using chunks (?)\r\n\r\n<details><summary>See also:</summary>\r\n\r\nSuperseded/Deferred Work\r\n- Sub-package evaluation with ancestor packages\r\n- [x] #28758\r\n  - [x] #28808\r\n  - #26711 \r\n  - #28813\r\n- #27018\r\n- #25038\r\n- #26403\r\n\r\nPrehistory\r\n- [x] #16400 \r\n- #16401 \r\n- #14895 \r\n- #19621 \r\n- https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a\r\n</details>",
          "user": {
            "login": "glozow",
            "id": 25183001,
            "node_id": "MDQ6VXNlcjI1MTgzMDAx",
            "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/glozow",
            "html_url": "https://github.com/glozow",
            "followers_url": "https://api.github.com/users/glozow/followers",
            "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
            "organizations_url": "https://api.github.com/users/glozow/orgs",
            "repos_url": "https://api.github.com/users/glozow/repos",
            "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/glozow/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 64583,
              "node_id": "MDU6TGFiZWw2NDU4Mw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature",
              "name": "Feature",
              "color": "7cf575",
              "default": false
            },
            {
              "id": 64584,
              "node_id": "MDU6TGFiZWw2NDU4NA==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Brainstorming",
              "name": "Brainstorming",
              "color": "ebd775",
              "default": false
            },
            {
              "id": 82428251,
              "node_id": "MDU6TGFiZWw4MjQyODI1MQ==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/TX%20fees%20and%20policy",
              "name": "TX fees and policy",
              "color": "5319e7",
              "default": false
            },
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 15,
          "created_at": "2023-04-14T11:14:50Z",
          "updated_at": "2024-04-16T07:30:57Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9073330438,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAIc0AkG",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9073330438",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-22T16:32:57Z"
    },
    {
      "event": "commented",
      "id": 1518699361,
      "node_id": "IC_kwDOAN28mc5ahYNh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1518699361",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-22T16:37:06Z",
      "updated_at": "2023-04-22T16:38:52Z",
      "author_association": "MEMBER",
      "body": "Changed the `version` field in \"sendpackages\" to `versions`, now interpreted as a bitfield, and updated the negotiation procedure accordingly. (https://github.com/bitcoin/bips/pull/1382#discussion_r1173605835)\r\nSwapped the inv values for `MSG_ANCPKGINFO` and `MSG_PKGTXNS` (https://github.com/bitcoin/bips/pull/1382#discussion_r1156267093)\r\n\r\nNeither of these are implemented in the branch I had linked before, so I've removed that link. Will update when I've done that.\r\n\r\nI've restructured the BIP to make the difference between \"generic\" (can be used in future versions of package relay) vs \"ancestor info\" (first defined version) parts more clear (https://github.com/bitcoin/bips/pull/1382#discussion_r1155782599). Also updated the diagrams and took wording suggestions.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1518699361",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "commented",
      "id": 1529901039,
      "node_id": "IC_kwDOAN28mc5bMG_v",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1529901039",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-01T16:07:11Z",
      "updated_at": "2023-05-01T16:07:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "Maybe it's obvious or I am missing something but I couldn't see the answer in the doc: How would a node decide between sending `Inv(PKGINFO, C)` or `Inv(WTX, C)` in the Generic Package Relay example graphic? Is it always sending `PKGINFO` if the peer wants packages and C is part of a package?",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1529901039",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "commented",
      "id": 1531630562,
      "node_id": "IC_kwDOAN28mc5bStPi",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1531630562",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-02T14:57:36Z",
      "updated_at": "2023-05-02T14:57:36Z",
      "author_association": "MEMBER",
      "body": "@fjahr \"The inv type should not be used in announcements\" it's a type used for `getdata` only IIUC",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1531630562",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 9146742588,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIhMDc8",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9146742588",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-02T14:57:37Z"
    },
    {
      "event": "subscribed",
      "id": 9146742613,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIhMDdV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9146742613",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-02T14:57:37Z"
    },
    {
      "event": "commented",
      "id": 1531716890,
      "node_id": "IC_kwDOAN28mc5bTCUa",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1531716890",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-02T15:53:48Z",
      "updated_at": "2023-05-02T15:53:48Z",
      "author_association": "CONTRIBUTOR",
      "body": "> @fjahr \"The inv type should not be used in announcements\" it's a type used for `getdata` only IIUC\r\n\r\nHmm, ok, first insight: the inconsistencies in the message naming can be confusing. I guess it gets obvious when someone goes deeper but I did a pretty superficial pass and then tried to find an answer to this question and I guess I stumbled over that it's `PKGINFO` in the graphics but `ANCPKGINFO` in the text.\r\n\r\nIt seems that the name has changed before which makes researching past discussions on the mailing list harder. Maybe that could be noted somewhere (the artist formerly known as `PKGINFO`, also formerly know as `MSG_PCKG1` etc.). Not sure it's worth the hassle but in this case it would have helped me.\r\n\r\nIn an old ML post I found:\r\n```\r\n''Q: Under what circumstances should a sender announce a\r\nchild-with-unconfirmed-parents package?''\r\n\r\nA child-with-unconfirmed-parents package for a transaction should be\r\nannounced when it meets the peer's fee filter but one or more of its\r\nparents don't; a \"inv(MSG_PCKG1)\" instead of \"inv(WTX)\" should be sent\r\nfor the child. Each of the parents which meet the peer's fee filter\r\nshould still be announced normally.\r\n```\r\n(from https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html)\r\n\r\nBut this is now changed it seems so maybe the graphics can be updated in this regard as well and the inv messages removed?",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1531716890",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 9147301871,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIhOL_v",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9147301871",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-02T15:53:50Z"
    },
    {
      "event": "subscribed",
      "id": 9147301928,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIhOMAo",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9147301928",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-02T15:53:51Z"
    },
    {
      "event": "commented",
      "id": 1532798599,
      "node_id": "IC_kwDOAN28mc5bXKaH",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1532798599",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-03T10:34:15Z",
      "updated_at": "2023-05-03T10:37:31Z",
      "author_association": "MEMBER",
      "body": "Yes, `PKGINFO` is not specified anywhere; think of it as an \"abstract class.\" The purpose of that diagram is to show how this protocol might be extended or upgraded in the future, i.e. we can define a new type of `PKGINFO` message to be used in invs and/or getdatas, and continue using the same getpkgtxns and pkgtxns message for transaction download. I want to separate those 2 concepts: exchanging package information and exchanging transaction data.\r\n\r\nFor example, `CHUNKPKGINFO` could contain a chunk (with cluster-based mempool), perhaps specifying the chunk fee and size as well. Originally, I proposed a `PCKGINFO1` type which was a child and its parents to communicate a fee-bumping relationship.\r\n\r\nThe reason there is an \"inv(PKGINFO)\" there is to communicate that, while `inv(ANCPKGINFO)` is not allowed, some other kind of `inv(PKGINFO)` can be allowed in the future for a sender-initiated protocol.\r\n\r\nI will update the diagram to make this more clear, thanks for the feedback and sorry for the confusion!",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1532798599",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9154160164,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAIhoWYk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9154160164",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-03T10:56:08Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9154256586,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAIhot7K",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9154256586",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-03T11:07:12Z"
    },
    {
      "event": "commented",
      "id": 1536325748,
      "node_id": "IC_kwDOAN28mc5bknh0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1536325748",
      "actor": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-05T14:13:19Z",
      "updated_at": "2023-05-05T14:13:19Z",
      "author_association": "NONE",
      "body": "Linking https://github.com/nostr-protocol/nips/pull/476, nostr-based package relay.",
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1536325748",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "reviewed",
      "id": 1424540699,
      "node_id": "PRR_kwDOAN28mc5U6MQb",
      "url": null,
      "actor": null,
      "commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "In my opinion, the proposed protocol is sound and the BIP provides almost all the necessary information. I am asking for a little more clarification in some places but most of my suggestions are intended to make to document easier to parse for first-time readers. While the information is there it is often ordered differently than I would expect. Maybe others' brains work differently but for me, this would have made a significant difference when I started studying this.",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1424540699",
      "submitted_at": "2023-05-14T14:23:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "commented",
      "id": 1568835235,
      "node_id": "IC_kwDOAN28mc5dgoaj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1568835235",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-30T17:49:53Z",
      "updated_at": "2023-05-30T17:49:53Z",
      "author_association": "MEMBER",
      "body": "bip-0331/package_cpfp_flow.png <--- looks like receiver is asking for A even though they already have it",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1568835235",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "reviewed",
      "id": 1451512139,
      "node_id": "PRR_kwDOAN28mc5WhFFL",
      "url": null,
      "actor": null,
      "commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1451512139",
      "submitted_at": "2023-05-30T18:02:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9388880383,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAIvnvH_",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9388880383",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T11:08:50Z"
    },
    {
      "event": "commented",
      "id": 1570002323,
      "node_id": "IC_kwDOAN28mc5dlFWT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1570002323",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T11:19:30Z",
      "updated_at": "2023-05-31T11:19:30Z",
      "author_association": "MEMBER",
      "body": "> bip-0331/package_cpfp_flow.png <--- looks like receiver is asking for A even though they already have it\r\n\r\nThanks for catching!!! Fixed",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1570002323",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "commented",
      "id": 1577414980,
      "node_id": "IC_kwDOAN28mc5eBXFE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1577414980",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T20:14:46Z",
      "updated_at": "2023-06-05T20:14:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK, thanks for the updates, I find it an easier read now and didn't see any other issues in my latest pass.\r\n\r\nOne more question: this protocol seems pretty convenient for fingerprinting nodes by giving specific ancestors to different connections and then observing which tx the connections request to complete the package. I don't think this is a huge problem since there are several other options that allow fingerprinting. But I am curious if this has been discussed somewhere in the past or if there are already ideas for mitigations in the implementation (which I haven't fully reviewed yet).",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1577414980",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "commented",
      "id": 1577426216,
      "node_id": "IC_kwDOAN28mc5eBZ0o",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1577426216",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T20:24:58Z",
      "updated_at": "2023-06-05T20:24:58Z",
      "author_association": "MEMBER",
      "body": "@fjahr can you think of a fundamentally new vectors vs the back and forth orphan fetching? Package fetching seems to be more of a optimization on that. Higher resolution fingerprinting, if it's more reliable I guess :)",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1577426216",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 9437965710,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIyi-2O",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9437965710",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T20:24:58Z"
    },
    {
      "event": "subscribed",
      "id": 9437965724,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIyi-2c",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9437965724",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T20:24:58Z"
    },
    {
      "event": "commented",
      "id": 1577450727,
      "node_id": "IC_kwDOAN28mc5eBfzn",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1577450727",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T20:47:05Z",
      "updated_at": "2023-06-05T20:47:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "> @fjahr can you think of a fundamentally new vectors vs the back and forth orphan fetching? Package fetching seems to be more of a optimization on that. Higher resolution fingerprinting, if it's more reliable I guess :)\r\n\r\nI don't think it's fundamentally new, that's why I don't think it's a big issue. But I do think it makes the attack more convenient to scale.\r\n\r\nWhat I had in mind: 1. Make an unconfirmed tx chain A through G. 2. Give different connections different combinations of the txs B through F. This should be 5! = 120 unique fingerprints. 3. Send G and respond to the `getdata(ANCPKGINFO, G)` to see which tx of B through F the connection is aware of.",
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1577450727",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 9438189132,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIyj1ZM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9438189132",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T20:47:05Z"
    },
    {
      "event": "subscribed",
      "id": 9438189146,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIyj1Za",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9438189146",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T20:47:05Z"
    },
    {
      "event": "commented",
      "id": 1578390236,
      "node_id": "IC_kwDOAN28mc5eFFLc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1578390236",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-06T10:29:50Z",
      "updated_at": "2023-06-06T10:29:50Z",
      "author_association": "MEMBER",
      "body": "@fjahr fingerprinting is a good consideration but neither new nor made\neasier. An even more convenient approach: make invalid transactions (as\nmany as you want for free), each with different wtxids, and send one to\neach node. Nodes will cache their unique rejections and not send a getdata\non announcement.\n\nEl El lun, 5 jun 2023 a las 21:47, Fabian Jahr ***@***.***>\nescribió:\n\n> @fjahr <https://github.com/fjahr> can you think of a fundamentally new\n> vectors vs the back and forth orphan fetching? Package fetching seems to be\n> more of a optimization on that. Higher resolution fingerprinting, if it's\n> more reliable I guess :)\n>\n> I don't think it's fundamentally new, that's why I don't think it's a big\n> issue. But I do think it makes the attack more convenient to scale.\n>\n> What I had in mind: 1. Make an unconfirmed tx chain A through G. 2. Give\n> different connections different combinations of the txs B through F. This\n> should be 5! = 120 unique fingerprints. 3. Send G and respond to the getdata(ANCPKGINFO,\n> G) to see which tx of B through F the connection is aware of.\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/bitcoin/bips/pull/1382#issuecomment-1577450727>, or\n> unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AGAEGGKBQPRGH6NQJYKJNG3XJZAVLANCNFSM6AAAAAAREVY6QA>\n> .\n> You are receiving this because you authored the thread.Message ID:\n> ***@***.***>\n>\n",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1578390236",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 9444480808,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAIy71co",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9444480808",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-06T10:29:51Z"
    },
    {
      "event": "subscribed",
      "id": 9444480835,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAIy71dD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9444480835",
      "actor": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-06T10:29:51Z"
    },
    {
      "event": "reviewed",
      "id": 1466384865,
      "node_id": "PRR_kwDOAN28mc5XZ0Hh",
      "url": null,
      "actor": null,
      "commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Review at “Combined Hash” excluded.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1466384865",
      "submitted_at": "2023-06-07T02:14:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "reviewed",
      "id": 1467895006,
      "node_id": "PRR_kwDOAN28mc5Xfkze",
      "url": null,
      "actor": null,
      "commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1467895006",
      "submitted_at": "2023-06-07T14:51:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9471695397,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAI0jpol",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9471695397",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-08T12:01:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9471721880,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAI0jwGY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9471721880",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-08T12:03:37Z"
    },
    {
      "event": "reviewed",
      "id": 1473309953,
      "node_id": "PRR_kwDOAN28mc5X0O0B",
      "url": null,
      "actor": null,
      "commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1473309953",
      "submitted_at": "2023-06-10T08:26:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "reviewed",
      "id": 1479517188,
      "node_id": "PRR_kwDOAN28mc5YL6QE",
      "url": null,
      "actor": null,
      "commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1479517188",
      "submitted_at": "2023-06-14T13:53:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9529033986,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAI3-YUC",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9529033986",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T13:55:04Z"
    },
    {
      "event": "commented",
      "id": 1591270404,
      "node_id": "IC_kwDOAN28mc5e2NwE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1591270404",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T14:00:39Z",
      "updated_at": "2023-06-14T14:00:39Z",
      "author_association": "MEMBER",
      "body": "Updated for suggestions from @ajtowns, thanks!\r\n\r\nMajor changes (still need to update implementation to reflect these):\r\n- Added a `PKG_RELAY_PKGTXNS = 1 << 0` and `PKG_RELAY_ANC` is now `1 << 1` (signaling both is versions=3). (https://github.com/bitcoin/bips/pull/1382#discussion_r1225156027)\r\n- Set maximum 100 wtxids in a `getpkgtxns` request. (https://github.com/bitcoin/bips/pull/1382#discussion_r1228918874)",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1591270404",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 9529110474,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAI3-q_K",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9529110474",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T14:00:39Z"
    },
    {
      "event": "subscribed",
      "id": 9529110504,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAI3-q_o",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9529110504",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T14:00:40Z"
    },
    {
      "event": "reviewed",
      "id": 1479716169,
      "node_id": "PRR_kwDOAN28mc5YMq1J",
      "url": null,
      "actor": null,
      "commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1479716169",
      "submitted_at": "2023-06-14T15:09:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "reviewed",
      "id": 1482524666,
      "node_id": "PRR_kwDOAN28mc5YXYf6",
      "url": null,
      "actor": null,
      "commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "See the note on maybe asymmetry around “ancpkginfo\"",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1482524666",
      "submitted_at": "2023-06-16T00:46:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-29T17:15:57Z",
      "updated_at": "2023-06-29T17:15:57Z",
      "source": {
        "issue": {
          "id": 1781225924,
          "node_id": "I_kwDOIb0R9c5qK1nE",
          "url": "https://api.github.com/repos/TABConf/2023.tabconf.com/issues/88",
          "repository_url": "https://api.github.com/repos/TABConf/2023.tabconf.com",
          "labels_url": "https://api.github.com/repos/TABConf/2023.tabconf.com/issues/88/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/TABConf/2023.tabconf.com/issues/88/comments",
          "events_url": "https://api.github.com/repos/TABConf/2023.tabconf.com/issues/88/events",
          "html_url": "https://github.com/TABConf/2023.tabconf.com/issues/88",
          "number": 88,
          "state": "closed",
          "state_reason": "completed",
          "title": "“Draw me a Contracting Protocol” : The case-study of Blockrate Binaries Contracts",
          "body": "The talk is about a) presenting the functional \"anatomy\" of contracting protocols, a class of Bitcoin second-layers (e.g vaults, LN, DLCs) that has been gaining more and more awareness and usage in the Bitcoin ecosystem along the past years, b) do a case study of Blockrate Binaries Contract as an example of a contracting protocol and c) teach attendees to design their own contracting protocols, the fundamentals, the pitfalls, and the software libraries available to build them.\r\n\r\nThe talk aims to be in socratic form, where attendees can ask questions on the flight, share their experiences, challenges the ideas presented, etc.\r\n\r\nThe attendees can read the [BIP331 Motivation](https://github.com/bitcoin/bips/pull/1382) which is one of the best resource available on the challenges of contracting protocols, [the Optech article on Blockrate Binaries](https://bitcoinops.org/en/newsletters/2023/05/10/) and the [Blockrate Binaries paper](https://github.com/blockrate-binaries/paper/blob/master/blockrate-binaries-paper.pdf) itself (previous litterature on POWSWAP is presented in the sources).\r\n\r\nAbout myself, former Chaincode Labs open-source developer, Bitcoin Core and Lightning Dev Kit contributor since 2018, independent Bitcoin protocols R&D enginer.\r\n\r\nAs usual for all my technical conferences talks, I'm kindly requesting from the organizers to not proceed to video record of my physical persona and nicely requesting the audience to not take pictures, while audio captation is allowed.\r\n\r\nLength of talk: 15 - 20min\r\n\r\nPreferred Day / Time Slot: Workshop. If both talks (cf. other on on LN sec) are accepted, as a preference not the same day.\r\n\r\n_Disclosure of potential conflict of interests: The blockrate binaries paper research has been conducted in the context of a business relationship with the OP_ENERGY project, while in respect of scientific research autonomy and Bitcoin FOSS standards._",
          "user": {
            "login": "ariard",
            "id": 23310655,
            "node_id": "MDQ6VXNlcjIzMzEwNjU1",
            "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ariard",
            "html_url": "https://github.com/ariard",
            "followers_url": "https://api.github.com/users/ariard/followers",
            "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
            "organizations_url": "https://api.github.com/users/ariard/orgs",
            "repos_url": "https://api.github.com/users/ariard/repos",
            "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ariard/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 5077562431,
              "node_id": "LA_kwDOIb0R9c8AAAABLqV0Pw",
              "url": "https://api.github.com/repos/TABConf/2023.tabconf.com/labels/Talk",
              "name": "Talk",
              "description": "Talks during TABConf 2023",
              "color": "46A88F",
              "default": false
            },
            {
              "id": 5648591830,
              "node_id": "LA_kwDOIb0R9c8AAAABUK6r1g",
              "url": "https://api.github.com/repos/TABConf/2023.tabconf.com/labels/Accepted",
              "name": "Accepted",
              "description": "Accepted",
              "color": "0E8A16",
              "default": false
            },
            {
              "id": 5855837911,
              "node_id": "LA_kwDOIb0R9c8AAAABXQj-1w",
              "url": "https://api.github.com/repos/TABConf/2023.tabconf.com/labels/ACK",
              "name": "ACK",
              "description": "",
              "color": "C2E0C6",
              "default": false
            }
          ],
          "assignee": {
            "login": "ariard",
            "id": 23310655,
            "node_id": "MDQ6VXNlcjIzMzEwNjU1",
            "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ariard",
            "html_url": "https://github.com/ariard",
            "followers_url": "https://api.github.com/users/ariard/followers",
            "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
            "organizations_url": "https://api.github.com/users/ariard/orgs",
            "repos_url": "https://api.github.com/users/ariard/repos",
            "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ariard/received_events",
            "type": "User",
            "site_admin": false
          },
          "assignees": [
            {
              "login": "ariard",
              "id": 23310655,
              "node_id": "MDQ6VXNlcjIzMzEwNjU1",
              "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/ariard",
              "html_url": "https://github.com/ariard",
              "followers_url": "https://api.github.com/users/ariard/followers",
              "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
              "organizations_url": "https://api.github.com/users/ariard/orgs",
              "repos_url": "https://api.github.com/users/ariard/repos",
              "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/ariard/received_events",
              "type": "User",
              "site_admin": false
            }
          ],
          "author_association": "NONE",
          "locked": false,
          "comments": 3,
          "closed_at": "2023-09-08T17:11:45Z",
          "created_at": "2023-06-29T17:15:56Z",
          "updated_at": "2023-09-08T17:11:45Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9720395713,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAJDYXfB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9720395713",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-04T10:48:30Z"
    },
    {
      "event": "commented",
      "id": 1620035096,
      "node_id": "IC_kwDOAN28mc5gj8YY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1620035096",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-04T11:02:23Z",
      "updated_at": "2023-07-04T11:02:23Z",
      "author_association": "MEMBER",
      "body": "I think I've addressed all comments now.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1620035096",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-04T11:03:14Z",
      "updated_at": "2023-07-04T11:03:14Z",
      "source": {
        "issue": {
          "id": 1724281348,
          "node_id": "PR_kwDOABII585RQ35P",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27742",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27742/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27742/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27742/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27742",
          "number": 27742,
          "state": "open",
          "state_reason": null,
          "title": "[NO MERGE] BIP331 Ancestor Package Relay",
          "body": "**WORK IN PROGRESS.** Please do not run it for any use other than testing.\r\n  \r\nThis PR is not meant for merge. This branch exists to help reviewers see what package relay would look like all together. I will open separate PRs for these components and expect to add more tests, docs, and polish along the way. This PR contains all of the functionality built in a linear manner. However, since there are pieces in various areas of the codebase and they can make progress in parallel, commits don't necessarily need to be merged in this order.\r\n\r\n**See #27463 for what PR(s) are open for review right now.**\r\n\r\n## Note to Reviewers\r\n\r\nThe major purpose of this PR is to solicit \"approach\" review.\r\n\r\nThis is a large project, and the first few p2p commits essentially define the interface. I'd like to get rough consensus on approach before we start looking at code details and merging PRs, because I believe it will help us \"get useful stuff in\" faster and avoid premature optimizations.\r\n\r\nHere are some questions I hope are answered before we try to merge anything (originally https://github.com/bitcoin/bitcoin/pull/27742#issuecomment-1572205313):\r\n\r\n1. Does the proposed protocol look sound?\r\n2. Are these 3 milestones appropriate?\r\n3. Is there important functionality that is in the \"todo improvements\" section but should be included in one of the 3 milestones? Alternatively, is there not-that-important stuff in the milestones that we should defer until later?\r\n4. Does it make sense to have this PeerManager <-> TxDownloadMan interface?\r\n\r\nComments about naming, typos, code details, etc. are also appreciated but please note I may wait until their respective PRs are open to incorporate your comments. Thank you for your patience.\r\n\r\n### Design Docs\r\n\r\nBIP: https://github.com/bitcoin/bips/pull/1382\r\nOrphanage changes: https://gist.github.com/glozow/7c0ff639f996e660146314edffa6f06c\r\n\r\n## Project Structure\r\n\r\n### 3 Major Milestones\r\n\r\nThis project is split into 3 milestones, each of which gives us something useful.\r\n\r\n1. Modularize and improve orphan-handling (also some refactoring).\r\n\t- Introduce a `TxDownloadManager` class, responsible for downloading transactions that have been announced to us.\r\n\t- Use all announcers as potential candidates for resolving an orphan. Add a `TxRequestTracker` Orphan Request Tracker which helps track orphans we need to resolve. Preferentially request orphan resolution from outbounds, preferred relay, etc., over inbounds.\r\n\r\n2. When package relay peers are available, use `ancpkginfo` instead of missing parents when handling orphans.\r\n\t- Add `sendpackages` negotiation logic.\r\n\t- Add a separate rejections filter for transactions that are eligible for reconsideration when validated together as a package, so that children of low-feerate transactions are still considered.\r\n\t- Send `getdata(MSG_ANCPKGINFO)` to package relay peers for orphan resolution. Use `ancpkginfo` to request missing ancestors through normal individual transaction relay.\r\n\r\n3. Download and validate ancestor packages using `getpkgtxns` and `pkgtxns`.\r\n\t- Add support for `getpkgtxns` and `pkgtxns`. Send a `pkgtxns` using the list of missing transactions from `ancpkginfo`.\r\n\t- Ensure we can process \"normal\" orphans even if a peer is trying to overwhelm/churn our orphanage. Do this by \"opportunistically\" protecting orphans from random eviction if they were sent by package relay peers, and redownloading orphans if we cannot afford to protect them. Each peer is allocated a certain amount of orphans they can protect at a time (\"token bucket\" style but the number of tokens is static for now). Outbound peers get more than inbounds.\r\n\t- If a transaction's parent(s) are below the fee filter, don't announce it (save the bandwidth of legacy nodes).\r\n\r\n###  Todo improvements \r\nThese could be added to the milestones or deferred until basic functionality is deployed.\r\n- Store orphans serialized instead of as CTransactionRefs to significantly reduce their memory usage.\r\n- Perhaps try to keep orphans in disk and/or process them asynchronously, given the incredibly DoSable nature of orphan handling.\r\n- Dynamically allocate tokens for orphan protection. For example, if a long-standing inbound peer continuously provides good packages for orphans, they should have more tokens. If a peer is obviously serving us garbage, reduce their tokens.\r\n- Detect when we have received all the transactions for a package, regardless of how (individual or block or other), and return `PackageToValidate`  in `GetTxToReconsider`.\r\n- New format for mempool.dat, packages instead of transactions.",
          "user": {
            "login": "glozow",
            "id": 25183001,
            "node_id": "MDQ6VXNlcjI1MTgzMDAx",
            "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/glozow",
            "html_url": "https://github.com/glozow",
            "followers_url": "https://api.github.com/users/glozow/followers",
            "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
            "organizations_url": "https://api.github.com/users/glozow/orgs",
            "repos_url": "https://api.github.com/users/glozow/repos",
            "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/glozow/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            },
            {
              "id": 5334691551,
              "node_id": "LA_kwDOABII588AAAABPfju3w",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/CI%20failed",
              "name": "CI failed",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 14,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27742",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27742",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27742.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27742.patch"
          },
          "created_at": "2023-05-24T15:38:55Z",
          "updated_at": "2024-03-16T00:09:18Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1517713387,
      "node_id": "PRR_kwDOAN28mc5adnfr",
      "url": null,
      "actor": null,
      "commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1517713387",
      "submitted_at": "2023-07-07T03:39:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "reviewed",
      "id": 1559745990,
      "node_id": "PRR_kwDOAN28mc5c99XG",
      "url": null,
      "actor": null,
      "commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK\r\n\r\nnits only ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1559745990",
      "submitted_at": "2023-08-02T21:21:29Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9997697621,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAJT6MJV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9997697621",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T11:07:03Z"
    },
    {
      "event": "reviewed",
      "id": 1560823749,
      "node_id": "PRR_kwDOAN28mc5dCEfF",
      "url": null,
      "actor": null,
      "commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Addressed the text-related comments",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1560823749",
      "submitted_at": "2023-08-03T11:07:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10021826010,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAAJVWO3a",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10021826010",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-07T09:40:20Z"
    },
    {
      "event": "commented",
      "id": 1667534408,
      "node_id": "IC_kwDOAN28mc5jZI5I",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1667534408",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-07T09:41:10Z",
      "updated_at": "2023-08-07T09:41:10Z",
      "author_association": "MEMBER",
      "body": "Changed combined hash to be single instead of double sha256",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1667534408",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "commented",
      "id": 1669773980,
      "node_id": "IC_kwDOAN28mc5jhrqc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1669773980",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T14:51:30Z",
      "updated_at": "2023-08-08T14:51:30Z",
      "author_association": "MEMBER",
      "body": "re-ACK https://github.com/bitcoin/bips/pull/1382/commits/02ec218c7857ef60914e9a3d383b68caf987f70b\r\n\r\nsuggested textual additions and change to single-sha2 for combined hash",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1669773980",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "commented",
      "id": 1895640693,
      "node_id": "IC_kwDOAN28mc5w_S51",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1895640693",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-17T11:44:22Z",
      "updated_at": "2024-01-17T11:44:22Z",
      "author_association": "MEMBER",
      "body": "@luke-jr @kallewoof is anything else needed here?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-1895640693",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 11510328873,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAKuEa4p",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11510328873",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-17T11:44:23Z"
    },
    {
      "event": "subscribed",
      "id": 11510328894,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAKuEa4-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11510328894",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-17T11:44:23Z"
    },
    {
      "event": "mentioned",
      "id": 11510328911,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAAKuEa5P",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11510328911",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-17T11:44:23Z"
    },
    {
      "event": "subscribed",
      "id": 11510328927,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAAKuEa5f",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/11510328927",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-17T11:44:23Z"
    },
    {
      "event": "reviewed",
      "id": 1899554781,
      "node_id": "PRR_kwDOAN28mc5xOOfd",
      "url": null,
      "actor": null,
      "commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Kampe",
        "id": 624150,
        "node_id": "MDQ6VXNlcjYyNDE1MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/624150?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kampe",
        "html_url": "https://github.com/Kampe",
        "followers_url": "https://api.github.com/users/Kampe/followers",
        "following_url": "https://api.github.com/users/Kampe/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kampe/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kampe/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kampe/subscriptions",
        "organizations_url": "https://api.github.com/users/Kampe/orgs",
        "repos_url": "https://api.github.com/users/Kampe/repos",
        "events_url": "https://api.github.com/users/Kampe/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kampe/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-1899554781",
      "submitted_at": "2024-02-24T19:02:00Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "commented",
      "id": 2049362394,
      "node_id": "IC_kwDOAN28mc56Jsna",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2049362394",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-11T10:10:46Z",
      "updated_at": "2024-04-11T10:10:46Z",
      "author_association": "MEMBER",
      "body": "@luke-jr pinging again, can we get this merged?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#issuecomment-2049362394",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1382"
    },
    {
      "event": "mentioned",
      "id": 12434353299,
      "node_id": "MEE_lADOAN28mc5T81tmzwAAAALlJSyT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12434353299",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-11T10:10:48Z"
    },
    {
      "event": "subscribed",
      "id": 12434353315,
      "node_id": "SE_lADOAN28mc5T81tmzwAAAALlJSyj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12434353315",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-11T10:10:48Z"
    },
    {
      "event": "reviewed",
      "id": 2004255882,
      "node_id": "PRR_kwDOAN28mc53doSK",
      "url": null,
      "actor": null,
      "commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "A couple of comments/nits I found when going over this",
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1382#pullrequestreview-2004255882",
      "submitted_at": "2024-04-16T18:09:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDkyYzA3ZjU3ZjRjY2IwOWRhOGY4ZWNkZTAxNDMyYTVhOWU2OGY1YTE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "tree": {
        "sha": "7ea74dc1331c863b8bed1d321c9e2bc717f86675",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/7ea74dc1331c863b8bed1d321c9e2bc717f86675"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/156e8aabe24c1253b38d61459791a939550a4b60",
          "sha": "156e8aabe24c1253b38d61459791a939550a4b60",
          "html_url": "https://github.com/bitcoin/bips/commit/156e8aabe24c1253b38d61459791a939550a4b60"
        }
      ],
      "message": "specify BIP331 Ancestor Package Relay",
      "committer": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2024-04-17T10:57:38Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2022-05-11T19:53:37Z"
      },
      "sha": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 12506104308,
      "node_id": "HRFPE_lADOAN28mc5T81tmzwAAAALpbAH0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/12506104308",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-04-17T10:57:57Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1012425379",
      "pull_request_review_id": 1166185447,
      "id": 1012425379,
      "node_id": "PRRC_kwDOAN28mc48WGKj",
      "diff_hunk": "@@ -0,0 +1,373 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-package-relay/tx_scenarios.png|800px]]\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-package-relay/no_package_info.png|900px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 142,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "112f8cc859d34b72f42708832172b09b70edfc05",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Need to update paths to images now that bip number is assigned",
      "created_at": "2022-11-03T01:25:37Z",
      "updated_at": "2022-11-03T01:25:37Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1012425379",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1012425379"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1013082139",
      "pull_request_review_id": 1167193398,
      "id": 1013082139,
      "node_id": "PRRC_kwDOAN28mc48Ymgb",
      "diff_hunk": "@@ -0,0 +1,373 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-package-relay/tx_scenarios.png|800px]]\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-package-relay/no_package_info.png|900px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 142,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "112f8cc859d34b72f42708832172b09b70edfc05",
      "in_reply_to_id": 1012425379,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Doh, thanks!",
      "created_at": "2022-11-03T15:45:28Z",
      "updated_at": "2022-11-03T15:45:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1013082139",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1013082139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144892783",
      "pull_request_review_id": 1352700273,
      "id": 1144892783,
      "node_id": "PRRC_kwDOAN28mc5EPa1v",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 93,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\noutput(s) from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have just\r\n```",
      "created_at": "2023-03-22T14:20:38Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144892783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144892783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144893395",
      "pull_request_review_id": 1352700273,
      "id": 1144893395,
      "node_id": "PRRC_kwDOAN28mc5EPa_T",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 100,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nnetwork and it relies on txid-based relay between two wtxid-relay peers.\r\n```",
      "created_at": "2023-03-22T14:20:59Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144893395",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144893395"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 100,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144894209",
      "pull_request_review_id": 1352700273,
      "id": 1144894209,
      "node_id": "PRRC_kwDOAN28mc5EPbMB",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 113,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"an ordered list\". Is there a well-defined ordering? What is it?",
      "created_at": "2023-03-22T14:21:32Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144894209",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144894209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 113,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144894559",
      "pull_request_review_id": 1352700273,
      "id": 1144894559,
      "node_id": "PRRC_kwDOAN28mc5EPbRf",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 136,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\r\n```",
      "created_at": "2023-03-22T14:21:48Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144894559",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144894559"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144895461",
      "pull_request_review_id": 1352700273,
      "id": 1144895461,
      "node_id": "PRRC_kwDOAN28mc5EPbfl",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 134,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why not make the transactions' virtual size 1kvB to make the math super easy?",
      "created_at": "2023-03-22T14:22:23Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144895461",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144895461"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144897484",
      "pull_request_review_id": 1352700273,
      "id": 1144897484,
      "node_id": "PRRC_kwDOAN28mc5EPb_M",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+",
      "path": "bip-0331.mediawiki",
      "position": 142,
      "original_position": 138,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n< br/>\r\n```\r\n\r\nThe line below (\"No Package Information Round...\") wraps strangely on certain resolution displays. The \"No Package\" appears to the right of the image and then there's a new line for \"Information Round...\". I think you can force a line break so that the text appears on a new line.",
      "created_at": "2023-03-22T14:23:45Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144897484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144897484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144898222",
      "pull_request_review_id": 1352700273,
      "id": 1144898222,
      "node_id": "PRRC_kwDOAN28mc5EPcKu",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+",
      "path": "bip-0331.mediawiki",
      "position": 151,
      "original_position": 143,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As above, force a newline here:\r\n\r\n```suggestion\r\n<br />\r\n```",
      "created_at": "2023-03-22T14:24:14Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144898222",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144898222"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144898872",
      "pull_request_review_id": 1352700273,
      "id": 1144898872,
      "node_id": "PRRC_kwDOAN28mc5EPcU4",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?'''No. If the low-feerate transaction was sent because it wasn't",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 164,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nrequired for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\r\n```",
      "created_at": "2023-03-22T14:24:36Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144898872",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144898872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144899277",
      "pull_request_review_id": 1352700273,
      "id": 1144899277,
      "node_id": "PRRC_kwDOAN28mc5EPcbN",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?'''No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon reeipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 274,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\r\n```",
      "created_at": "2023-03-22T14:24:49Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144899277",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144899277"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144902863",
      "pull_request_review_id": 1352700273,
      "id": 1144902863,
      "node_id": "PRRC_kwDOAN28mc5EPdTP",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?'''No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon reeipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" should never be sent.\n+\n+# This inv type should only be used if both peers agreed to send version 0 packages. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x7) is added, for use only in \"notfound\" messages pertaining to\n+package transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 336,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# A new inv type (MSG_PKGTXNS == 0x7) is added, for use only in \"notfound\" messages pertaining to package transactions.\r\n```",
      "created_at": "2023-03-22T14:26:44Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144902863",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144902863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": 335,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 336,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144911353",
      "pull_request_review_id": 1352700273,
      "id": 1144911353,
      "node_id": "PRRC_kwDOAN28mc5EPfX5",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?'''No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 208,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Which hash function?",
      "created_at": "2023-03-22T14:31:53Z",
      "updated_at": "2023-03-22T14:35:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144911353",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144911353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144916422",
      "pull_request_review_id": 1352700273,
      "id": 1144916422,
      "node_id": "PRRC_kwDOAN28mc5EPgnG",
      "diff_hunk": "@@ -0,0 +1,391 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend\n+output(s) from a transaction they are unaware of.  Orphans are common for new nodes that have just\n+completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is an ordered list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are the same size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?'''No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon reeipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 319,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "2f65ad1658c4b18c32765455bb844ad771cc36ca",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It'd be good to explicitly define what a \"version 0 package\" is in this doc.",
      "created_at": "2023-03-22T14:35:10Z",
      "updated_at": "2023-03-22T14:35:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1144916422",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1144916422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 323,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155685642",
      "pull_request_review_id": 1368605053,
      "id": 1155685642,
      "node_id": "PRRC_kwDOAN28mc5E4l0K",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 30,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps \"the same contents\" -> \"similar contents\". I think that better conveys that there's a spectrum, where the closer you are to the miners' mempools, the more benefit you get from compact block relay and fee estimation.",
      "created_at": "2023-04-03T09:05:49Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155685642",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155685642"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155688831",
      "pull_request_review_id": 1368605053,
      "id": 1155688831,
      "node_id": "PRRC_kwDOAN28mc5E4ml_",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 66,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\noverestimating fees may sidestep this issue (at least while mempool traffic is low and\r\n```\r\n\r\nI think the word 'temporarily' here could be misinterpreted.",
      "created_at": "2023-04-03T09:08:37Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155688831",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155688831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155693083",
      "pull_request_review_id": 1368605053,
      "id": 1155693083,
      "node_id": "PRRC_kwDOAN28mc5E4nob",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 64,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps prefer \"forecast\" as the past of \"forecast\":\r\n\r\n```suggestion\r\nare negotiated well ahead of broadcast time. If the forecast feerate was too low and no\r\n```\r\n\r\n(both \"forecast\" and \"forecasted\" are acceptable forms for the past participle, but \"forecast\" seems to be more common)",
      "created_at": "2023-04-03T09:12:12Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155693083",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155693083"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155694580",
      "pull_request_review_id": 1368605053,
      "id": 1155694580,
      "node_id": "PRRC_kwDOAN28mc5E4n_0",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 67,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps \"foolproof\" -> \"guaranteed to work\". \"foolproof\" implies more user error to me, whereas this method may fail due to circumstances outside the user's control.",
      "created_at": "2023-04-03T09:13:31Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155694580",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155694580"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 67,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155697432",
      "pull_request_review_id": 1368605053,
      "id": 1155697432,
      "node_id": "PRRC_kwDOAN28mc5E4osY",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 82,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Does the \"related\" refer to \"package validation\"? If yes, I think this is better:\r\n\r\n```suggestion\r\nsuggests adding new p2p messages enabling nodes to request and share package-validation-related\r\n```",
      "created_at": "2023-04-03T09:16:02Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155697432",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155697432"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155698357",
      "pull_request_review_id": 1368605053,
      "id": 1155698357,
      "node_id": "PRRC_kwDOAN28mc5E4o61",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 93,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nfrom an unconfirmed transaction the receiving node is unaware of.  Orphans are common for new nodes that have\r\n```",
      "created_at": "2023-04-03T09:16:53Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155698357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155698357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155703244",
      "pull_request_review_id": 1368605053,
      "id": 1155703244,
      "node_id": "PRRC_kwDOAN28mc5E4qHM",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 137,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You still need to update the values in these bullet points and the image. Also, the image says the virtual size is 1600Wu, but virtual size should be in vB. I'd also remove the \"size\" from the image.",
      "created_at": "2023-04-03T09:21:20Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155703244",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155703244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155720539",
      "pull_request_review_id": 1368605053,
      "id": 1155720539,
      "node_id": "PRRC_kwDOAN28mc5E4uVb",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 138,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorry, I got the whitespace wrong in my review comment. It should be:\r\n\r\n```suggestion\r\n<br />\r\n```\r\n\r\nSame on line 144 below.",
      "created_at": "2023-04-03T09:36:30Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155720539",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155720539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155725057",
      "pull_request_review_id": 1368605053,
      "id": 1155725057,
      "node_id": "PRRC_kwDOAN28mc5E4vcB",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 210,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you should include the name of the hash function in this definition.",
      "created_at": "2023-04-03T09:40:29Z",
      "updated_at": "2023-04-21T10:31:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155725057",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155725057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155726292",
      "pull_request_review_id": 1368605053,
      "id": 1155726292,
      "node_id": "PRRC_kwDOAN28mc5E4vvU",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nmore low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\r\n```",
      "created_at": "2023-04-03T09:41:33Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155726292",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155726292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155726898",
      "pull_request_review_id": 1368605053,
      "id": 1155726898,
      "node_id": "PRRC_kwDOAN28mc5E4v4y",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 154,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nUpon receiving an orphan transaction, a node may request ancestor package information delineating the wtxids\r\n```",
      "created_at": "2023-04-03T09:42:05Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155726898",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155726898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155738712",
      "pull_request_review_id": 1368605053,
      "id": 1155738712,
      "node_id": "PRRC_kwDOAN28mc5E4yxY",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 124,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd add a sentence here along the lines of \"This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate descendant paying for low-feerate ancestors).\" and then have sub-headings for \"orphan transaction handling\", \"high-feerate descendants\" and \"feature negotiation\" below. Without the sub-headings, it's a bit difficult to follow the structure of the doc.",
      "created_at": "2023-04-03T09:52:47Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155738712",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155738712"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 131,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155740400",
      "pull_request_review_id": 1368605053,
      "id": 1155740400,
      "node_id": "PRRC_kwDOAN28mc5E4zLw",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 164,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nhigh-feerate transaction ''will'' be sent by the sender, and received and handled as an orphan by the receiver. The transactions are validated as a\r\n```",
      "created_at": "2023-04-03T09:54:19Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155740400",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155740400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155741450",
      "pull_request_review_id": 1368605053,
      "id": 1155741450,
      "node_id": "PRRC_kwDOAN28mc5E4zcK",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 165,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I suggest you bring this into the main body of this section rather than have it as a footnote.",
      "created_at": "2023-04-03T09:55:17Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155741450",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155741450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155748078",
      "pull_request_review_id": 1368605053,
      "id": 1155748078,
      "node_id": "PRRC_kwDOAN28mc5E41Du",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====",
      "path": "bip-0331.mediawiki",
      "position": 264,
      "original_position": 286,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would it make sense to put this above the definition of \"getpkgtxns\"? \"ancpkginfo comes first both sequentially in the protocol flow and alphabetically.",
      "created_at": "2023-04-03T10:00:59Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155748078",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155748078"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 264,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155751181",
      "pull_request_review_id": 1368605053,
      "id": 1155751181,
      "node_id": "PRRC_kwDOAN28mc5E410N",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 331,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\r\n```",
      "created_at": "2023-04-03T10:03:57Z",
      "updated_at": "2023-04-03T10:40:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155751181",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155751181"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155751864",
      "pull_request_review_id": 1368605053,
      "id": 1155751864,
      "node_id": "PRRC_kwDOAN28mc5E41-4",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 331,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\r\n```",
      "created_at": "2023-04-03T10:04:37Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155751864",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155751864"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155753255",
      "pull_request_review_id": 1368605053,
      "id": 1155753255,
      "node_id": "PRRC_kwDOAN28mc5E42Un",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 331,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think \"The node should not assume that the sender is requesting the transaction data as well.\" is unnecessary, since the description of the protocol above has already specified that the protocol has separate package information and transaction data rounds.",
      "created_at": "2023-04-03T10:06:03Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155753255",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155753255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155755567",
      "pull_request_review_id": 1368605053,
      "id": 1155755567,
      "node_id": "PRRC_kwDOAN28mc5E424v",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" should never be sent.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 333,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What should happen if a node receives an `inv(MSG_ANCPKGINFO)`? Drop/ignore the message or disconnect/punish?",
      "created_at": "2023-04-03T10:08:16Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155755567",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155755567"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155769723",
      "pull_request_review_id": 1368605053,
      "id": 1155769723,
      "node_id": "PRRC_kwDOAN28mc5E46V7",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 319,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This seems to slightly contradict the \"Should a peer be punished if they provide incorrect package info\" footnote, or am I misunderstanding?",
      "created_at": "2023-04-03T10:20:59Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155769723",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155769723"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 319,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155771108",
      "pull_request_review_id": 1368605053,
      "id": 1155771108,
      "node_id": "PRRC_kwDOAN28mc5E46rk",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" should never be sent.\n+\n+# This inv type should only be used if both peers agreed to send version 0 packages. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 335,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps:\r\n\r\n```suggestion\r\n# This inv type should only be used if both peers agreed to send version 0 packages. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\r\n```",
      "created_at": "2023-04-03T10:22:26Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155771108",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155771108"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 335,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155772456",
      "pull_request_review_id": 1368605053,
      "id": 1155772456,
      "node_id": "PRRC_kwDOAN28mc5E47Ao",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 323,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This seems slightly redundant with the point above. If package relay has not been negotiated, then the peer shouldn't have sent a `getdata(MSG_ANCPKGINFO)`",
      "created_at": "2023-04-03T10:23:52Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155772456",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155772456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 323,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155776769",
      "pull_request_review_id": 1368605053,
      "id": 1155776769,
      "node_id": "PRRC_kwDOAN28mc5E48EB",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 259,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If I read this bullet point and footnote literally, it says that *all* nodes *must* respond to `getpkgtxns` messages, _even if they haven't negotiated package relay_. That seems wrong. It means that all existing nodes on the network would be in violation of this rule.",
      "created_at": "2023-04-03T10:26:11Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155776769",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155776769"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155778414",
      "pull_request_review_id": 1368605053,
      "id": 1155778414,
      "node_id": "PRRC_kwDOAN28mc5E48du",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 191,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this be version=0?",
      "created_at": "2023-04-03T10:27:49Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155778414",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155778414"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155782599",
      "pull_request_review_id": 1368605053,
      "id": 1155782599,
      "node_id": "PRRC_kwDOAN28mc5E49fH",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 243,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it'd be better to pull this definition out and make it more explicit. It'd also be useful to distinguish between the parts of this proposal that are specific to version 0 (`MSG_ANCPKGINFO` and `ancpkginfo`) and the parts that are generic to any kind of package (`sendpackages`, `getpkgtxns`, `pkgtxns` and `MSG_PKGTXNS`)",
      "created_at": "2023-04-03T10:32:07Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155782599",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155782599"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155783694",
      "pull_request_review_id": 1368605053,
      "id": 1155783694,
      "node_id": "PRRC_kwDOAN28mc5E49wO",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" should never be sent.\n+\n+# This inv type should only be used if both peers agreed to send version 0 packages. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x7) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined sha256 hash of the wtxids in the getpkgtxns request.\n+\n+# This inv type should only be used in \"notfound\" messages, i.e. \"inv(MSG_PKGTXNS)\" and \"getdata(MSG_PKGTXNS)\" should never be sent.\n+\n+\n+==Compatibility==\n+\n+Older clients remain fully compatible and interoperable after this change. Clients implementing this\n+protocol will only attempt to send and request packages if agreed upon during the version handshake.\n+<ref>'''Will package relay cause non-package relay nodes to waste bandwidth on low-feerate transactions?'''\n+If a node supports package relay, it may accept low-feerate transactions (e.g. paying zero fees)\n+into its mempool, but non-package relay nodes would most likely reject them. To mitigate bandwidth\n+waste, a package relay node should probably not announce descendants of below-fee-filter",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 353,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can we remove \"probably\" here?",
      "created_at": "2023-04-03T10:33:18Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155783694",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155783694"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155789872",
      "pull_request_review_id": 1368605053,
      "id": 1155789872,
      "node_id": "PRRC_kwDOAN28mc5E4_Qw",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" should never be sent.\n+\n+# This inv type should only be used if both peers agreed to send version 0 packages. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x7) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined sha256 hash of the wtxids in the getpkgtxns request.\n+\n+# This inv type should only be used in \"notfound\" messages, i.e. \"inv(MSG_PKGTXNS)\" and \"getdata(MSG_PKGTXNS)\" should never be sent.\n+\n+\n+==Compatibility==\n+\n+Older clients remain fully compatible and interoperable after this change. Clients implementing this\n+protocol will only attempt to send and request packages if agreed upon during the version handshake.\n+<ref>'''Will package relay cause non-package relay nodes to waste bandwidth on low-feerate transactions?'''\n+If a node supports package relay, it may accept low-feerate transactions (e.g. paying zero fees)\n+into its mempool, but non-package relay nodes would most likely reject them. To mitigate bandwidth\n+waste, a package relay node should probably not announce descendants of below-fee-filter\n+transactions to non-package relay peers.\n+</ref>\n+<ref>'''Is Package Erlay possible?'''\n+A client using BIP330 reconciliation-based transaction relay (Erlay) is able to use package relay\n+without interference. After reconciliation, any transactions with unconfirmed ancestors may be\n+relayed using ancestor package relay.\n+[[File:./bip-0331/package_erlay.png|800px]]\n+</ref>\n+\n+==Implementation==\n+\n+Implementation for Bitcoin Core: https://github.com/glozow/bitcoin/tree/2023-01-package-relay\n+\n+Caveat: the crux of package relay is a mempool policy that works.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 367,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Caveat/crux/\"that works\" all feel a bit informal/imprecise. Perhaps:\r\n\r\n```suggestion\r\nSample implementation for Bitcoin Core: https://github.com/glozow/bitcoin/tree/2023-01-package-relay. A prerequisite for implementing a safe package relay protocol is to have a mempool acceptance policy that is able to safely validate packages of transactions.\r\n```",
      "created_at": "2023-04-03T10:40:00Z",
      "updated_at": "2023-04-03T10:40:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1155789872",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1155789872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": 365,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 367,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156046406",
      "pull_request_review_id": 1369166545,
      "id": 1156046406,
      "node_id": "PRRC_kwDOAN28mc5E595G",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 115,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nIn this proposal, a package is limited to unconfirmed transactions.\r\n```",
      "created_at": "2023-04-03T14:29:41Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156046406",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156046406"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156060166",
      "pull_request_review_id": 1369166545,
      "id": 1156060166,
      "node_id": "PRRC_kwDOAN28mc5E6BQG",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 159,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it's supposed to be `getdata(MSG_ANCPKGINFO, ...)` instead of `getdata(ANCPKGINFO, ...)`?",
      "created_at": "2023-04-03T14:40:17Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156060166",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156060166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156068254",
      "pull_request_review_id": 1369166545,
      "id": 1156068254,
      "node_id": "PRRC_kwDOAN28mc5E6DOe",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 159,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156060166,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also general comment: perhaps figure annotations would be helpful?",
      "created_at": "2023-04-03T14:46:28Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156068254",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156068254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156222599",
      "pull_request_review_id": 1369166545,
      "id": 1156222599,
      "node_id": "PRRC_kwDOAN28mc5E6o6H",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 210,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1155725057,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we use a BIP340 tagged hash here? (I'm not sure, thinking out loud). For example, could be relevant for [these rolling bloom filters](https://gist.github.com/glozow/8469dc9c3a003c7046033a92dd504329#:~:text=For%20packages%20and%20sub%2Dpackages%20that%20fail%2C%20add%20the%20transaction%20group%20by%20hashing%20the%20wtxids%20of%20each%20of%20the%20transactions%2C%20sorted%20lexicographically.%20Ensure%20that%20each%20group%20is%20itself%20an%20ancestor%20package.%20When%20a%20package%20is%20partially%20submitted%2C%20exclude%20the%20transactions%20that%20ended%20up%20in%20the%20mempool.) that contain hashes corresponding to both txes and packages?",
      "created_at": "2023-04-03T16:59:29Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156222599",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156222599"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 225,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156233612",
      "pull_request_review_id": 1369166545,
      "id": 1156233612,
      "node_id": "PRRC_kwDOAN28mc5E6rmM",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 223,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If `version` is a `uint32_t`, it seems to indicate that we want to leave room for a significant amount more package versions (and even if we don't, it's an infrequently sent message, so no biggie to have this be oversized). In that light, would it make sense to have instead have a `versions` `array<uint32_t>`, so in a future with lots of possible package versions we don't need to flood `sendpackages` messages, and making it an array now is not a lot of overhead?\r\n\r\nI'd be surprised if we end up with a huge number of package versions so I'm probably exaggerating here, but I think even for a small number of versions it makes sense, since the expectation is that we'll have multiple versions?",
      "created_at": "2023-04-03T17:11:05Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156233612",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156233612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156236321",
      "pull_request_review_id": 1369166545,
      "id": 1156236321,
      "node_id": "PRRC_kwDOAN28mc5E6sQh",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 236,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is inconsistent with [Erlay behaviour](https://github.com/bitcoin/bips/blob/master/bip-0330.mediawiki#sendtxrcncl:~:text=If%20%22sendtxrcncl%22%20was%20sent%20before%20%22verack%22%2C%20but%20by%20%22verack%22%20the%20%22wtxidrelay%22%20message%20was%20not%20received%2C%20%22sendtxrcncl%22%20should%20be%20ignored.%20The%20connection%20should%20proceed%20normally%2C%20but%20as%20if%20reconciliation%20was%20not%20supported.). I think I prefer the \"may be disconnected\" approach, but just flagging that since ideally they're aligned?",
      "created_at": "2023-04-03T17:13:51Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156236321",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156236321"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": 235,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156262597",
      "pull_request_review_id": 1369166545,
      "id": 1156262597,
      "node_id": "PRRC_kwDOAN28mc5E6yrF",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 223,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156233612,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a shame we can't version `getdata` messages, because then we could have a generic `MSG_PKGINFO` (and `MSG_PKGTXNS` INV type, and use the same version that we announce in `sendpackages`. That would avoid having to create a new INV type for every package version.\r\n\r\nI think we can make things more consistent by having the `version(s)` field in `sendpackages` correspond to the INV type, though? I.e. instead of `version=0` we'd use `version=0x6` for ancestor packages?",
      "created_at": "2023-04-03T17:39:18Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156262597",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156262597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156267093",
      "pull_request_review_id": 1369166545,
      "id": 1156267093,
      "node_id": "PRRC_kwDOAN28mc5E6zxV",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" should never be sent.\n+\n+# This inv type should only be used if both peers agreed to send version 0 packages. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x7) is added, for use only in \"notfound\" messages pertaining to package transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 339,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "supernit: I know it _really_ doesn't matter, and yet it feels so much cleaner if the version-less `MSG_PKGTXNS` has the lower number `(0x6)` so all the package-specific invs can increase from there? (i.e. `MSG_ANCPKGINFO (0x7)`)",
      "created_at": "2023-04-03T17:44:08Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156267093",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156267093"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 356,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156273895",
      "pull_request_review_id": 1369166545,
      "id": 1156273895,
      "node_id": "PRRC_kwDOAN28mc5E61bn",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====",
      "path": "bip-0331.mediawiki",
      "position": 264,
      "original_position": 286,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we want to redefine a package info message for every package version? Could also use a generic `pkginfo` with `version` field matching the one in `sendpackages`? ",
      "created_at": "2023-04-03T17:51:28Z",
      "updated_at": "2023-04-03T18:50:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156273895",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156273895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 264,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156976942",
      "pull_request_review_id": 1370565687,
      "id": 1156976942,
      "node_id": "PRRC_kwDOAN28mc5E9hEu",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 34,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You could consider re-wording this to:\r\n\r\n\"Individually considering transactions for submission to the mempool creates a limitation...\"",
      "created_at": "2023-04-04T09:25:28Z",
      "updated_at": "2023-04-04T13:37:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156976942",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156976942"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156982266",
      "pull_request_review_id": 1370565687,
      "id": 1156982266,
      "node_id": "PRRC_kwDOAN28mc5E9iX6",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 42,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it's alluded to, but perhaps it's worth clarifying that they also currently cannot submit the high-fee descendant first, followed by the low-fee ancestor?",
      "created_at": "2023-04-04T09:30:02Z",
      "updated_at": "2023-04-04T13:37:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156982266",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156982266"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156989061",
      "pull_request_review_id": 1370565687,
      "id": 1156989061,
      "node_id": "PRRC_kwDOAN28mc5E9kCF",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 115,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156046406,
      "user": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What happens if my node sends a package including a confirmed ancestor transaction?",
      "created_at": "2023-04-04T09:35:53Z",
      "updated_at": "2023-04-04T13:37:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156989061",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156989061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156997032",
      "pull_request_review_id": 1370565687,
      "id": 1156997032,
      "node_id": "PRRC_kwDOAN28mc5E9l-o",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 137,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1155703244,
      "user": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If it doesn't clutter it too much it might also be nice to add the package feerates? Although they are simple enough to calculate too...",
      "created_at": "2023-04-04T09:42:45Z",
      "updated_at": "2023-04-04T13:37:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1156997032",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1156997032"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1157005586",
      "pull_request_review_id": 1370565687,
      "id": 1157005586,
      "node_id": "PRRC_kwDOAN28mc5E9oES",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 163,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nlow-feerate transaction is below the node's fee filter, the sender will not announce it. The\r\n```",
      "created_at": "2023-04-04T09:49:57Z",
      "updated_at": "2023-04-04T13:37:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1157005586",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1157005586"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1157014503",
      "pull_request_review_id": 1370565687,
      "id": 1157014503,
      "node_id": "PRRC_kwDOAN28mc5E9qPn",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 188,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought that a decent middle-ground could be to apply something like the following:\r\n\r\n* If you receive a package initially, you proactively re-broadcast it as a package to your peers.\r\n* If you recieve an orphan and end up requesting a package, you re-broadcast the orphan and not the package.\r\n\r\nThis way you still retain some bandwidth minimisation, whilst also being somewhat proactive about broadcasting packages and reducing the # of roundtrips. Also it places the onus on the (original) sender to be broadcasting as a package if they want it relayed (as quickly as possible) as a package to the network.\r\n\r\nBut in thinking it through more, this could permit malicious nodes to start sending many large packages around unsolicited wasting the bandwidth of our P2P network...\r\n\r\nTherefore I agree that reciever-initiated makes the most sense here.",
      "created_at": "2023-04-04T09:57:37Z",
      "updated_at": "2023-04-04T13:37:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1157014503",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1157014503"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 203,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1157043078",
      "pull_request_review_id": 1370565687,
      "id": 1157043078,
      "node_id": "PRRC_kwDOAN28mc5E9xOG",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 208,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": null,
      "user": {
        "login": "willcl-ark",
        "id": 6606587,
        "node_id": "MDQ6VXNlcjY2MDY1ODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6606587?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/willcl-ark",
        "html_url": "https://github.com/willcl-ark",
        "followers_url": "https://api.github.com/users/willcl-ark/followers",
        "following_url": "https://api.github.com/users/willcl-ark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/willcl-ark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/willcl-ark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/willcl-ark/subscriptions",
        "organizations_url": "https://api.github.com/users/willcl-ark/orgs",
        "repos_url": "https://api.github.com/users/willcl-ark/repos",
        "events_url": "https://api.github.com/users/willcl-ark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/willcl-ark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What exactly is this combined hash for -- is it only used in the `inv(MSG_PKGTXNS)` message?\r\n\r\nMy understanding is that we are referring to packages by the child `wtxid`?",
      "created_at": "2023-04-04T10:24:27Z",
      "updated_at": "2023-04-04T13:37:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1157043078",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1157043078"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1157309767",
      "pull_request_review_id": 1371074208,
      "id": 1157309767,
      "node_id": "PRRC_kwDOAN28mc5E-yVH",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 208,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1157043078,
      "user": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think one use case to unambiguously determine if we've already validated (/rejected) a certain (exact) package as per [this comment](https://gist.github.com/glozow/8469dc9c3a003c7046033a92dd504329#:~:text=For%20packages%20and%20sub%2Dpackages%20that%20fail%2C%20add%20the%20transaction%20group%20by%20hashing%20the%20wtxids%20of%20each%20of%20the%20transactions%2C%20sorted%20lexicographically.%20Ensure%20that%20each%20group%20is%20itself%20an%20ancestor%20package.%20When%20a%20package%20is%20partially%20submitted%2C%20exclude%20the%20transactions%20that%20ended%20up%20in%20the%20mempool.)",
      "created_at": "2023-04-04T14:04:28Z",
      "updated_at": "2023-04-04T14:04:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1157309767",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1157309767"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1158706782",
      "pull_request_review_id": 1373213703,
      "id": 1158706782,
      "node_id": "PRRC_kwDOAN28mc5FEHZe",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 259,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1155776769,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes my bad, a node *should* respond.",
      "created_at": "2023-04-05T15:47:44Z",
      "updated_at": "2023-04-05T15:47:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1158706782",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1158706782"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 259,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1158708717",
      "pull_request_review_id": 1373216624,
      "id": 1158708717,
      "node_id": "PRRC_kwDOAN28mc5FEH3t",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 115,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156046406,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> What happens if my node sends a package including a confirmed ancestor transaction?\r\n\r\nThe receiver should be able to deal with it. It is not a violation to do so, as you might just have different chainstates.",
      "created_at": "2023-04-05T15:49:20Z",
      "updated_at": "2023-04-05T15:49:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1158708717",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1158708717"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 115,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1158711561",
      "pull_request_review_id": 1373220844,
      "id": 1158711561,
      "node_id": "PRRC_kwDOAN28mc5FEIkJ",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====",
      "path": "bip-0331.mediawiki",
      "position": 264,
      "original_position": 286,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156273895,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Do we want to redefine a package info message for every package version? \r\n\r\nYes\r\n\r\n> Could also use a generic pkginfo with version field matching the one in sendpackages?\r\n\r\nI think it makes more sense to have a separate protocol message for separate things than to add 4-byte overhead on *every* package info message.",
      "created_at": "2023-04-05T15:51:47Z",
      "updated_at": "2023-04-05T15:51:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1158711561",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1158711561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 264,
      "original_line": 264,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1158714337",
      "pull_request_review_id": 1373226113,
      "id": 1158714337,
      "node_id": "PRRC_kwDOAN28mc5FEJPh",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 208,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1157043078,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, the combined hash is only used in `notfound(MSG_PKGTXNS)`.\r\n\r\nWe cannot use the child wtxid because the child wtxid is not included in the `getpkgtxns` request.",
      "created_at": "2023-04-05T15:54:06Z",
      "updated_at": "2023-04-05T15:54:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1158714337",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1158714337"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 223,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1173605835",
      "pull_request_review_id": 1395510867,
      "id": 1173605835,
      "node_id": "PRRC_kwDOAN28mc5F883L",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 223,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156233612,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I agree that having space for 4294967295 package versions is probably more than we'll ever need.\r\n\r\nAn alternative would be to treat this as a bit field, in the way that `nServices` flags are signalled in the version message. This BIP would define version `(1 << 0)` and future versions would be defined as `(1 << n)`. When we receive a `sendpackages` message, we XOR the received versions with the received versions from previous `sendpackages` messages.",
      "created_at": "2023-04-21T10:22:32Z",
      "updated_at": "2023-04-21T10:22:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1173605835",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1173605835"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1173944978",
      "pull_request_review_id": 1396037417,
      "id": 1173944978,
      "node_id": "PRRC_kwDOAN28mc5F-PqS",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 223,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156233612,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes I think a bitfield is best :+1: 32 package versions seems plenty, and this makes the implementation cleaner as well.",
      "created_at": "2023-04-21T16:06:07Z",
      "updated_at": "2023-04-21T16:06:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1173944978",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1173944978"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 238,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436362",
      "pull_request_review_id": 1396758139,
      "id": 1174436362,
      "node_id": "PRRC_kwDOAN28mc5GAHoK",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 236,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156236321,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed",
      "created_at": "2023-04-22T16:37:17Z",
      "updated_at": "2023-04-22T16:37:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1174436362",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436362"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": 235,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 257,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436390",
      "pull_request_review_id": 1396758181,
      "id": 1174436390,
      "node_id": "PRRC_kwDOAN28mc5GAHom",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# A \"ancpkginfo\" message should only be sent if both peers agreed to send version 0 packages. If a \"ancpkginfo\" message is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x6) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request for, the node should respond with the \"ancpkginfo\" corresponding to the transaction's unconfirmed ancestor package, or with NOTFOUND.  The wtxid of the requested transaction should be the last item in the list. The node should not assume that the sender is requesting the transaction data as well.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" should never be sent.\n+\n+# This inv type should only be used if both peers agreed to send version 0 packages. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x7) is added, for use only in \"notfound\" messages pertaining to package transactions.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 339,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156267093,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done, I like it better too :)",
      "created_at": "2023-04-22T16:37:41Z",
      "updated_at": "2023-04-22T16:37:41Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1174436390",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436390"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 356,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436514",
      "pull_request_review_id": 1396758260,
      "id": 1174436514,
      "node_id": "PRRC_kwDOAN28mc5GAHqi",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 159,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1156060166,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I omit the `MSG` because all the inv types have it",
      "created_at": "2023-04-22T16:38:26Z",
      "updated_at": "2023-04-22T16:38:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1174436514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436559",
      "pull_request_review_id": 1396758274,
      "id": 1174436559,
      "node_id": "PRRC_kwDOAN28mc5GAHrP",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 243,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1155782599,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done",
      "created_at": "2023-04-22T16:38:37Z",
      "updated_at": "2023-04-22T16:38:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1174436559",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436559"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436726",
      "pull_request_review_id": 1396758611,
      "id": 1174436726,
      "node_id": "PRRC_kwDOAN28mc5GAHt2",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 137,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1155703244,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ended up removing this as I don't think it was adding very much",
      "created_at": "2023-04-22T16:39:41Z",
      "updated_at": "2023-04-22T16:39:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1174436726",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436726"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436933",
      "pull_request_review_id": 1396758764,
      "id": 1174436933,
      "node_id": "PRRC_kwDOAN28mc5GAHxF",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with the same contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only considering transactions one at a time for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html RBF Pinning with Counterparties and Competing Interest]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Pinning : The Good, The Bad, The Ugly]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md T-bast's Pinning Attacks Document]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Eltoo Pinning]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecasted feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue temporarily (while mempool traffic is low and\n+predictable), but this solution is not foolproof and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools,\n+which is an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee parent transactions with a high-fee child, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from a transaction the receiving node is unaware of.  Orphans are common for new nodes that have\n+just completed Initial Block Download (IBD) and do not have an up-to-date mempool.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+Typically, a package refers to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+\n+Package Relay consists of two phases: a package information round and a transaction data round.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+For example, consider the following scenarios (where the mempool minimum feerate is 3sat/vB and all\n+transactions are 1000vB in size):\n+\n+* Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in fees.\n+* Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in fees.\n+* Package {E, F, G, H, J} that pay 4000, 8000, 0, 2000, and 4000 satoshis in fees, respectively.\n+[[File:./bip-0331/tx_scenarios.png|800px]]\n+< br/>\n+\n+'''No Package Information Round:''' Instead of having a package information round, just use the\n+child's wtxid to refer to the package and always send the entire package together. This would make\n+it very likely for honest nodes to redownload duplicate transactions.\n+[[File:./bip-0331/no_package_info.png|900px]]\n+< br/>\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a good fallback if batched\n+transaction download fails for some reason, it shouldn't be used as the default because it always\n+requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1200px]]\n+</ref>\n+\n+Upon encountering an orphan, a node may request ancestor package information delineating the wtxids\n+of the transaction's unconfirmed ancestors. This is done without using txid-based relay. The package\n+information can be used to request transaction data. As these transactions are dependent upon one\n+another to be valid, the transactions can be requested and sent as a batch.\n+\n+[[File:./bip-0331/protocol_flow.png|1200px]]\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filer, the sender will not announce it. The\n+high-feerate transaction is seen and handled as an orphan, the transactions are validated as a\n+package, and so the protocol naturally works for this use case.<ref>'''Does this mean BIP133 is\n+required for package relay to work?''' No. If the low-feerate transaction was sent because it wasn't\n+filtered out for being too-low-feerate, the receiver will reject it and then request it again after\n+learning that it is the ancestor of the high-feerate transaction.</ref>\n+\n+[[File:./bip-0331/package_cpfp_flow.png|800px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it's difficult to design anything to save\n+bandwidth without any idea of what its bandwidth usage actually looks like in practice. We'll want\n+to design the sender-initiated protocol carefully, and inform the design decisions using data\n+collected from the mainnet p2p network. However, there is no historical transaction data to use\n+because the goal is to enable currently-rejected transactions to propagate. In order to get this\n+right, I propose we hold off on sender-initiated for now, deploy receiver-initiated package relay,\n+observe its usage and figure out where we can save a round trip, and then introduce a\n+well-researched sender-initiated package relay protocol.</ref>\n+\n+Ancestor package relay is negotiated between two peers during the version handshake using a\n+\"sendpackages\" message containing version=1. It requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxid. Peers wishing to relay multiple versions\n+of packages should send one \"sendpackages\" message for each version.\n+<ref>'''Is it possible to support other types of packages in the future?''' Yes. Attempting to\n+support arbitrary packages in mempool validation may result in very complex logic, new Denial of\n+Service attack vectors, and policy limitations that could be leveraged to censor transactions (aka\n+\"pinning attacks\").  This protocol is extensible to support multiple types of packages based on\n+future desired use cases.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation deprecates\n+version 2, it should be easy to announce support for version 1, but not version 2, packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|600px]]\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of unique transactions.\n+\n+The combined hash of a package of transactions is equal to the hash of each transaction's wtxid, concatenated in lexicographical order.\n+\n+The combined hash can be calculated using just the wtxids of the transactions.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|version || uint32_t || 4 || Denotes a package version supported by the node.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send a \"sendpackages\" message to indicate they support package relay. Nodes should send a \"sendpackages\" message for each version they support.\n+\n+# Upon receipt of a \"sendpackages\" message with a version that is not supported, a node must treat the peer as if it never received the message.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# A node that sends \"sendpackages\" MUST also send \"wtxidrelay\". Upon receipt of a \"verack\", if the sender has sent a \"sendpackages\" but not \"wtxidrelay\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+# Version=0 packages correspond to ancestor packages, i.e. \"ancpkginfo\" and \"MSG_ANCPKGINFO\".\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request all or some of the transactions previously announced in a \"ancpkginfo\" message, specified by witness transaction id. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated immediately.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node must respond with either a \"pkgtxns\" containing the requested transactions or \"notfound\" messages indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid (the \"representative transaction\"). Apart from the last wtxid, the rest of the wtxids may be in any order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node should de-duplicate\n+recently-confirmed transactions and make a best effort to validate the transactions it has already\n+downloaded. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions not already in its mempool.\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message that does not contain the ancestor package of the transaction (which the node learns after receiving the transaction data and validating them), the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 319,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "43be4d7c9e7fdec4836e4c54cd3e7b8c2a6baa9b",
      "in_reply_to_id": 1155769723,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed, described what malformed means",
      "created_at": "2023-04-22T16:40:15Z",
      "updated_at": "2023-04-22T16:40:16Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1174436933",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1174436933"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 319,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192395367",
      "pull_request_review_id": 1424540699,
      "id": 1192395367,
      "node_id": "PRRC_kwDOAN28mc5HEoJn",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===",
      "path": "bip-0331.mediawiki",
      "position": 231,
      "original_position": 238,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this could be moved into the definitions section.",
      "created_at": "2023-05-12T13:41:23Z",
      "updated_at": "2023-05-14T14:23:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192395367",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192395367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 231,
      "original_line": 231,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192405550",
      "pull_request_review_id": 1424540699,
      "id": 1192405550,
      "node_id": "PRRC_kwDOAN28mc5HEqou",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 263,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`should one` => `should send one`\r\n`of they` => `they`",
      "created_at": "2023-05-12T13:49:43Z",
      "updated_at": "2023-05-14T14:23:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192405550",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192405550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192438437",
      "pull_request_review_id": 1424540699,
      "id": 1192438437,
      "node_id": "PRRC_kwDOAN28mc5HEyql",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+",
      "path": "bip-0331.mediawiki",
      "position": 128,
      "original_position": 127,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Consider adding something here like \"This BIP defines both Generic Package Relay, the unconditional part of the protocol that all nodes opt-in to when they indicate support for package relay, as well as Ancestor Package Relay, the first optional part of the protocol that nodes may opt-in to during the version handshake. The version handshake itself is considered part of Generic Package Relay.\"",
      "created_at": "2023-05-12T14:16:34Z",
      "updated_at": "2023-05-14T14:23:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192438437",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192438437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 128,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192451579",
      "pull_request_review_id": 1424540699,
      "id": 1192451579,
      "node_id": "PRRC_kwDOAN28mc5HE137",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 183,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Was it ever considered to name Ancestor Package Relay together with the `sendpackages` version number it uses?  It's possible that there is a different way of exchanging ancestors in the future and then that might be confusing if we are not referring to it with v0 ancestor package relay and v1 ancestor package relay. It's also much shorter to reference ;)",
      "created_at": "2023-05-12T14:28:14Z",
      "updated_at": "2023-05-14T14:23:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192451579",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192451579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192465038",
      "pull_request_review_id": 1424540699,
      "id": 1192465038,
      "node_id": "PRRC_kwDOAN28mc5HE5KO",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"",
      "path": "bip-0331.mediawiki",
      "position": 160,
      "original_position": 164,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Consider moving the version stuff at the beginning of the Generic Package Relay section or even giving it it's own section. It feels more natural and aligns with the chronology and the order of the messages in \"New Messages\".",
      "created_at": "2023-05-12T14:40:08Z",
      "updated_at": "2023-05-14T14:23:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192465038",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192465038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 160,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192466585",
      "pull_request_review_id": 1424540699,
      "id": 1192466585,
      "node_id": "PRRC_kwDOAN28mc5HE5iZ",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+=====getpkgtxns=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receiver either all the specified transactions or none of them. This messages is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 285,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`receiver` => `receive`\r\n`This messages` => `This message`",
      "created_at": "2023-05-12T14:41:28Z",
      "updated_at": "2023-05-14T14:23:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192466585",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192466585"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192467314",
      "pull_request_review_id": 1424540699,
      "id": 1192467314,
      "node_id": "PRRC_kwDOAN28mc5HE5ty",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 265,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`afer` => `after`",
      "created_at": "2023-05-12T14:42:02Z",
      "updated_at": "2023-05-14T14:23:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192467314",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192467314"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192752953",
      "pull_request_review_id": 1424540699,
      "id": 1192752953,
      "node_id": "PRRC_kwDOAN28mc5HF_c5",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+=====getpkgtxns=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receiver either all the specified transactions or none of them. This messages is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 287,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1. Just checking: so if a `notfound` message is sent as a response, there is never also a `pgtxns` sent, even if some of the txs are available, right?\r\n2. This will be the combined hash of the all the requested wtxids, not all the wtxids that are not available, right? I think this could be a little more clear.",
      "created_at": "2023-05-12T20:03:16Z",
      "updated_at": "2023-05-14T14:23:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192752953",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192752953"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 287,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192755067",
      "pull_request_review_id": 1424540699,
      "id": 1192755067,
      "node_id": "PRRC_kwDOAN28mc5HF_97",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+=====getpkgtxns=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receiver either all the specified transactions or none of them. This messages is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+=====pkgtxns=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 308,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What if a node sends more transactions than were requested? Might that also be a reason to disconnect?",
      "created_at": "2023-05-12T20:06:57Z",
      "updated_at": "2023-05-14T14:23:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192755067",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192755067"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192777834",
      "pull_request_review_id": 1424540699,
      "id": 1192777834,
      "node_id": "PRRC_kwDOAN28mc5HGFhq",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 185,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Ancestor Package Relay\" and \"Ancestor Package Information\" is used interchangeably in the proposal. The reason is probably that this only contains an *info message. Nonetheless, I think it would be better if this could be made consistent. I don't have a preference since both are correct, it may even be \"Ancestor Package Information Relay\"",
      "created_at": "2023-05-12T20:43:05Z",
      "updated_at": "2023-05-14T14:23:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192777834",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192777834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192800702",
      "pull_request_review_id": 1424540699,
      "id": 1192800702,
      "node_id": "PRRC_kwDOAN28mc5HGLG-",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 267,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should `versions` == 0 be allowed? ",
      "created_at": "2023-05-12T21:15:26Z",
      "updated_at": "2023-05-14T14:23:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1192800702",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1192800702"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1193155496",
      "pull_request_review_id": 1424540699,
      "id": 1193155496,
      "node_id": "PRRC_kwDOAN28mc5HHhuo",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 189,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "fjahr",
        "id": 1322187,
        "node_id": "MDQ6VXNlcjEzMjIxODc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1322187?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fjahr",
        "html_url": "https://github.com/fjahr",
        "followers_url": "https://api.github.com/users/fjahr/followers",
        "following_url": "https://api.github.com/users/fjahr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fjahr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fjahr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fjahr/subscriptions",
        "organizations_url": "https://api.github.com/users/fjahr/orgs",
        "repos_url": "https://api.github.com/users/fjahr/repos",
        "events_url": "https://api.github.com/users/fjahr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fjahr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "While this section does talk about protocol flow it does so in the context of specific examples. I would probably call this section \"Practical application of the Protocol with examples\" or something like that, and move it out of and right after the specification section. I.e. have it between Specification and Compatibility. But I don't feel too strongly about this.",
      "created_at": "2023-05-14T14:15:32Z",
      "updated_at": "2023-05-14T14:23:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1193155496",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1193155496"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 181,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1199652994",
      "pull_request_review_id": 1435440577,
      "id": 1199652994,
      "node_id": "PRRC_kwDOAN28mc5HgUCC",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===",
      "path": "bip-0331.mediawiki",
      "position": 231,
      "original_position": 238,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192395367,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unsure... somebody would need to use this to implement MSG_PKGTXNS. That seems like it should be \"specification\" ?",
      "created_at": "2023-05-20T19:51:39Z",
      "updated_at": "2023-05-25T13:14:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1199652994",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1199652994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 231,
      "original_line": 231,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1210627208",
      "pull_request_review_id": 1451512139,
      "id": 1210627208,
      "node_id": "PRRC_kwDOAN28mc5IKLSI",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 267,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s)). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\r\n```",
      "created_at": "2023-05-30T17:54:03Z",
      "updated_at": "2023-05-30T18:02:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1210627208",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1210627208"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211504629",
      "pull_request_review_id": 1452853686,
      "id": 1211504629,
      "node_id": "PRRC_kwDOAN28mc5INhf1",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+=====getpkgtxns=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receiver either all the specified transactions or none of them. This messages is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+=====pkgtxns=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 308,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192755067,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, reason to disconnect. I think that is the same thing as an unsolicited package.",
      "created_at": "2023-05-31T10:41:58Z",
      "updated_at": "2023-05-31T10:41:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211504629",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211504629"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211541523",
      "pull_request_review_id": 1452913359,
      "id": 1211541523,
      "node_id": "PRRC_kwDOAN28mc5INqgT",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+",
      "path": "bip-0331.mediawiki",
      "position": 128,
      "original_position": 127,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192438437,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, yeah, it's weird the way drew a line between generic/ancestor package relay!\r\n\r\nHad an offline conversation with someone about the \"generic\" thing. I decided to get rid of that and instead add the information in an \"Extensibility\" section. At the end of the day, I'm just suggesting what a future package relay upgrade could look like and we are not locked into using the format I outlined.",
      "created_at": "2023-05-31T11:11:12Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211541523",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211541523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 128,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211544475",
      "pull_request_review_id": 1452913359,
      "id": 1211544475,
      "node_id": "PRRC_kwDOAN28mc5INrOb",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"",
      "path": "bip-0331.mediawiki",
      "position": 160,
      "original_position": 164,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192465038,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":+1: I've gotten rid of Generic and hopefully the flow is now more natural since there's only 1 section in \"New Messages\"",
      "created_at": "2023-05-31T11:13:20Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211544475",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211544475"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 160,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211545311",
      "pull_request_review_id": 1452913359,
      "id": 1211545311,
      "node_id": "PRRC_kwDOAN28mc5INrbf",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 185,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192777834,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Changed all the proper noun instances to Ancestor Package Relay",
      "created_at": "2023-05-31T11:14:03Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211545311",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211545311"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211546033",
      "pull_request_review_id": 1452913359,
      "id": 1211546033,
      "node_id": "PRRC_kwDOAN28mc5INrmx",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===",
      "path": "bip-0331.mediawiki",
      "position": 231,
      "original_position": 238,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192395367,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Kept this as is for now",
      "created_at": "2023-05-31T11:14:38Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211546033",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211546033"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 231,
      "original_line": 231,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211546494",
      "pull_request_review_id": 1452913359,
      "id": 1211546494,
      "node_id": "PRRC_kwDOAN28mc5INrt-",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 267,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192800702,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, though ignored. I've added a note about this now",
      "created_at": "2023-05-31T11:15:02Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211546494",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211546494"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211546917",
      "pull_request_review_id": 1452913359,
      "id": 1211546917,
      "node_id": "PRRC_kwDOAN28mc5INr0l",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 267,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1210627208,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, taken",
      "created_at": "2023-05-31T11:15:25Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211546917",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211546917"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 267,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211547145",
      "pull_request_review_id": 1452913359,
      "id": 1211547145,
      "node_id": "PRRC_kwDOAN28mc5INr4J",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 263,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192405550,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, fixed",
      "created_at": "2023-05-31T11:15:38Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211547145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211547145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211548195",
      "pull_request_review_id": 1452913359,
      "id": 1211548195,
      "node_id": "PRRC_kwDOAN28mc5INsIj",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 183,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192451579,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Heh, I think in the future if we have 2, we could probably say `PKG_RELAY_ANC` (the name of the version bit) to refer to this one?",
      "created_at": "2023-05-31T11:16:42Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211548195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211548195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211548640",
      "pull_request_review_id": 1452913359,
      "id": 1211548640,
      "node_id": "PRRC_kwDOAN28mc5INsPg",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====Generic Package Relay Messages====\n+\n+=====sendpackages=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions of they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received afer \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version(s). Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply logic at the\n+end. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html discussion].\n+</ref>\n+\n+=====getpkgtxns=====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receiver either all the specified transactions or none of them. This messages is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 287,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192752953,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yep! tried to clarify this",
      "created_at": "2023-05-31T11:17:08Z",
      "updated_at": "2023-05-31T11:17:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1211548640",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1211548640"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 287,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220626227",
      "pull_request_review_id": 1466384865,
      "id": 1220626227,
      "node_id": "PRRC_kwDOAN28mc5IwUcz",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]",
      "path": "bip-0331.mediawiki",
      "position": 50,
      "original_position": 50,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There is one more L2 protocol with time-sensitive pre-signed transactions _deployed today in production_ (at least by Eclair and CLN) that benefits from package relay: https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#peer-protocol-for-peerswap-swaps\r\n\r\nThe maker can pin the off-chain commitment transaction until the `claim_by_csv` path becomes final with the CSV expiration, and therefore spend both the incoming HTLC output and the opening transaction output.",
      "created_at": "2023-06-07T01:03:42Z",
      "updated_at": "2023-06-07T02:14:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1220626227",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220626227"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 50,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220651721",
      "pull_request_review_id": 1466384865,
      "id": 1220651721,
      "node_id": "PRRC_kwDOAN28mc5IwarJ",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.",
      "path": "bip-0331.mediawiki",
      "position": 144,
      "original_position": 142,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "And I think such design would suffer from transaction censorship vector if you have a parent with multiple childs of unequal feerate ?\r\n\r\nLet’s say you have LN commitment transaction with anchor output support. Both anchors are present as both counterparties have balances. If your counterparty has broadcast its commitment with its own child, you can attach your `to_remote` child downgrading the feerate of the whole package.\r\n\r\nOf course, from the sender-side, you could re-announce the package for each known child, though it sounds a bandwidth waste as you should do ancestor feerate to propagate the parent first.\r\n\r\nI need to look on the PR to see how package are assembled on the sender-side.",
      "created_at": "2023-06-07T01:21:15Z",
      "updated_at": "2023-06-07T02:14:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1220651721",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220651721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 144,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220670659",
      "pull_request_review_id": 1466384865,
      "id": 1220670659,
      "node_id": "PRRC_kwDOAN28mc5IwfTD",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 165,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It sounds that type of cheap bandwidth saving that might reveal as a downside a decade from now ? And it’s one time message per-link.\r\n\r\nLet’s hypothetize you will have half a dozen of time-sensitive second-layers deployed few years from now (lightning, vaults, statechains, submarine swaps, time-locked wallets, discreet log contracts). Among those second-layers, they might need different variants of packages for each of their protocol versions (e.g for Lightning taproot channels, eltoo channels, demux channels for jamming) and for each protocol phase (dual-funding, splicing).\r\n\r\nAnd this becomes worst if you have to combine package size characteristics (e.g N-parent for 1-child) with other future package information like feerare or relationships between transactions.\r\n\r\nUsing an extensible feature flags (e.g TLV) like Lightning is doing for most of its peer messages has been discussed so far in the context of BIP 331 ?",
      "created_at": "2023-06-07T01:38:32Z",
      "updated_at": "2023-06-07T02:14:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1220670659",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220670659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220712671",
      "pull_request_review_id": 1466384865,
      "id": 1220712671,
      "node_id": "PRRC_kwDOAN28mc5Iwpjf",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.",
      "path": "bip-0331.mediawiki",
      "position": 221,
      "original_position": 220,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this assumption is dependent on the bumping patterns of package broadcast. In the sense that if the package is re-broadcast as it is (and there is no mempool fluctuations), there is a complete waste of bandwidth as both parent and child are known.\r\n\r\nIf the package is rebroadcast with the CPFP bumped (probably the future usage for LN where the parent commitment transaction stays an invariant), there is only a need to re-announce the child to the peer nodes.\r\n\r\nAnd note bandwidth assumptions we’re making on our side can be falsified in changes in the re-broadcast logic of LN implementations, like it has been done recently.\r\n\r\nI think a realistic simulation model would encompass at least few dimensions \r\n- the peer-to-peer announcement format\r\n- the mempool fluctuations and evictions of package component\r\n- the rebroadcast frequency of applications (and if there is a malleation of CFPP at each rebroadcast)\r\n\r\nMore dimensions to think about ?",
      "created_at": "2023-06-07T02:13:41Z",
      "updated_at": "2023-06-07T02:14:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1220712671",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220712671"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 221,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221107480",
      "pull_request_review_id": 1466937089,
      "id": 1221107480,
      "node_id": "PRRC_kwDOAN28mc5IyJ8Y",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.",
      "path": "bip-0331.mediawiki",
      "position": 144,
      "original_position": 142,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220651721,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note that this comment is on an alternative design considered but *not* proposed.\r\n\r\n> And I think such design would suffer from transaction censorship vector if you have a parent with multiple childs of unequal feerate ?\r\n\r\n> you can attach your to_remote child downgrading the feerate of the whole package.\r\n\r\nSure, an additional child may exist. But it is not included in the package because it's not part of the actual cpfp child's ancestor set. Its low fees should not be considered in combination with transactions that don't rely on it.\r\n\r\nAs for potential censorship, that is solved by caching \"reconsiderable\" rejections separately (see `m_recent_rejects_reconsiderable` in PR). You can relay a separate package that is the ancestor set of the additional child, and its rejection should not affect whether another overlapping ancestor package is considered/accepted.",
      "created_at": "2023-06-07T08:03:22Z",
      "updated_at": "2023-06-07T08:03:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1221107480",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221107480"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 144,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221721569",
      "pull_request_review_id": 1467870920,
      "id": 1221721569,
      "node_id": "PRRC_kwDOAN28mc5I0f3h",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.",
      "path": "bip-0331.mediawiki",
      "position": 221,
      "original_position": 220,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220712671,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this is where practical experience is going to help. Receiver initiated imo helps out in the sense of it fits somewhat more neatly in the current orphan/feefilter paradigm?",
      "created_at": "2023-06-07T14:40:42Z",
      "updated_at": "2023-06-07T14:40:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1221721569",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221721569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 221,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221736469",
      "pull_request_review_id": 1467895006,
      "id": 1221736469,
      "node_id": "PRRC_kwDOAN28mc5I0jgV",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash (defined above) of the wtxids in the getpkgtxns request.\n+\n+# This inv type should only be used in \"notfound\" messages, i.e. \"inv(MSG_PKGTXNS)\" and \"getdata(MSG_PKGTXNS)\" must never be sent.\n+\n+==Compatibility==\n+\n+Older clients remain fully compatible and interoperable after this change. Clients implementing this\n+protocol will only attempt to send and request packages if agreed upon during the version handshake.\n+<ref>'''Will package relay cause non-package relay nodes to waste bandwidth on low-feerate transactions?'''\n+If a node supports package relay, it may accept low-feerate transactions (e.g. paying zero fees)\n+into its mempool, but non-package relay nodes would most likely reject them. To mitigate bandwidth\n+waste, a package relay node should not announce descendants of below-fee-filter transactions to\n+non-package relay peers.\n+</ref>\n+<ref>'''Is Package Erlay possible?'''\n+A client using BIP330 reconciliation-based transaction relay (Erlay) is able to use package relay\n+without interference. After reconciliation, any transactions with unconfirmed ancestors may be\n+relayed using ancestor package relay.\n+[[File:./bip-0331/package_erlay.png|700px]]\n+</ref>\n+\n+==Extensibility==\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download. One would define a new package\n+information message, allocate its corresponding inv type, and its bit in the versions field of\n+\"sendpackages\".  A future version of package relay may allow a sender-initiated dialogue if it is\n+specified that the \"*PKGINFO\" inv type can be used in an \"inv\" message.\n+<br />\n+[[File:./bip-0331/generic_package_relay.png|600px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 389,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually not totally clear what this image is showing. why is there a notfound followed by packagetxns?",
      "created_at": "2023-06-07T14:51:13Z",
      "updated_at": "2023-06-07T14:51:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1221736469",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221736469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 389,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222945911",
      "pull_request_review_id": 1469760487,
      "id": 1222945911,
      "node_id": "PRRC_kwDOAN28mc5I5Kx3",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash (defined above) of the wtxids in the getpkgtxns request.\n+\n+# This inv type should only be used in \"notfound\" messages, i.e. \"inv(MSG_PKGTXNS)\" and \"getdata(MSG_PKGTXNS)\" must never be sent.\n+\n+==Compatibility==\n+\n+Older clients remain fully compatible and interoperable after this change. Clients implementing this\n+protocol will only attempt to send and request packages if agreed upon during the version handshake.\n+<ref>'''Will package relay cause non-package relay nodes to waste bandwidth on low-feerate transactions?'''\n+If a node supports package relay, it may accept low-feerate transactions (e.g. paying zero fees)\n+into its mempool, but non-package relay nodes would most likely reject them. To mitigate bandwidth\n+waste, a package relay node should not announce descendants of below-fee-filter transactions to\n+non-package relay peers.\n+</ref>\n+<ref>'''Is Package Erlay possible?'''\n+A client using BIP330 reconciliation-based transaction relay (Erlay) is able to use package relay\n+without interference. After reconciliation, any transactions with unconfirmed ancestors may be\n+relayed using ancestor package relay.\n+[[File:./bip-0331/package_erlay.png|700px]]\n+</ref>\n+\n+==Extensibility==\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download. One would define a new package\n+information message, allocate its corresponding inv type, and its bit in the versions field of\n+\"sendpackages\".  A future version of package relay may allow a sender-initiated dialogue if it is\n+specified that the \"*PKGINFO\" inv type can be used in an \"inv\" message.\n+<br />\n+[[File:./bip-0331/generic_package_relay.png|600px]]",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 389,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1221736469,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Changed it and added some more descriptions. I had wanted to show multiple possible dialogues but it just looks confusing.",
      "created_at": "2023-06-08T12:05:19Z",
      "updated_at": "2023-06-08T12:05:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1222945911",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222945911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 389,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222949472",
      "pull_request_review_id": 1469767357,
      "id": 1222949472,
      "node_id": "PRRC_kwDOAN28mc5I5Lpg",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.",
      "path": "bip-0331.mediawiki",
      "position": 221,
      "original_position": 220,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220712671,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah so sender-initiated is not being proposed here. The general philosophy is that since everything here is receiver-initiated in certain situations, and we are careful to not waste bandwidth in honest cases in the implementation, hopefully we are not blowing up bandwidth.\r\n\r\nIf we can do even better by doing sender-initiated in some cases in the future, that'd be nice. I don't think any simulation can be realistic, as we have 0 data about package relay usage until we actually deploy it and people use it to relay transactions that they couldn't before. But these are very helpful considerations for measuring things, thanks will keep in mind.",
      "created_at": "2023-06-08T12:08:33Z",
      "updated_at": "2023-06-08T12:08:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1222949472",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222949472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 221,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222965182",
      "pull_request_review_id": 1469791145,
      "id": 1222965182,
      "node_id": "PRRC_kwDOAN28mc5I5Pe-",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 165,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220670659,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> It sounds that type of cheap bandwidth saving that might reveal as a downside a decade from now ? And it’s one time message per-link.\r\n\r\n> Let’s hypothetize you will have half a dozen of time-sensitive second-layers deployed few years from now (lightning, vaults, statechains, submarine swaps, time-locked wallets, discreet log contracts). Among those second-layers, they might need different variants of packages for each of their protocol versions (e.g for Lightning taproot channels, eltoo channels, demux channels for jamming) and for each protocol phase (dual-funding, splicing).\r\n\r\nEr, what exactly is the \"cheap bandwidth saving?\" Are you suggesting to increase the field size?\r\n\r\nI've removed the mention of 32 versions to leave room for other ways to extend. For now, I don't think we should over-engineer the versions field for a hypothetical super-complex future that may or may not need dozens of types of packages. I think 32 is plenty, and the worst case scenario is defining a new message and sending another few bytes once per connection.",
      "created_at": "2023-06-08T12:23:29Z",
      "updated_at": "2023-06-08T12:23:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1222965182",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222965182"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225093574",
      "pull_request_review_id": 1473309953,
      "id": 1225093574,
      "node_id": "PRRC_kwDOAN28mc5JBXHG",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 20,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Use a subheading? `===Help incen...===` ?\r\n\r\n\"incentive-compatible\" seems a bit euphemistic -- wouldn't it be better just to say \"help ensure the transactions paying the most fees propogate\" ?",
      "created_at": "2023-06-10T04:46:26Z",
      "updated_at": "2023-06-10T08:26:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225093574",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225093574"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225103264",
      "pull_request_review_id": 1473309953,
      "id": 1225103264,
      "node_id": "PRRC_kwDOAN28mc5JBZeg",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 86,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You still \"need\" txid-based relay for backwards compatibility.\r\n\r\nArguably, txid-based relay would be more efficient than the proposed protocol: if you see an orphan Z, whose parent Y does not spend any in-mempool txs, then this protocol would make three round trips: \r\n\r\n * GETDATA wtx(Z); TZ Z\r\n * GETDATA andpkginfo(Z); ANCPKGINFO Z, Y\r\n * GETPKGTXNS wtx(Y); PKGTXNS Y\r\n\r\nbut you could alternatively do two round trips:\r\n\r\n * GETDATA wtx(Z); TZ Z\r\n * GETDATA andpkginfo(Z), tx(Y); ANCPKGINFO Z, Y; TX Y\r\n\r\nThat approach would not reduce round-trips when receiving orphans that do have an in-mempool grandparent that the receiver does not already know about (but it wouldn't increase the number of roundtrips either), and would also require storing both the child and parents while waiting for any grandparents.",
      "created_at": "2023-06-10T05:07:05Z",
      "updated_at": "2023-06-10T08:26:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225103264",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225103264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225139722",
      "pull_request_review_id": 1473309953,
      "id": 1225139722,
      "node_id": "PRRC_kwDOAN28mc5JBiYK",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 128,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"package information round and package transaction download round\" might read better -- as it is my first read associated \"download\" with both the \"information\" and \"data\". (Being synonyms, \"information\" and \"data\" aren't great ways of describing two different things, either...)",
      "created_at": "2023-06-10T06:15:11Z",
      "updated_at": "2023-06-10T08:26:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225139722",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225139722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225141794",
      "pull_request_review_id": 1473309953,
      "id": 1225141794,
      "node_id": "PRRC_kwDOAN28mc5JBi4i",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.",
      "path": "bip-0331.mediawiki",
      "position": 133,
      "original_position": 131,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The information round doesn't really help you learn \"whether you want to download the transactions\" -- you know that already, either because you already have the txs, or you've remembered that you've downloaded them previously and rejected them.",
      "created_at": "2023-06-10T06:19:02Z",
      "updated_at": "2023-06-10T08:26:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225141794",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225141794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225156027",
      "pull_request_review_id": 1473309953,
      "id": 1225156027,
      "node_id": "PRRC_kwDOAN28mc5JBmW7",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.",
      "path": "bip-0331.mediawiki",
      "position": 163,
      "original_position": 161,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You could break `ancpkginfo` (\"ancestor package information\") and `pkgtxns` (\"package tx data relay\") into two separate features, with the idea that maybe someday we'll have something better than ancestor package relay and want to deprecate the `ancpkginfo` part, while continuing to have the `pkgtxns` part.\r\n\r\nIf so, you could consider sending `sendpackages 3` instead of `sendpackages 1` -- with bit 0 indicating support of the `pkgtxns` part, and bit 1 indicating support of the `ancpkginfo` part.",
      "created_at": "2023-06-10T06:43:43Z",
      "updated_at": "2023-06-10T08:26:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225156027",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225156027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 163,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225156783",
      "pull_request_review_id": 1473309953,
      "id": 1225156783,
      "node_id": "PRRC_kwDOAN28mc5JBmiv",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 172,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"doesn't support\" seems sufficient and clearer?",
      "created_at": "2023-06-10T06:45:19Z",
      "updated_at": "2023-06-10T08:26:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225156783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225156783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225160837",
      "pull_request_review_id": 1473309953,
      "id": 1225160837,
      "node_id": "PRRC_kwDOAN28mc5JBniF",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===",
      "path": "bip-0331.mediawiki",
      "position": 231,
      "original_position": 238,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1192395367,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be good to have the motivation (ie \"to provide a meaningful but short `notfound` response to `getpkgtxns`\") mentioned before the definition",
      "created_at": "2023-06-10T06:53:41Z",
      "updated_at": "2023-06-10T08:26:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225160837",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225160837"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 231,
      "original_line": 231,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225178558",
      "pull_request_review_id": 1473309953,
      "id": 1225178558,
      "node_id": "PRRC_kwDOAN28mc5JBr2-",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 308,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "**an** \"ancpkginfo\"",
      "created_at": "2023-06-10T07:25:49Z",
      "updated_at": "2023-06-10T08:26:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225178558",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225178558"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225180817",
      "pull_request_review_id": 1473309953,
      "id": 1225180817,
      "node_id": "PRRC_kwDOAN28mc5JBsaR",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 310,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"The ancestor package should be topologically sorted, and therefore the requested transaction should be the last item in the list.\" ?\r\n\r\nAlternatively, if we're using the last item in the list to determine which request this was in response to, perhaps change \"should\" to \"must\" ?\r\n\r\nMaybe be explicit about whether a node that receive a ancpkginfo set that's not topologically sorted (which they determine either because the requested tx isn't last, or they figure out after downloading the tx contents) should potentially disconnect in response? (I assume they shouldn't)\r\n\r\nMaybe note that topological sort can be achieved by sorting by mempool acceptance order, if you always accept parents prior to accepting any of their children?",
      "created_at": "2023-06-10T07:30:25Z",
      "updated_at": "2023-06-10T08:26:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225180817",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225180817"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225183098",
      "pull_request_review_id": 1473309953,
      "id": 1225183098,
      "node_id": "PRRC_kwDOAN28mc5JBs96",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 312,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "**an** \"inv()\"\r\n\r\nMaybe better to phrase it as \"the MSG_ANCPKGINFO  inv type must only be used in `getdata` message; it must not be used with the `inv` message\" or similar?",
      "created_at": "2023-06-10T07:35:02Z",
      "updated_at": "2023-06-10T08:26:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225183098",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225183098"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225188167",
      "pull_request_review_id": 1473309953,
      "id": 1225188167,
      "node_id": "PRRC_kwDOAN28mc5JBuNH",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 151,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "change \"Omit the\" to \"that is, rather than using `getpkgtxns` and `pkgtxns`, send `getdata` and receive each tx individually\" ?",
      "created_at": "2023-06-10T07:44:51Z",
      "updated_at": "2023-06-10T08:26:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225188167",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225188167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225190718",
      "pull_request_review_id": 1473309953,
      "id": 1225190718,
      "node_id": "PRRC_kwDOAN28mc5JBu0-",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 351,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe also mention that a node might simply ignore an unsolicited package, or may attempt to validate it, or may accept a subset of transactions from the package that it can validate, and may disconnect only if validation fails, or only if validation fails due the package being consensus invalid?\r\n\r\nI assume what core would do is only disconnect if one or more of the txs fails validation due to `TX_CONSENSUS`.",
      "created_at": "2023-06-10T07:49:19Z",
      "updated_at": "2023-06-10T08:26:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225190718",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225190718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225194338",
      "pull_request_review_id": 1473309953,
      "id": 1225194338,
      "node_id": "PRRC_kwDOAN28mc5JBvti",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 330,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What if you received a `getpkgtxns` for wtxids that weren't in an `ancpkginfo` that you set? Should you always accept and respond if you have the txs and they all fit into a single message? Can you say \"I'll never accept a tx with more than 20 ancestors in my mempool, so I'll never send more than 21 wtxids in an ancpkginfo, so I'll never send more than 21 txs in response to a `getpkgtxns`?",
      "created_at": "2023-06-10T07:54:00Z",
      "updated_at": "2023-06-10T08:26:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225194338",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225194338"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225211226",
      "pull_request_review_id": 1473309953,
      "id": 1225211226,
      "node_id": "PRRC_kwDOAN28mc5JBz1a",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for downloading transactions as\n+batches.</ref>\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash (defined above) of the wtxids in the getpkgtxns request.\n+\n+# This inv type should only be used in \"notfound\" messages, i.e. \"inv(MSG_PKGTXNS)\" and \"getdata(MSG_PKGTXNS)\" must never be sent.\n+\n+==Compatibility==\n+\n+Older clients remain fully compatible and interoperable after this change. Clients implementing this\n+protocol will only attempt to send and request packages if agreed upon during the version handshake.\n+<ref>'''Will package relay cause non-package relay nodes to waste bandwidth on low-feerate transactions?'''\n+If a node supports package relay, it may accept low-feerate transactions (e.g. paying zero fees)\n+into its mempool, but non-package relay nodes would most likely reject them. To mitigate bandwidth\n+waste, a package relay node should not announce descendants of below-fee-filter transactions to\n+non-package relay peers.\n+</ref>\n+<ref>'''Is Package Erlay possible?'''\n+A client using BIP330 reconciliation-based transaction relay (Erlay) is able to use package relay\n+without interference. After reconciliation, any transactions with unconfirmed ancestors may be\n+relayed using ancestor package relay.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 377,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We already have the transaction at that point, so maybe better to phrase it as \"any transaction with unconfirmed ancestors may have those ancestors resolved using ancestor package relay\" ?",
      "created_at": "2023-06-10T08:10:41Z",
      "updated_at": "2023-06-10T08:26:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1225211226",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1225211226"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 377,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226651514",
      "pull_request_review_id": 1474903974,
      "id": 1226651514,
      "node_id": "PRRC_kwDOAN28mc5JHTd6",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.",
      "path": "bip-0331.mediawiki",
      "position": 133,
      "original_position": 131,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225141794,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In future package types where you might get additional information, e.g., package feerates or similar this may make more sense to say.",
      "created_at": "2023-06-12T13:15:34Z",
      "updated_at": "2023-06-12T13:30:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1226651514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226651514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226670321",
      "pull_request_review_id": 1474903974,
      "id": 1226670321,
      "node_id": "PRRC_kwDOAN28mc5JHYDx",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 351,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225190718,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "leaving it undefined seems ok, since it's just a bucket of \"mays\" at this point?",
      "created_at": "2023-06-12T13:29:36Z",
      "updated_at": "2023-06-12T13:30:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1226670321",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226670321"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228661325",
      "pull_request_review_id": 1478001050,
      "id": 1228661325,
      "node_id": "PRRC_kwDOAN28mc5JO-JN",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.",
      "path": "bip-0331.mediawiki",
      "position": 133,
      "original_position": 131,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225141794,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think it's that simple - we have cases of\r\n- I downloaded this tx and rejected it for too low feerate, but I'm okay with trying again because it's with a package of other transactions I haven't seen before\r\n- I haven't seen this tx before but there's another tx in the package that I know is consensus-invalid so I'm not going to download any of them",
      "created_at": "2023-06-13T20:27:43Z",
      "updated_at": "2023-06-13T20:27:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1228661325",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228661325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228676522",
      "pull_request_review_id": 1478023709,
      "id": 1228676522,
      "node_id": "PRRC_kwDOAN28mc5JPB2q",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 330,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225194338,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> What if you received a getpkgtxns for wtxids that weren't in an ancpkginfo that you set?\r\n\r\nThat's fine imo - we'll also respond to getdata(tx) for transactions we didn't announce under certain conditions.\r\n\r\n> Can you say \"I'll never accept a tx with more than 20 ancestors in my mempool, so I'll never send more than 21 wtxids in an ancpkginfo, so I'll never send more than 21 txs in response to a getpkgtxns?\r\n\r\nI think it's better for ancpkginfo and getpkgtxns logic to be independent, as the idea is to be able to reuse getpkgtxns for other package info types in the future. One might imagine a future where we have cluster package info (or something), and even though ancestor limit is 21, there is a cluster with 22 transactions.",
      "created_at": "2023-06-13T20:43:06Z",
      "updated_at": "2023-06-13T20:43:07Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1228676522",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228676522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228906901",
      "pull_request_review_id": 1478351648,
      "id": 1228906901,
      "node_id": "PRRC_kwDOAN28mc5JP6GV",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.",
      "path": "bip-0331.mediawiki",
      "position": 133,
      "original_position": 131,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225141794,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> In future package types where you might get additional information, e.g., package feerates or similar this may make more sense to say.\r\n\r\nOkay, \"the information round *described here* doesn't really help you learn...\"\r\n\r\n> I haven't seen this tx before but there's another tx in the package that I know is consensus-invalid so I'm not going to download any of them\r\n\r\nIn that case, (on the implementation side) would we need different reject caches, one for \"consensus invalid\", one for \"policy invalid\"? Not sure that would be worth the hassle (honest peers sending consensus invalid stuff should be extremely rare; attackers could just send novel txs each time avoiding the cache)",
      "created_at": "2023-06-14T02:45:36Z",
      "updated_at": "2023-06-14T02:45:37Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1228906901",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228906901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228909347",
      "pull_request_review_id": 1478354837,
      "id": 1228909347,
      "node_id": "PRRC_kwDOAN28mc5JP6sj",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 351,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225190718,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The way I would read the above is that most of those \"mays\" would be violating the previous paragraph: \"the node should validate the transactions together as a package rather than individually\".",
      "created_at": "2023-06-14T02:50:54Z",
      "updated_at": "2023-06-14T02:50:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1228909347",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228909347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228918874",
      "pull_request_review_id": 1478369391,
      "id": 1228918874,
      "node_id": "PRRC_kwDOAN28mc5JP9Ba",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 330,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225194338,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I agree in principle, but I think there probably should be some explicit limit for what you can put in getpkgtxns. With 65 byte txs being standard, you could fit ~60k txs in a pkgtxns response; is there anything beyond \"whoops, your response would exceed `MAX_PROTOCOL_MESSAGE_LENGTH` so you get a notfound instead\" that we could use to trim nonsense requests early? There's a big difference between 21 and 60k!",
      "created_at": "2023-06-14T02:58:09Z",
      "updated_at": "2023-06-14T02:58:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1228918874",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228918874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229455991",
      "pull_request_review_id": 1479187078,
      "id": 1229455991,
      "node_id": "PRRC_kwDOAN28mc5JSAJ3",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.",
      "path": "bip-0331.mediawiki",
      "position": 163,
      "original_position": 161,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225156027,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah good idea.",
      "created_at": "2023-06-14T11:38:53Z",
      "updated_at": "2023-06-14T11:38:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229455991",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229455991"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 163,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229562930",
      "pull_request_review_id": 1479355267,
      "id": 1229562930,
      "node_id": "PRRC_kwDOAN28mc5JSaQy",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.",
      "path": "bip-0331.mediawiki",
      "position": 133,
      "original_position": 131,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225141794,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> In that case, (on the implementation side) would we need different reject caches, one for \"consensus invalid\", one for \"policy invalid\"?\r\n\r\nYes. Two rejection caches is necessary, see https://github.com/glozow/bitcoin/pull/8#issuecomment-1453791776. But not policy vs consensus, just ones that are eligible for reconsideration in a package (i.e. too low feerate or missing ephemeral anchor spend) vs ones that are not. I said \"consensus invalid\" to provide a clear example, but I just mean \"something we don't need to validate again, even if it's in a package.\" If something was larger than max standard size or has too many ancestors, trying it in a package won't make it valid.",
      "created_at": "2023-06-14T12:48:19Z",
      "updated_at": "2023-06-14T12:57:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229562930",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229562930"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229619856",
      "pull_request_review_id": 1479450541,
      "id": 1229619856,
      "node_id": "PRRC_kwDOAN28mc5JSoKQ",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 351,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225190718,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do I understand correctly that you're saying we might want to validate an unsolicited package and not disconnect the sender? Why would we do this? It doesn't seem like a good idea to spend resources validating transactions if we didn't ask for them.",
      "created_at": "2023-06-14T13:26:12Z",
      "updated_at": "2023-06-14T13:26:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229619856",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229619856"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229632069",
      "pull_request_review_id": 1479469876,
      "id": 1229632069,
      "node_id": "PRRC_kwDOAN28mc5JSrJF",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 330,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225194338,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah good point. Perhaps we limit to, say, 50? 100? (Arbitrarily picked, 25 just seems a little bit too limiting)",
      "created_at": "2023-06-14T13:34:34Z",
      "updated_at": "2023-06-14T13:34:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229632069",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229632069"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229640816",
      "pull_request_review_id": 1479484624,
      "id": 1229640816,
      "node_id": "PRRC_kwDOAN28mc5JStRw",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 351,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225190718,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> \"the node should validate the transactions together as a package rather than individually\".\r\n\r\nhm good point. I'm not actually sure what this phrase means? Even the implementation for Core tries transactions individually and in subpackages.\r\n\r\n> Why would we do this? It doesn't seem like a good idea to spend resources validating transactions if we didn't ask for them.\r\n\r\nIt's kind of an implementation detail, in that it doesn't effect the underlying protocol(?)",
      "created_at": "2023-06-14T13:40:37Z",
      "updated_at": "2023-06-14T13:40:37Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229640816",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229640816"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229648228",
      "pull_request_review_id": 1479496811,
      "id": 1229648228,
      "node_id": "PRRC_kwDOAN28mc5JSvFk",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\".  If a node receives an unsolicited package, the sender may be disconnected.<ref>'''Why isn't package relay negotiation required for pkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 351,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225190718,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah good point, I suppose I can just delete this bullet. Doesn't really matter for protocol what the node does with the transactions.",
      "created_at": "2023-06-14T13:45:33Z",
      "updated_at": "2023-06-14T13:45:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229648228",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229648228"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229652195",
      "pull_request_review_id": 1479502636,
      "id": 1229652195,
      "node_id": "PRRC_kwDOAN28mc5JSwDj",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 330,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225194338,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If we pick an explicit limit, and want to re-use this message for later info fetching types, we should pick something \"stupidly\" high to not interfere with known ancestor package/cluster sizes being considered\r\n\r\ne.g., 500?",
      "created_at": "2023-06-14T13:48:06Z",
      "updated_at": "2023-06-14T13:48:07Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229652195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229652195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229660994",
      "pull_request_review_id": 1479517188,
      "id": 1229660994,
      "node_id": "PRRC_kwDOAN28mc5JSyNC",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 349,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229640816\r\n\r\nAs per discussion, I'm not sure what this sentence actually means. It's up to the node implementation to decide how to handle these, including trying individual validation first, then subpackage subsets...",
      "created_at": "2023-06-14T13:53:27Z",
      "updated_at": "2023-06-14T13:53:27Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229660994",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229660994"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 349,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229664213",
      "pull_request_review_id": 1479522453,
      "id": 1229664213,
      "node_id": "PRRC_kwDOAN28mc5JSy_V",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020496.html suggested] that\n+this message is not package-specific and generally useful for requesting transactions as\n+batches.</ref>\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# Upon receipt of a \"pkgtxns\" message, the node should validate the transactions together as a package rather than individually.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 349,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1229660994,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Deleted",
      "created_at": "2023-06-14T13:55:27Z",
      "updated_at": "2023-06-14T13:55:27Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229664213",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229664213"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 349,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229783524",
      "pull_request_review_id": 1479716169,
      "id": 1229783524,
      "node_id": "PRRC_kwDOAN28mc5JTQHk",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorry for re-painting this shed, but I think this number is a bit low and means we may need to revisit sooner rather than later, for instance if we transition to cluster mempools and have large chunks we want to fetch? \r\n\r\nCan debate the number with more information later I suppose\r\n",
      "created_at": "2023-06-14T15:09:44Z",
      "updated_at": "2023-06-14T15:09:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229783524",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229783524"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229829205",
      "pull_request_review_id": 1479785778,
      "id": 1229829205,
      "node_id": "PRRC_kwDOAN28mc5JTbRV",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1229783524,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No worries. I picked 100 arbitrarily, but I don't imagine we'd be picking a cluster limit higher than that (just a guess, maybe somebody else has more insight). Note that this max is also the number of wtxids we may potentially need to sort + hash together to send a \"notfound\" response.",
      "created_at": "2023-06-14T15:40:29Z",
      "updated_at": "2023-06-14T15:40:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1229829205",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229829205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231038559",
      "pull_request_review_id": 1481615077,
      "id": 1231038559,
      "node_id": "PRRC_kwDOAN28mc5JYChf",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1229783524,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd be pretty cautious about trying to request large chunks via getpkgtxns -- if any tx has been bumped, you'll just get a notfound with no indication of what part might be okay to retry.",
      "created_at": "2023-06-15T13:42:50Z",
      "updated_at": "2023-06-15T13:42:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231038559",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231038559"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231049141",
      "pull_request_review_id": 1481633077,
      "id": 1231049141,
      "node_id": "PRRC_kwDOAN28mc5JYFG1",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.",
      "path": "bip-0331.mediawiki",
      "position": 133,
      "original_position": 131,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225141794,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I guess as long as they're global caches and not per-peer it doesn't matter much anyway.",
      "created_at": "2023-06-15T13:49:04Z",
      "updated_at": "2023-06-15T13:49:04Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231049141",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231049141"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231299408",
      "pull_request_review_id": 1482026619,
      "id": 1231299408,
      "node_id": "PRRC_kwDOAN28mc5JZCNQ",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1229783524,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Inclined to keep this at 100. Agree it doesn't make much sense to request a ton of transactions anyway, given the response is all or nothing.",
      "created_at": "2023-06-15T16:46:09Z",
      "updated_at": "2023-06-15T16:46:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231299408",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231299408"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231638592",
      "pull_request_review_id": 1482524666,
      "id": 1231638592,
      "node_id": "PRRC_kwDOAN28mc5JaVBA",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 274,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Side-note, I think the feerate cannot be trusted under BIP118  [ANYPREVOUTANYSCRIPT,](https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki) where the spent amount are not committed in the digest and transaction child A can be attached to parent X or parent Z of different amounts (of course there is the issue to re-bind the ANYPREVOUTANYSCRIPT on a parent by scriptpubkey only…). So I think this avoid to introduce a dependency in light of potential future consensus changes.",
      "created_at": "2023-06-16T00:00:32Z",
      "updated_at": "2023-06-16T00:46:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231638592",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231638592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231651784",
      "pull_request_review_id": 1482524666,
      "id": 1231651784,
      "node_id": "PRRC_kwDOAN28mc5JaYPI",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.",
      "path": "bip-0331.mediawiki",
      "position": 270,
      "original_position": 269,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There is no limit on the number of announced ancestors ?\r\n\r\nFrom my understanding, there is a bandwidth asymmetry in this design. A receiver can request an unbounded number of parents from the sender by sending a single GETDATA(wtixd), where the child transaction is deliberately spending a large number of in-mempool unconfirmed ancestors. As the ancestors are not linked without the child, I think the number can be beyond in-mempool ancestors limits.\r\n\r\nThose ancestors might have been previously announced by an inbound connection controlled by the adversary for a bandwidth cost of O(n), however the target node might have to spend a bandwidth cost of O(n*m), where m is the number of transaction-relay connections controlled by the adversary, if I’m correct ?",
      "created_at": "2023-06-16T00:22:44Z",
      "updated_at": "2023-06-16T00:46:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231651784",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231651784"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 270,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231652747",
      "pull_request_review_id": 1482524666,
      "id": 1231652747,
      "node_id": "PRRC_kwDOAN28mc5JaYeL",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 301,
      "original_position": 302,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the wtxid of the requested transaction is missing in the list, and therefore the “ancpkginfo” is uncomplete, should the peer be disconnected (as there is no way to dissociate it’s a unsolicited package) ?",
      "created_at": "2023-06-16T00:25:10Z",
      "updated_at": "2023-06-16T00:46:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231652747",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231652747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231653989",
      "pull_request_review_id": 1482524666,
      "id": 1231653989,
      "node_id": "PRRC_kwDOAN28mc5JaYxl",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 330,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "“previsously-received “ancpkginfo” message” for more clarity i think",
      "created_at": "2023-06-16T00:28:26Z",
      "updated_at": "2023-06-16T00:46:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231653989",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231653989"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231657260",
      "pull_request_review_id": 1482524666,
      "id": 1231657260,
      "node_id": "PRRC_kwDOAN28mc5JaZks",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.",
      "path": "bip-0331.mediawiki",
      "position": 331,
      "original_position": 332,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Here I think you’re restraining some partial package download, where none of your peers have all the ancestors for a known child transaction however the unions of all the available transactions announced by our peers give you such complete package.\r\n\r\nI think that’s okay and the behavior of “notfound(MSG_PKGTXND)” can be changed by bumping the version bits.",
      "created_at": "2023-06-16T00:35:20Z",
      "updated_at": "2023-06-16T00:46:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231657260",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231657260"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 331,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231658625",
      "pull_request_review_id": 1482524666,
      "id": 1231658625,
      "node_id": "PRRC_kwDOAN28mc5JaZ6B",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": 351,
      "original_position": 352,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think here the receiver behavior can be more liberal and unsolicited “pkgtxns” shouldn’t be treated as a disconnection. A sender implementing some “prediction algorithm”, in the sense knowing the parent is going to be rejected on its own (e.g due to feerate under feefilter) might optimize by sending a full-package, without opt-in from your peer. This behavior could be legit as it’s RTT/bandwidth consumed on its side.",
      "created_at": "2023-06-16T00:39:01Z",
      "updated_at": "2023-06-16T00:46:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231658625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231658625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 351,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231659797",
      "pull_request_review_id": 1482524666,
      "id": 1231659797,
      "node_id": "PRRC_kwDOAN28mc5JaaMV",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash (defined above) of the wtxids in the getpkgtxns request.\n+\n+# This inv type should only be used in \"notfound\" messages, i.e. \"inv(MSG_PKGTXNS)\" and \"getdata(MSG_PKGTXNS)\" must never be sent.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 362,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can precise peer will be disconnected.",
      "created_at": "2023-06-16T00:42:21Z",
      "updated_at": "2023-06-16T00:46:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231659797",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231659797"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 362,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231663595",
      "pull_request_review_id": 1482564746,
      "id": 1231663595,
      "node_id": "PRRC_kwDOAN28mc5JabHr",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.",
      "path": "bip-0331.mediawiki",
      "position": 144,
      "original_position": 142,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220651721,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> As for potential censorship, that is solved by caching \"reconsiderable\" rejections separately (see m_recent_rejects_reconsiderable in PR). You can relay a separate package that is the ancestor set of the additional child, and its rejection should not affect whether another overlapping ancestor package is considered/accepted.\r\n\r\nYes sounds correct to process each cpfp’s ancestor set separately.",
      "created_at": "2023-06-16T00:51:18Z",
      "updated_at": "2023-06-16T00:51:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231663595",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231663595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 144,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231664984",
      "pull_request_review_id": 1482566511,
      "id": 1231664984,
      "node_id": "PRRC_kwDOAN28mc5JabdY",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 165,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220670659,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Er, what exactly is the \"cheap bandwidth saving?\" Are you suggesting to increase the field size?\r\n\r\nYes increasing the filed size to a u64 or u128 to have more bits available for mechanism.\r\n\r\n>  I think 32 is plenty, and the worst case scenario is defining a new message and sending another few bytes once per connection.\r\n\r\nSure we can always define a new message, or an extension of it at the price of more p2p code surface and complexity (and note all the bikeshedding with `fRelay`). Sounds package relay will get more complex not less, though happy to take the bet and wait when this hypothetical super-complex future does happen :)",
      "created_at": "2023-06-16T00:54:53Z",
      "updated_at": "2023-06-16T00:54:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231664984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231664984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231667295",
      "pull_request_review_id": 1482569630,
      "id": 1231667295,
      "node_id": "PRRC_kwDOAN28mc5JacBf",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.",
      "path": "bip-0331.mediawiki",
      "position": 221,
      "original_position": 220,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220712671,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Receiver initiated imo helps out in the sense of it fits somewhat more neatly in the current orphan/feefilter paradigm?\r\n\r\nCorrect the update frequency sounds another dimension to think about to evaluate bandwidth consumption.\r\n\r\n> Yeah so sender-initiated is not being proposed here. The general philosophy is that since everything here is receiver-initiated in certain situations, and we are careful to not waste bandwidth in honest cases in the implementation, hopefully we are not blowing up bandwidth.\r\n\r\nNote here I’m not thinking to evaluate future hypothetical sender-initiated though the performance of this current receiver-initiated version, especially the burden than rebroadcast frequency of Lightning node might throw on the base layer. Yeah not a blocker right now to deploy, I might start to do simulation by myself once I’m good reviewing the code, really interested to have a clearer picture, and tweak back in consequence Lightning backend.",
      "created_at": "2023-06-16T01:00:17Z",
      "updated_at": "2023-06-16T01:00:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1231667295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231667295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 221,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1234083845",
      "pull_request_review_id": 1486266119,
      "id": 1234083845,
      "node_id": "PRRC_kwDOAN28mc5JjqAF",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.",
      "path": "bip-0331.mediawiki",
      "position": 270,
      "original_position": 269,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1231651784,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> A receiver can request an unbounded number of parents from the sender by sending a single GETDATA(wtixd), where the child transaction is deliberately spending a large number of in-mempool unconfirmed ancestors.\r\n\r\nThis doesn't make sense to me. The max size of an ancpkginfo is the maximum number of ancestors a tx could have. For default bitcoin core, that's 25.\r\n\r\nI don't think we should add a limit like 25 to the protocol spec because it's a policy value and configurable. In the implementation, sender side is bounded by what your ancestor package limits are. On the receiver side, if you're reading an ancpkginfo and see it has >25 items in the list (i.e. higher than your ancestor limits), you can just drop it on the floor. This is more helpful than getting a notfound (e.g. if you tell them ahead of time that you only want lists up to 10 wtxids long).",
      "created_at": "2023-06-19T13:40:10Z",
      "updated_at": "2023-06-19T13:40:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1234083845",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1234083845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 270,
      "original_line": 270,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1234084673",
      "pull_request_review_id": 1486267075,
      "id": 1234084673,
      "node_id": "PRRC_kwDOAN28mc5JjqNB",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 301,
      "original_position": 302,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1231652747,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, that is an unsolicited ancpkginfo.",
      "created_at": "2023-06-19T13:40:42Z",
      "updated_at": "2023-06-19T13:40:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1234084673",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1234084673"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1234090307",
      "pull_request_review_id": 1486275417,
      "id": 1234090307,
      "node_id": "PRRC_kwDOAN28mc5JjrlD",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.",
      "path": "bip-0331.mediawiki",
      "position": 331,
      "original_position": 332,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1231657260,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> where none of your peers have all the ancestors for a known child transaction however the unions of all the available transactions announced by our peers give you such complete package.\r\n\r\nWe should be able to hope that at least one of the peers was able to keep the list of wtxids they told us about in their ancpkginfo message. If they evicted some ancestors, they also evicted the child we're trying to resolve with them.\r\n\r\nAlso, this definition of how the \"getpkgtxns\" message works does not preclude having logic for retrieving packages from multiple peers in your implementation.",
      "created_at": "2023-06-19T13:45:10Z",
      "updated_at": "2023-06-19T13:45:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1234090307",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1234090307"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 331,
      "original_line": 331,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1234096569",
      "pull_request_review_id": 1486286216,
      "id": 1234096569,
      "node_id": "PRRC_kwDOAN28mc5JjtG5",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": 351,
      "original_position": 352,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1231658625,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I can see a \"prediction algorithm\" for proactive, sender-initiated *announcements* being appropriate and more effective. But I don't see why it would make sense to do this for full transaction data. Can you provide a specific reason why this would be needed?",
      "created_at": "2023-06-19T13:50:24Z",
      "updated_at": "2023-06-19T13:50:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1234096569",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1234096569"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 351,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1235492806",
      "pull_request_review_id": 1488512828,
      "id": 1235492806,
      "node_id": "PRRC_kwDOAN28mc5JpB_G",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1229783524,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sounds like clusters are unlikely to go this high anyways, so let's keep it at 100 for this and the other reasons above",
      "created_at": "2023-06-20T16:07:49Z",
      "updated_at": "2023-06-20T16:07:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1235492806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1235492806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1235516974",
      "pull_request_review_id": 1488550244,
      "id": 1235516974,
      "node_id": "PRRC_kwDOAN28mc5JpH4u",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.\n+\n+# The inv type should not be used in announcements, i.e. \"inv(MSG_ANCPKGINFO)\" must never be sent.  If a \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers agreed to ancestor package relay. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which ancestor package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.<ref>'''Why isn't package relay negotiation required for getpkgtxns?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 330,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225194338,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Marking as resolved based on https://github.com/bitcoin/bips/pull/1382#discussion_r1235492806",
      "created_at": "2023-06-20T16:29:23Z",
      "updated_at": "2023-06-20T16:29:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1235516974",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1235516974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251860151",
      "pull_request_review_id": 1512630210,
      "id": 1251860151,
      "node_id": "PRRC_kwDOAN28mc5Knd63",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.",
      "path": "bip-0331.mediawiki",
      "position": 133,
      "original_position": 131,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225141794,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm going to resolve this for now, but let me know if you still feel that I should change this. Right now the text is \"The package information round is used to help a receiver learn what transactions are in a package and decide whether they want to download them.\"",
      "created_at": "2023-07-04T10:49:56Z",
      "updated_at": "2023-07-04T10:49:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251860151",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251860151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 133,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251861477",
      "pull_request_review_id": 1512632349,
      "id": 1251861477,
      "node_id": "PRRC_kwDOAN28mc5KnePl",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 301,
      "original_position": 302,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1231652747,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added an extra sentence about the fact that the last transaction is required to be the transaction we're talking about.",
      "created_at": "2023-07-04T10:51:15Z",
      "updated_at": "2023-07-04T10:51:16Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251861477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251861477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 301,
      "original_line": 301,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251861603",
      "pull_request_review_id": 1512632553,
      "id": 1251861603,
      "node_id": "PRRC_kwDOAN28mc5KneRj",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 330,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1231653989,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done",
      "created_at": "2023-07-04T10:51:24Z",
      "updated_at": "2023-07-04T10:51:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251861603",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251861603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 330,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251861710",
      "pull_request_review_id": 1512632734,
      "id": 1251861710,
      "node_id": "PRRC_kwDOAN28mc5KneTO",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash (defined above) of the wtxids in the getpkgtxns request.\n+\n+# This inv type should only be used in \"notfound\" messages, i.e. \"inv(MSG_PKGTXNS)\" and \"getdata(MSG_PKGTXNS)\" must never be sent.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 362,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1231659797,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added",
      "created_at": "2023-07-04T10:51:31Z",
      "updated_at": "2023-07-04T10:51:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251861710",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251861710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 362,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251863205",
      "pull_request_review_id": 1512634983,
      "id": 1251863205,
      "node_id": "PRRC_kwDOAN28mc5Kneql",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 274,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1231638592,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Useful extra context, though I didn't add any of this to the text.",
      "created_at": "2023-07-04T10:53:04Z",
      "updated_at": "2023-07-04T10:53:04Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251863205",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251863205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 274,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251865543",
      "pull_request_review_id": 1512638481,
      "id": 1251865543,
      "node_id": "PRRC_kwDOAN28mc5KnfPH",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 86,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225103264,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I suppose it's true that this protocol is not going to have fewer round trips in every possible case of orphans, but we wouldn't have a way of detecting those cases on the receiver end.",
      "created_at": "2023-07-04T10:55:13Z",
      "updated_at": "2023-07-04T10:55:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251865543",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251865543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 86,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251868691",
      "pull_request_review_id": 1512643167,
      "id": 1251868691,
      "node_id": "PRRC_kwDOAN28mc5KngAT",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 165,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220670659,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've changed this to u64.\r\n\r\n> happy to take the bet and wait when this hypothetical super-complex future does happen :)\r\n\r\nhaha :handshake: If this super-complex future happens and we run out of package types, I'll send you sats via each protocol",
      "created_at": "2023-07-04T10:57:46Z",
      "updated_at": "2023-07-04T10:57:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251868691",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251868691"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251870848",
      "pull_request_review_id": 1512646359,
      "id": 1251870848,
      "node_id": "PRRC_kwDOAN28mc5KngiA",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+===Generic Package Relay===\n+\n+Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+This protocol can be extended to include more types of package information in the future, while\n+continuing to use the same messages for transaction data download.\n+[[File:./bip-0331/generic_package_relay.png|600px]]\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support up to 32 types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+===Ancestor Package Information===\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANCPKG = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Intended Protocol Flow===",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 189,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "7118e550cf2e08641fa7b76c532c85153e8dc751",
      "in_reply_to_id": 1193155496,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've changed this to \"Protocol Flow Examples\" but kept them in the same place. I'm thinking they might be helpful earlier on as a quick way to learn how the dialogue looks. Lmk if you disagree though!",
      "created_at": "2023-07-04T10:59:46Z",
      "updated_at": "2023-07-04T10:59:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251870848",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251870848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 181,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251873108",
      "pull_request_review_id": 1512649819,
      "id": 1251873108,
      "node_id": "PRRC_kwDOAN28mc5KnhFU",
      "diff_hunk": "@@ -0,0 +1,428 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+(2) Eliminate the need for txid-based transaction relay and make orphan handling more robust.\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: package information and transaction data download.\n+A package information round is used to help a receiver learn what transactions are in a package and\n+whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. Omit the \"getpkgtxns\" and \"pkgtxns\" messages and just download the\n+transactions individually using existing messages. While this option is a potential fallback if\n+batched transaction download fails for some reason, it shouldn't be used as the default because it\n+always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why send one message per version instead of sending a single message for the highest\n+supported version?''' It should also be possible to support some subset of the existing package\n+types. For example, if a node's mempool policy doesn't support or a node implementation stops\n+supporting version n, it should be easy to announce support for version n-1, but not version n,\n+packages.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Ancestor Package Relay allows nodes to send and request a transaction's list of unconfirmed\n+ancestors.  Nodes indicate support for Ancestor Package Relay by adding the\n+<code>PKG_RELAY_ANC = (1 << 0)</code> bit in their \"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions (which may or may\n+not be a true package).\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants a \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction should be the last item in the list.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 310,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "0a46f7d4cb997fdd7a228ab280821adbcbc7565b",
      "in_reply_to_id": 1225180817,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updated to clarify that the last transaction must be the requested one, the rest can be in any order (nodes should not disconnect or punish), but sender \"should\" sort topologically for the receiver's convenience, and that can be achieved through sorting by acceptance order.",
      "created_at": "2023-07-04T11:01:56Z",
      "updated_at": "2023-07-04T11:01:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1251873108",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1251873108"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1255205696",
      "pull_request_review_id": 1517713387,
      "id": 1255205696,
      "node_id": "PRRC_kwDOAN28mc5K0OtA",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can precise `GETPKGTXNS` must not be empty, enforced as a disconnection condition (`Misbehaving(*peer, 100, …)`) on `GETPKGTXNS` reception (if i’m on the right commit).",
      "created_at": "2023-07-07T03:39:00Z",
      "updated_at": "2023-07-07T03:39:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1255205696",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1255205696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1272016013",
      "pull_request_review_id": 1543102660,
      "id": 1272016013,
      "node_id": "PRRC_kwDOAN28mc5L0WyN",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1255205696,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think it's implemented this way? `if (num_txns == 0) return;` means it's ignored.",
      "created_at": "2023-07-24T09:48:49Z",
      "updated_at": "2023-07-24T09:48:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1272016013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1272016013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1281320195",
      "pull_request_review_id": 1558091736,
      "id": 1281320195,
      "node_id": "PRRC_kwDOAN28mc5MX2UD",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1255205696,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah would have to check back the code here.",
      "created_at": "2023-08-02T02:41:11Z",
      "updated_at": "2023-08-02T02:41:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1281320195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1281320195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282357850",
      "pull_request_review_id": 1559745990,
      "id": 1282357850,
      "node_id": "PRRC_kwDOAN28mc5Mbzpa",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 35,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nthe node's ability to determine which transactions to include in the mempool, since it cannot take\r\n```",
      "created_at": "2023-08-02T19:55:07Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282357850",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282357850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282359269",
      "pull_request_review_id": 1559745990,
      "id": 1282359269,
      "node_id": "PRRC_kwDOAN28mc5Mbz_l",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 41,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nreplacement transaction directly, their transaction will simply be rejected by this mempool or evicted if already included. They\r\n```",
      "created_at": "2023-08-02T19:56:51Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282359269",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282359269"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282361539",
      "pull_request_review_id": 1559745990,
      "id": 1282361539,
      "node_id": "PRRC_kwDOAN28mc5Mb0jD",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 46,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nThis limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\r\nissues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\r\n```\r\ninability to consider package feerates also creates complexity in these protocols, I think important to note",
      "created_at": "2023-08-02T19:59:24Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282361539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282361539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282363418",
      "pull_request_review_id": 1559745990,
      "id": 1282363418,
      "node_id": "PRRC_kwDOAN28mc5Mb1Aa",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nPart of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\r\n```\r\nnot everything is fixed yet :)",
      "created_at": "2023-08-02T20:01:33Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282363418",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282363418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282367142",
      "pull_request_review_id": 1559745990,
      "id": 1282367142,
      "node_id": "PRRC_kwDOAN28mc5Mb16m",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 106,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nThis proposal makes orphan-resolution more efficient and no longer require txid-based relay.\r\n```\r\n\r\nwe don't really \"fetch orphans\", at least intentionally ",
      "created_at": "2023-08-02T20:06:04Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282367142",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282367142"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282408213",
      "pull_request_review_id": 1559745990,
      "id": 1282408213,
      "node_id": "PRRC_kwDOAN28mc5Mb_8V",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 312,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the \"ancpkginfo\" response list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\r\n```",
      "created_at": "2023-08-02T20:52:50Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282408213",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282408213"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282417371",
      "pull_request_review_id": 1559745990,
      "id": 1282417371,
      "node_id": "PRRC_kwDOAN28mc5McCLb",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash (defined above) of the wtxids in the getpkgtxns request.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 360,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash of the wtxids in the getpkgtxns request.\r\n```",
      "created_at": "2023-08-02T21:03:53Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282417371",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282417371"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282424520",
      "pull_request_review_id": 1559745990,
      "id": 1282424520,
      "node_id": "PRRC_kwDOAN28mc5McD7I",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 275,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure this first half is very persuasive, a node can lie and waste our bandwidth regardless. I think the latter half of the answer is the most sensible. ",
      "created_at": "2023-08-02T21:13:27Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282424520",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282424520"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282428280",
      "pull_request_review_id": 1559745990,
      "id": 1282428280,
      "node_id": "PRRC_kwDOAN28mc5McE14",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 235,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "we could just make this single-sha2...",
      "created_at": "2023-08-02T21:18:50Z",
      "updated_at": "2023-08-02T21:21:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1282428280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282428280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283024460",
      "pull_request_review_id": 1560823749,
      "id": 1283024460,
      "node_id": "PRRC_kwDOAN28mc5MeWZM",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.\n+\n+# As a notfound type, it indicates that the sender is unable to send all the transactions requested in a prior \"getpkgtxns\" message. The hash used is equal to the combined hash (defined above) of the wtxids in the getpkgtxns request.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 360,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282417371,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done",
      "created_at": "2023-08-03T10:50:39Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283024460",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283024460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283025013",
      "pull_request_review_id": 1560823749,
      "id": 1283025013,
      "node_id": "PRRC_kwDOAN28mc5MeWh1",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 312,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282408213,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added",
      "created_at": "2023-08-03T10:51:13Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283025013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283025013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 312,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283026910",
      "pull_request_review_id": 1560823749,
      "id": 1283026910,
      "node_id": "PRRC_kwDOAN28mc5MeW_e",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 275,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282424520,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Deleted the first sentence.",
      "created_at": "2023-08-03T10:53:07Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283026910",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283026910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 275,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283030135",
      "pull_request_review_id": 1560823749,
      "id": 1283030135,
      "node_id": "PRRC_kwDOAN28mc5MeXx3",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 106,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282367142,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "True, changed",
      "created_at": "2023-08-03T10:56:14Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283030135",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283030135"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283030728",
      "pull_request_review_id": 1560823749,
      "id": 1283030728,
      "node_id": "PRRC_kwDOAN28mc5MeX7I",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282363418,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "heh. changed",
      "created_at": "2023-08-03T10:56:51Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283030728",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283030728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283031993",
      "pull_request_review_id": 1560823749,
      "id": 1283031993,
      "node_id": "PRRC_kwDOAN28mc5MeYO5",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 46,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282361539,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added",
      "created_at": "2023-08-03T10:58:03Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283031993",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283031993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": 45,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 46,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283033578",
      "pull_request_review_id": 1560823749,
      "id": 1283033578,
      "node_id": "PRRC_kwDOAN28mc5MeYnq",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 41,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282359269,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2023-08-03T10:59:35Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283033578",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283033578"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 41,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283033646",
      "pull_request_review_id": 1560823749,
      "id": 1283033646,
      "node_id": "PRRC_kwDOAN28mc5MeYou",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 35,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282357850,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-08-03T10:59:40Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283033646",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283033646"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 35,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283041029",
      "pull_request_review_id": 1560823749,
      "id": 1283041029,
      "node_id": "PRRC_kwDOAN28mc5MeacF",
      "diff_hunk": "@@ -0,0 +1,426 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+(1) Help incentive-compatible transactions propagate.\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]",
      "path": "bip-0331.mediawiki",
      "position": 50,
      "original_position": 50,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "70605899186abc0debb7dcf534c21566357d985c",
      "in_reply_to_id": 1220626227,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added",
      "created_at": "2023-08-03T11:06:37Z",
      "updated_at": "2023-08-03T11:07:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1283041029",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283041029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 50,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285629908",
      "pull_request_review_id": 1564948477,
      "id": 1285629908,
      "node_id": "PRRC_kwDOAN28mc5MoSfU",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 235,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "c2da2cffd6021ee2d575cc7ded326b1df4307b80",
      "in_reply_to_id": 1282428280,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Changed",
      "created_at": "2023-08-07T09:40:46Z",
      "updated_at": "2023-08-07T09:40:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1285629908",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285629908"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1364405638",
      "pull_request_review_id": 1685929004,
      "id": 1364405638,
      "node_id": "PRRC_kwDOAN28mc5RUy2G",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions have the highest feerates, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool. They\n+also cannot attach a descendant to pay for replacing a conflicting transaction; it would be rejected\n+for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents a security\n+issue in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+The best solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan-fetching more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the double-sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint32_t || 4 || Bit field that is 32 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. The sender should - but is not required to - sort these wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+Peers are not trusted to provide correct information, so a reported low feerate should not stop a\n+node from downloading the package or verifying what the transactions' feerates actually are.\n+Additionally, a simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received pkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.",
      "path": "bip-0331.mediawiki",
      "position": 333,
      "original_position": 334,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "d07535cc3d6686bc37e72f267bc24c58cad49a12",
      "in_reply_to_id": 1229783524,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/28676/commits/4c9842999ed5e35d959f10185a7ca82194ec28c5#diff-1fc0f6b5081e8ed5dfa8bf230744ad08cc6f4c1147e98552f1f424b0492fe9bdR59 for reference to initial cluster mempool implementation",
      "created_at": "2023-10-18T19:17:18Z",
      "updated_at": "2023-10-18T19:17:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1364405638",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1364405638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 333,
      "original_line": 333,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1567733003",
      "pull_request_review_id": 2004255882,
      "id": 1567733003,
      "node_id": "PRRC_kwDOAN28mc5dcbUL",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions to include in the mempool, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool or\n+evicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\n+transaction; it would be rejected for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\n+issues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+Part of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan resolution more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+A simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the \"ancpkginfo\" response list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": 353,
      "original_position": 353,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"sendpackages\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\r\n```",
      "created_at": "2024-04-16T17:38:49Z",
      "updated_at": "2024-04-16T18:09:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1567733003",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1567733003"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 353,
      "original_line": 353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1567740006",
      "pull_request_review_id": 2004255882,
      "id": 1567740006,
      "node_id": "PRRC_kwDOAN28mc5dcdBm",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions to include in the mempool, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool or\n+evicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\n+transaction; it would be rejected for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\n+issues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+Part of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan resolution more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+A simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the \"ancpkginfo\" response list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.",
      "path": "bip-0331.mediawiki",
      "position": 357,
      "original_position": 357,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: here, \"notfound\" is quoted, but it is not in the next line. In contrast, when referring to `MSG_ANCPKGINFO == 0x7`, getdata is not quoted in any of the cases.\r\n\r\nIt may be good to make this consistent",
      "created_at": "2024-04-16T17:45:04Z",
      "updated_at": "2024-04-16T18:09:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1567740006",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1567740006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 357,
      "original_line": 357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1567750298",
      "pull_request_review_id": 2004255882,
      "id": 1567750298,
      "node_id": "PRRC_kwDOAN28mc5dcfia",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions to include in the mempool, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool or\n+evicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\n+transaction; it would be rejected for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\n+issues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+Part of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan resolution more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+A simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 303,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "in_reply_to_id": null,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Both peers both set\" sounds like both of the peers set two distinct things: \"Both peers both set this and that\", but here it is referring to both peers setting a single thing each (`PKG_RELAY_ANC` in this case).\r\n\r\nShouldn't this be: \"Both peers set\"? If so, this applies to multiple places in the doc",
      "created_at": "2024-04-16T17:54:20Z",
      "updated_at": "2024-04-16T18:09:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1567750298",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1567750298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568644939",
      "pull_request_review_id": 2005716238,
      "id": 1568644939,
      "node_id": "PRRC_kwDOAN28mc5df59L",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions to include in the mempool, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool or\n+evicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\n+transaction; it would be rejected for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\n+issues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+Part of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan resolution more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+A simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 303,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "in_reply_to_id": 1567750298,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh yes, this is a typo - I have an extra 'both'. Thanks!",
      "created_at": "2024-04-17T10:49:33Z",
      "updated_at": "2024-04-17T10:50:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1568644939",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568644939"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568645646",
      "pull_request_review_id": 2005716238,
      "id": 1568645646,
      "node_id": "PRRC_kwDOAN28mc5df6IO",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions to include in the mempool, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool or\n+evicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\n+transaction; it would be rejected for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\n+issues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+Part of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan resolution more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+A simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the \"ancpkginfo\" response list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": 353,
      "original_position": 353,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "in_reply_to_id": 1567733003,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think \"getpkgtxns\" is correct actually?",
      "created_at": "2024-04-17T10:50:13Z",
      "updated_at": "2024-04-17T10:50:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1568645646",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568645646"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 353,
      "original_line": 353,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568655538",
      "pull_request_review_id": 2005732746,
      "id": 1568655538,
      "node_id": "PRRC_kwDOAN28mc5df8iy",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions to include in the mempool, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool or\n+evicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\n+transaction; it would be rejected for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\n+issues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+Part of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan resolution more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+A simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the \"ancpkginfo\" response list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_PKGTXNS====\n+\n+# A new inv type (MSG_PKGTXNS == 0x6) is added, for use only in \"notfound\" messages pertaining to package transactions.",
      "path": "bip-0331.mediawiki",
      "position": 357,
      "original_position": 357,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "in_reply_to_id": 1567740006,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added quotes for all notfounds. thanks!",
      "created_at": "2024-04-17T10:58:21Z",
      "updated_at": "2024-04-17T10:58:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1568655538",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568655538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 357,
      "original_line": 357,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568665082",
      "pull_request_review_id": 2005748692,
      "id": 1568665082,
      "node_id": "PRRC_kwDOAN28mc5df-36",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions to include in the mempool, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool or\n+evicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\n+transaction; it would be rejected for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\n+issues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+Part of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan resolution more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+A simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": null,
      "original_position": 303,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "in_reply_to_id": 1567750298,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note that this is not the only place in the doc where \"Both peers both set\" appears",
      "created_at": "2024-04-17T11:07:03Z",
      "updated_at": "2024-04-17T11:07:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1568665082",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568665082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568669445",
      "pull_request_review_id": 2005756675,
      "id": 1568669445,
      "node_id": "PRRC_kwDOAN28mc5df_8F",
      "diff_hunk": "@@ -0,0 +1,429 @@\n+<pre>\n+  BIP: 331\n+  Layer: Peer Services\n+  Title: Ancestor Package Relay\n+  Author: Gloria Zhao <gloriajzhao@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0331\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2022-08-08\n+  License: BSD-3-Clause\n+</pre>\n+\n+==Abstract==\n+\n+Peer-to-peer protocol messages enabling nodes to request and relay the unconfirmed ancestor package\n+of a given transaction, and to request and relay transactions in batches.\n+\n+==Motivation==\n+\n+===Propagate High Feerate Transactions===\n+\n+Since v0.13, Bitcoin Core has used ancestor packages instead of individual transactions to evaluate\n+the incentive compatibility of transactions in the mempool\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7594 Add tracking of ancestor packages]</ref> and\n+selecting them for inclusion in blocks\n+<ref>[https://github.com/bitcoin/bitcoin/pull/7600 Select transactions using feerate-with-ancestors]</ref>.\n+Incentive-compatible mempool and miner policies help create a fair, fee-based market for block\n+space. While miners maximize transaction fees in order to earn higher block rewards, non-mining\n+users participating in transaction relay reap many benefits from employing policies that result in a\n+mempool with similar contents, including faster compact block relay and more accurate fee\n+estimation. Additionally, users may take advantage of mempool and miner policy to bump the priority\n+of their transactions by attaching high-fee descendants (Child Pays for Parent or CPFP).\n+\n+Only individually considering transactions for submission to the mempool creates a limitation in\n+the node's ability to determine which transactions to include in the mempool, since it cannot take\n+into account descendants until all the transactions are in the mempool. Similarly, it cannot use a\n+transaction's descendants when considering which of two conflicting transactions to keep (Replace by\n+Fee or RBF).\n+\n+When a user's transaction does not meet a mempool's minimum feerate and they cannot create a\n+replacement transaction directly, their transaction will simply be rejected by this mempool or\n+evicted if already included. They also cannot attach a descendant to pay for replacing a conflicting\n+transaction; it would be rejected for spending inputs that do not exist.\n+\n+This limitation harms users' ability to fee-bump their transactions. Further, it presents security and complexity\n+issues in contracting protocols which rely on presigned, time-sensitive transactions<ref>'''Examples of time-sensitive pre-signed transactions in L2 protocols.'''\n+* [https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions HTCL-Timeout in LN Penalty]\n+* [https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx Unvault Cancel in Revault]\n+* [https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction Refund Transaction in Discreet Log Contracts]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Updates in Eltoo]\n+* [https://github.com/ElementsProject/peerswap/blob/master/docs/peer-protocol.md#claim-transaction Claim Transactions in PeerSwap]\n+</ref> to prevent cheating.\n+In other words, a key security assumption of many contracting protocols is that all parties can\n+propagate and confirm transactions in a timely manner.  Increasing attention has been brought to\n+\"pinning attacks,\" a type of censorship in which the attacker uses mempool policy restrictions to\n+prevent a transaction from being relayed or getting mined.\n+<ref>'''Concerns for pinning attacks in L2 protocols'''\n+* [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020458.html Greg Sanders, \"Bringing a nuke to a knife fight: Transaction introspection to stop RBF pinning\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html Matt Corallo, \"RBF Pinning with Counterparties and Competing Interest\"]\n+* [https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html Antoine Riard, \"Pinning : The Good, The Bad, The Ugly\"]\n+* [https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md Bastien Teinturier, \"Pinning Attacks\"]\n+* [https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1 Greg Sanders, \"Eltoo Pinning\"]\n+</ref>\n+\n+These transactions must meet a certain confirmation target to be effective, but their feerates\n+are negotiated well ahead of broadcast time. If the forecast feerate was too low and no\n+fee-bumping options are available, attackers can steal money from their counterparties.  Always\n+overestimating fees may sidestep this issue (but only while mempool traffic is low and\n+predictable), but this solution is not guaranteed to work and wastes users' money. For some attacks,\n+the available defenses require nodes to have a bird's-eye view of Bitcoin nodes' mempools, which is\n+an unreasonable security requirement.\n+\n+Part of the solution is to enable nodes to consider packages of transactions as a unit, e.g. one or\n+more low-fee ancestor transactions with a high-fee descendant, instead of separately. A package-aware\n+mempool policy can help determine if it would actually be economically rational to accept a\n+transaction to the mempool if it doesn't meet fee requirements individually. Network-wide adoption\n+of these policies would create a more purely-feerate-based market for block space and allow\n+contracting protocols to adjust fees (and therefore mining priority) at broadcast time.\n+\n+Theoretically, developing a safe and incentive-compatible package mempool acceptance policy is\n+sufficient to solve this issue. Nodes could opportunistically accept packages (e.g. by trying\n+combinations of transactions rejected from their mempools), but this practice would likely be\n+inefficient at best and open new Denial of Service attacks at worst.  As such, this proposal\n+suggests adding new p2p messages enabling nodes to request and share package-validation-related\n+information with one another, resulting in a more efficient and reliable way to propagate packages.\n+\n+===Handle Orphans Better===\n+\n+Txid-based transaction relay is problematic since a transaction's witness may be malleated without\n+changing its txid; a node cannot use txid to deduplicate transactions it has already downloaded\n+or validated. Ideally, two nodes that both support BIP339 wtxid-based transaction relay shouldn't\n+ever need to use txid-based transaction relay.\n+\n+A single use case of txid-based relay remains: handling \"orphan\" transactions that spend output(s)\n+from an unconfirmed transaction the receiving node is unaware of. Orphan transactions are very\n+common for new nodes that have just completed Initial Block Download and do not have an up-to-date\n+mempool. Nodes also download transactions from multiple peers. If the peer from which a child\n+transaction was requested responds faster than the peer from which its parent was requested, that\n+child is seen as an orphan transaction.\n+\n+Nodes may handle orphans by storing them in a cache and requesting any missing parent(s) by txid\n+(prevouts specify txid, not wtxid). These parents may end up being orphans as well, if they also\n+spend unconfirmed inputs that the node is unaware of. This method of handling orphans is problematic\n+for two reasons: it requires nodes to allocate memory for unvalidated data received on the p2p\n+network and it relies on txid-based relay between two wtxid-relay peers.\n+\n+This proposal makes orphan resolution more efficient and no longer require txid-based relay.\n+\n+==Definitions==\n+\n+Given any two transactions Tx0 and Tx1 where Tx1 spends an output of Tx0, Tx0 is a '''parent''' of\n+Tx1 and Tx1 is a '''child''' of Tx0.\n+\n+A transaction's '''ancestors''' include, recursively, its parents, the parents of its parents, etc.\n+A transaction's '''descendants''' include, recursively, its children, the children of its children,\n+etc. A transaction's parent is its ancestor, but an ancestor is not necessarily a parent.\n+\n+A '''package''' is a list of transactions, representable by a connected Directed Acyclic\n+Graph (a directed edge exists between a transaction that spends the output of another transaction).\n+In this proposal, a package is limited to unconfirmed transactions.\n+\n+An '''ancestor package''' consists of an unconfirmed transaction with all of its unconfirmed\n+ancestors.\n+\n+In a '''topologically sorted''' package, each parent appears somewhere in the list before its child.\n+\n+==Specification==\n+\n+Ancestor Package Relay includes two parts: a package information round and a transaction data\n+download round.\n+The package information round is used to help a receiver learn what transactions are in a package and\n+decide whether they want to download them. The transaction data round is used to help a node download\n+multiple transactions in one message instead of as separate messages.\n+<ref>'''Why are package information and transaction data rounds both necessary?'''\n+\n+Several alternative designs were considered. One should measure alternative solutions based on the\n+resources used to communicate (not necessarily trustworthy) information: We would like to minimize\n+network bandwidth, avoid downloading a transaction more than once, avoid downloading transactions\n+that are eventually rejected, and minimize storage allocated for not-yet-validated transactions.\n+\n+<br />\n+\n+'''No Package Information Round:''' One proposal is to just use the child's wtxid to refer to the\n+package and always send the entire package together, skipping the package information round.\n+However, this protocol would make it very likely for honest nodes to redownload duplicate\n+transactions. See the following example, where the high-feerate ancestors were already downloaded\n+and accepted individually.\n+\n+[[File:./bip-0331/no_package_info.png|600px]]\n+<br />\n+\n+'''Package Information Only:''' Just having package information gives enough information for the\n+receiver to accept the packages. That is, rather than using \"getpkgtxns\" and \"pkgtxns\" messages,\n+send \"getdata\" and download the transactions individually. While this option is a potential fallback\n+if batched transaction download fails for some reason, it shouldn't be used as the default because\n+it always requires storage of unvalidated transactions.\n+[[File:./bip-0331/package_info_only.png|1000px]]\n+</ref>\n+\n+Package relay is negotiated between two peers during the version handshake using a \"sendpackages\"\n+message. The versions field within \"sendpackages\" is interpreted as a bitfield; peers may relay\n+multiple versions of packages. Package relay requires both peers to support wtxid-based relay\n+because package transactions are referenced by their wtxids.\n+<ref>'''Why do we need multiple versions? Why can't we just support arbitrary packages?'''\n+Attempting to support arbitrary packages in mempool validation may result in very complex logic, new\n+Denial of Service attack vectors, and policy limitations that could be leveraged to censor\n+transactions (aka \"pinning attacks\"). This protocol is extensible to support other types of\n+packages based on future desired use cases. Future package information messages may describe\n+different types of packages and/or contain more information than a list of wtxids, e.g. feerate or\n+relationships between transactions.</ref>\n+<ref>'''Why use a bitfield instead of a numbering system?'''\n+It should be possible to support some subset of the existing package types.</ref>\n+\n+[[File:./bip-0331/version_negotiation.png|400px]]\n+\n+Nodes indicate support for batched transaction data round (\"getpkgtxns\", \"pkgtxns\", and\n+\"MSG_PKGTXNS\") using the <code>PKG_RELAY_PKGTXNS = (1 << 0)</code> bit in their \"sendpackages\"\n+messages during version handshake. They indicate support for the ancestor package information\n+round (\"ancpkginfo\", \"MSG_ANCPKGINFO\") using the <code>PKG_RELAY_ANC = (1 << 1)</code> bit in their\n+\"sendpackages\" messages during version handshake.\n+\n+===Protocol Flow Examples===\n+\n+This package relay protocol satisfies both use cases (orphan transaction handling and high-feerate\n+transaction paying for low-feerate ancestors).\n+\n+====Orphan Transaction Handling====\n+\n+Upon receiving an orphan transaction, a node may request ancestor package information delineating\n+the wtxids of the transaction's unconfirmed ancestors. This is done without using txid-based relay.\n+The package information can be used to request transaction data. As these transactions are dependent\n+upon one another to be valid, the transactions can be requested and sent as a batch.\n+\n+Contrast this protocol with legacy orphan handling, which requires requesting the missing\n+transactions by their txids and may require new round trips for each generation of missing parents.\n+[[File:./bip-0331/orphan_handling_flow.png|1000px]]\n+\n+====Fee-Bumped Transactions====\n+\n+Too-low-feerate transactions (i.e. below the node's minimum mempool feerate) with high-feerate\n+descendants can also be relayed this way. If the peers are using BIP133 fee filters and a\n+low-feerate transaction is below the node's fee filter, the sender will not announce it. The\n+high-feerate transaction will be sent by the sender, and received and handled as an orphan by the\n+receiver, the transactions are validated as a package, and so the protocol naturally works for this\n+use case.\n+\n+This does not mean BIP133 is required for package relay to work, provided that nodes do not\n+immediately reject transactions previously found to be too low feerate. If the low-feerate\n+transaction was sent and rejected, the receiver should later re-request and accept it after learning\n+that it is the ancestor of another transaction, and that they meet the receiver's mempool policy\n+requirements when validated together.\n+\n+[[File:./bip-0331/package_cpfp_flow.png|600px]]\n+\n+This protocol is receiver-initiated only; nodes do not proactively announce packages to their peers.\n+<ref>'''Why no sender-initiated protocol?''' Sender-initiated package\n+relay can, theoretically, save a round trip by notifying the receiver ahead of time that they will\n+probably need to request and validate a group of transactions together in order for them to be\n+accepted. As with any proactive communication, there is a chance that the receiver already knows\n+this information, so this network bandwidth may be wasted. Shortened latency is less significant\n+than wasted bandwidth.\n+\n+The logic used to decide when to announce a package proactively determines whether it is a net\n+increase or decrease for overall bandwidth usage. However, it is difficult to design anything to\n+save bandwidth without any idea of what its bandwidth usage actually looks like in practice. No\n+historical data is available, as one of the primary goals of this protocol is to enable\n+currently-rejected transactions to propagate. After deploying receiver-initiated package relay, we\n+can observe its usage and then introduce a sender-initiated package relay protocol informed by data\n+collected from the p2p network.</ref>\n+\n+===Combined Hash===\n+\n+A \"combined hash\" serves as a unique \"package id\" for some list of transactions and helps provide a\n+meaningful but short \"notfound\" response to \"getpkgtxns.\"\n+\n+The combined hash of a package of transactions is equal to the sha256 hash of each transaction's\n+wtxid concatenated in lexicographical order.\n+\n+===New Messages===\n+\n+Four new protocol messages and two inv types are added.\n+\n+====sendpackages====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||  Purpose\n+|-\n+|versions || uint64_t || 4 || Bit field that is 64 bits wide, denoting the package versions supported by the sender.\n+|-\n+|}\n+\n+# The \"sendpackages\" message has the structure defined above, with pchCommand == \"sendpackages\".\n+\n+# During version handshake, nodes should send one \"sendpackages\" message indicating they support package relay, with the versions field indicating which versions they support.\n+\n+# The \"sendpackages\" message MUST be sent before sending a \"verack\" message. If a \"sendpackages\" message is received after \"verack\", the sender may be disconnected.\n+\n+# Upon successful connection (\"verack\" sent by both peers), a node may relay packages with the peer if they did not set \"fRelay\" to false in the \"version\" message, both peers sent \"wtxidrelay\", and both peers sent \"sendpackages\" for matching version bit(s). Unknown bits (including versions==0) should be ignored. Peers should relay packages corresponding to versions that both sent \"sendpackages\" for.<ref>'''Is it ok to send \"sendpackages\" to a peer that specified fRelay=false in their \"version\" message?'''\n+Yes, this is allowed in order to reduce the number of negotiation steps. This means nodes can\n+announce features without first checking what the other peer has sent, and then apply negotiation\n+logic at the end based on what was sent and received. See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020510.html this discussion].\n+</ref>\n+\n+====ancpkginfo====\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"ancpkginfo\" message has the structure defined above, with pchCommand == \"ancpkginfo\".\n+\n+# The \"txns\" field should contain a list of wtxids which constitute the ancestor package of the last wtxid. For the receiver's convenience, the sender should - but is not required to - sort the wtxids in topological order. The topological sort can be achieved by sorting the transactions by mempool acceptance order (if parents are always accepted before children). Apart from the last wtxid which is used to learn which transaction the message corresponds to, there is no enforced ordering. Nodes should not disconnect or punish a peer who provides a list not sorted in topological order.<ref>'''Why not include feerate information to help the receiver decide whether these transactions are worth downloading?'''\n+A simple feerate is typically insufficient; the receiver must also know the dependency\n+relationships between transactions and their respective sizes.\n+</ref><ref>'''Should a peer be punished if they provide incorrect package info, e.g. a list of unrelated transactions?'''\n+Ideally, there should be a way to enforce that peers are providing correct information to each\n+other. However, two peers may have different views of what a transaction's unconfirmed ancestors\n+are based on their chainstate. For example, during a reorg or when two blocks are found at the same\n+time, one peer may see a transaction as confirmed while the other peer does not.\n+As such, it is impossible to accurately enforce this without also knowing the peer's chainstate.\n+It was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020493.html originally proposed]\n+to include a block hash in \"ancpkginfo\" to avoid unwarranted disconnections. However, it does not\n+make much sense to stop or delay transaction data requests due to mismatched chainstates, and the\n+chainstate may change again between package information and transaction data rounds. Instead,\n+differences in chainstate should be handled at the validation level. The node has already spent\n+network bandwidth downloading these transactions; it should make a best effort to validate them.\n+See [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-June/020558.html discussion].\n+</ref><ref>'''Why not require topological order?'''\n+It is not possible to determine whether a list of transactions is topologically sorted without first\n+establishing that the list contains a full ancestor package. It is not possible to determine whether\n+a list of transactions contains a full ancestor package without knowing what the chainstate is.\n+</ref>\n+\n+# Upon receipt of a \"ancpkginfo\" message, the node may use it to request the transactions it does not already have (e.g. using \"getpkgtxns\" or \"tx\").\n+\n+# Upon receipt of a malformed \"ancpkginfo\" message, the sender may be disconnected. An \"ancpkginfo\" message is malformed if it contains duplicate wtxids or conflicting transactions (spending the same inputs). The receiver may learn that a package info was malformed after downloading the transactions.\n+\n+# A node MUST NOT send a \"ancpkginfo\" message that has not been requested by the recipient. Upon receipt of an unsolicited \"ancpkginfo\", a node may disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If an \"ancpkginfo\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====MSG_ANCPKGINFO====\n+\n+# A new inv type (MSG_ANCPKGINFO == 0x7) is added, for use only in getdata requests pertaining to ancestor packages.\n+\n+# As a getdata request type, it indicates that the sender wants an \"ancpkginfo\" containing all of the unconfirmed ancestors of a transaction, referenced by wtxid.\n+\n+# Upon receipt of a \"getdata(MSG_ANCPKGINFO)\" request, the node should respond with an \"ancpkginfo\" message corresponding to the transaction's unconfirmed ancestor package, or with \"notfound\".  The wtxid of the requested transaction must be the last item in the \"ancpkginfo\" response list, as the last item is used to determine which transaction the \"ancpkginfo\" pertains to.\n+\n+# The inv type must only be used in a \"getdata\" message. An \"inv(MSG_ANCPKGINFO)\" must never be sent.  If an \"inv(MSG_ANCPKGINFO)\" is received, the sender may be disconnected.\n+\n+# This inv type must only be used if both peers both set <code>PKG_RELAY_ANC</code> in their \"sendpackages\" message. If a \"getdata\" message with type MSG_ANCPKGINFO is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====getpkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions requested.\n+|-\n+|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in the package.\n+|}\n+\n+# The \"getpkgtxns\" message has the structure defined above, with pchCommand == \"getpkgtxns\".\n+\n+# A \"getpkgtxns\" message should be used to request some list of transactions specified by witness transaction id. It indicates that the node wants to receive either all the specified transactions or none of them. This message is intended to allow nodes to avoid downloading and storing transactions that cannot be validated without each other. The list of transactions does not need to correspond to a previously-received ancpkginfo message.\n+\n+# Upon receipt of a \"getpkgtxns\" message, a node should respond with either a \"pkgtxns\" containing all of the requested transactions in the same order specified in the \"getpkgtxns\" request or one \"notfound\" message of type MSG_PKGTXNS and combined hash of all of the wtxids in the \"getpkgtxns\" request (only one \"notfound\" message and nothing else), indicating one or more of the transactions is unavailable.\n+\n+# A \"getpkgtxns\" message must contain at most 100 wtxids. Upon receipt of a \"getpkgtxns\" message with more than 100 wtxids, a node may ignore the message (to avoid calculating the combined hash) and disconnect the sender.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.\n+\n+====pkgtxns====\n+\n+{|\n+|  Field Name  ||  Type  ||  Size  ||   Purpose\n+|-\n+|txns_length||CompactSize||1 or 3 bytes|| The number of transactions provided.\n+|-\n+|txns||List of transactions||variable|| The transactions in the package.\n+|}\n+\n+# The \"pkgtxns\" message has the structure defined above, with pchCommand == \"pkgtxns\".\n+\n+# A \"pkgtxns\" message should contain the transaction data requested using \"getpkgtxns\".\n+\n+# A \"pkgtxns\" message should only be sent to a peer that requested the package using \"getpkgtxns\". If a node receives an unsolicited package, it may choose to validate the transactions or not, and the sender may be disconnected.\n+\n+# This message must only be used if both peers both set <code>PKG_RELAY_PKGTXNS</code> in their \"sendpackages\" message. If a \"getpkgtxns\" message is received from a peer with which this type of package relay was not negotiated, no response should be sent and the sender may be disconnected.",
      "path": "bip-0331.mediawiki",
      "position": 353,
      "original_position": 353,
      "commit_id": "92c07f57f4ccb09da8f8ecde01432a5a9e68f5a1",
      "original_commit_id": "02ec218c7857ef60914e9a3d383b68caf987f70b",
      "in_reply_to_id": 1567733003,
      "user": {
        "login": "sr-gi",
        "id": 6665628,
        "node_id": "MDQ6VXNlcjY2NjU2Mjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6665628?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sr-gi",
        "html_url": "https://github.com/sr-gi",
        "followers_url": "https://api.github.com/users/sr-gi/followers",
        "following_url": "https://api.github.com/users/sr-gi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sr-gi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sr-gi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sr-gi/subscriptions",
        "organizations_url": "https://api.github.com/users/sr-gi/orgs",
        "repos_url": "https://api.github.com/users/sr-gi/repos",
        "events_url": "https://api.github.com/users/sr-gi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sr-gi/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is it? This is part of the \"pkgtxns\" section, so it would make sense to be referring to the message that is being talked about. That is, at least, how this note is handled in every other message section that includes it throughout the doc.\r\n\r\nAlso notice that, as is, this is the exact same text as in point 5 of \"getpkgtxns\"",
      "created_at": "2024-04-17T11:11:19Z",
      "updated_at": "2024-04-17T11:11:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1382#discussion_r1568669445",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1568669445"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1382"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 353,
      "original_line": 353,
      "side": "RIGHT"
    }
  ]
}