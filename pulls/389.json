{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/389",
    "id": 70457774,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NzA0NTc3NzQ=",
    "html_url": "https://github.com/bitcoin/bips/pull/389",
    "diff_url": "https://github.com/bitcoin/bips/pull/389.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/389.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/389",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/389/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/389/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/389/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/20a842244bbdf85c36b16544def261b9da0948da",
    "number": 389,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "BIP 152: Compact Block Relay",
    "user": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is a first draft of BIP 152 - Compact Block Relay.\n",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2016-05-18T01:43:46Z",
    "updated_at": "2016-05-23T10:30:36Z",
    "closed_at": "2016-05-23T10:30:36Z",
    "mergeable_state": "unknown",
    "merged_at": "2016-05-23T10:30:36Z",
    "merge_commit_sha": "4c61338ccb6bb801397dfd91989b1737dbfacede",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "TheBlueMatt:152",
      "ref": "152",
      "sha": "20a842244bbdf85c36b16544def261b9da0948da",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 57929990,
        "node_id": "MDEwOlJlcG9zaXRvcnk1NzkyOTk5MA==",
        "name": "bips",
        "full_name": "TheBlueMatt/bips",
        "owner": {
          "login": "TheBlueMatt",
          "id": 649246,
          "node_id": "MDQ6VXNlcjY0OTI0Ng==",
          "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/TheBlueMatt",
          "html_url": "https://github.com/TheBlueMatt",
          "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
          "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
          "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
          "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
          "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/TheBlueMatt/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/TheBlueMatt/bips",
        "archive_url": "https://api.github.com/repos/TheBlueMatt/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/TheBlueMatt/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/TheBlueMatt/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/TheBlueMatt/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/TheBlueMatt/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/TheBlueMatt/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/TheBlueMatt/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/TheBlueMatt/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/TheBlueMatt/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/TheBlueMatt/bips/contributors",
        "deployments_url": "https://api.github.com/repos/TheBlueMatt/bips/deployments",
        "downloads_url": "https://api.github.com/repos/TheBlueMatt/bips/downloads",
        "events_url": "https://api.github.com/repos/TheBlueMatt/bips/events",
        "forks_url": "https://api.github.com/repos/TheBlueMatt/bips/forks",
        "git_commits_url": "https://api.github.com/repos/TheBlueMatt/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/TheBlueMatt/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/TheBlueMatt/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/TheBlueMatt/bips.git",
        "issue_comment_url": "https://api.github.com/repos/TheBlueMatt/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/TheBlueMatt/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/TheBlueMatt/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/TheBlueMatt/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/TheBlueMatt/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/TheBlueMatt/bips/languages",
        "merges_url": "https://api.github.com/repos/TheBlueMatt/bips/merges",
        "milestones_url": "https://api.github.com/repos/TheBlueMatt/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/TheBlueMatt/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/TheBlueMatt/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/TheBlueMatt/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:TheBlueMatt/bips.git",
        "stargazers_url": "https://api.github.com/repos/TheBlueMatt/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/TheBlueMatt/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/TheBlueMatt/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/TheBlueMatt/bips/subscription",
        "tags_url": "https://api.github.com/repos/TheBlueMatt/bips/tags",
        "teams_url": "https://api.github.com/repos/TheBlueMatt/bips/teams",
        "trees_url": "https://api.github.com/repos/TheBlueMatt/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/TheBlueMatt/bips.git",
        "hooks_url": "https://api.github.com/repos/TheBlueMatt/bips/hooks",
        "svn_url": "https://github.com/TheBlueMatt/bips",
        "homepage": "bitcoin.org",
        "language": "Python",
        "forks_count": 8,
        "stargazers_count": 42,
        "watchers_count": 42,
        "size": 5276,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2020-04-03T14:05:39Z",
        "created_at": "2016-05-03T00:30:51Z",
        "updated_at": "2023-01-26T18:31:10Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "ad9fc9cceae39baa1d190efaa0649d4d78b4fadd",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5178,
        "stargazers_count": 8116,
        "watchers_count": 8116,
        "size": 13694,
        "default_branch": "master",
        "open_issues_count": 115,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-08T12:03:37Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-06-12T10:53:19Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 192,
    "deletions": 0,
    "changed_files": 3,
    "commits": 1,
    "review_comments": 8,
    "comments": 5
  },
  "events": [
    {
      "event": "commented",
      "id": 219916616,
      "node_id": "MDEyOklzc3VlQ29tbWVudDIxOTkxNjYxNg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/219916616",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T03:32:12Z",
      "updated_at": "2016-05-18T03:32:12Z",
      "author_association": "MEMBER",
      "body": "Title case mismatch between README and bip-0152\n",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/389#issuecomment-219916616",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/389"
    },
    {
      "event": "labeled",
      "id": 663880391,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDY2Mzg4MDM5MQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/663880391",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T03:32:17Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "renamed",
      "id": 663880517,
      "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50NjYzODgwNTE3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/663880517",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T03:32:36Z",
      "rename": {
        "from": "Add compact-block bip",
        "to": "BIP 152: Compact Block Relay"
      }
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwNjY4MjE6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "mentioned",
      "id": 663941587,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NjYzOTQxNTg3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/663941587",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T05:41:34Z"
    },
    {
      "event": "subscribed",
      "id": 663941588,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDY2Mzk0MTU4OA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/663941588",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T05:41:34Z"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwNjY4MjY6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "mentioned",
      "id": 663980553,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NjYzOTgwNTUz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/663980553",
      "actor": {
        "login": "dcousens",
        "id": 413395,
        "node_id": "MDQ6VXNlcjQxMzM5NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/413395?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dcousens",
        "html_url": "https://github.com/dcousens",
        "followers_url": "https://api.github.com/users/dcousens/followers",
        "following_url": "https://api.github.com/users/dcousens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dcousens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dcousens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dcousens/subscriptions",
        "organizations_url": "https://api.github.com/users/dcousens/orgs",
        "repos_url": "https://api.github.com/users/dcousens/repos",
        "events_url": "https://api.github.com/users/dcousens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dcousens/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T06:41:35Z"
    },
    {
      "event": "subscribed",
      "id": 663980554,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDY2Mzk4MDU1NA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/663980554",
      "actor": {
        "login": "dcousens",
        "id": 413395,
        "node_id": "MDQ6VXNlcjQxMzM5NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/413395?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dcousens",
        "html_url": "https://github.com/dcousens",
        "followers_url": "https://api.github.com/users/dcousens/followers",
        "following_url": "https://api.github.com/users/dcousens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dcousens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dcousens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dcousens/subscriptions",
        "organizations_url": "https://api.github.com/users/dcousens/orgs",
        "repos_url": "https://api.github.com/users/dcousens/repos",
        "events_url": "https://api.github.com/users/dcousens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dcousens/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T06:41:35Z"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwNjY4Mjk6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwNjY4MzI6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "head_ref_force_pushed",
      "id": 664949315,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NjY0OTQ5MzE1",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/664949315",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T20:26:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 664950705,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NjY0OTUwNzA1",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/664950705",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T20:27:49Z"
    },
    {
      "event": "commented",
      "id": 220147986,
      "node_id": "MDEyOklzc3VlQ29tbWVudDIyMDE0Nzk4Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/220147986",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T20:28:08Z",
      "updated_at": "2016-05-18T20:28:08Z",
      "author_association": "MEMBER",
      "body": "I think I addressed all the concerns here.\n",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/389#issuecomment-220147986",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/389"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 664952672,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NjY0OTUyNjcy",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/664952672",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T20:29:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 664954696,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NjY0OTU0Njk2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/664954696",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T20:31:29Z"
    },
    {
      "event": "commented",
      "id": 220180610,
      "node_id": "MDEyOklzc3VlQ29tbWVudDIyMDE4MDYxMA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/220180610",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-18T22:46:48Z",
      "updated_at": "2016-05-18T22:46:48Z",
      "author_association": "MEMBER",
      "body": "Missing separator line in README\n",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/389#issuecomment-220180610",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/389"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwNjY4MzQ6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "commented",
      "id": 220206444,
      "node_id": "MDEyOklzc3VlQ29tbWVudDIyMDIwNjQ0NA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/220206444",
      "actor": {
        "login": "dcousens",
        "id": 413395,
        "node_id": "MDQ6VXNlcjQxMzM5NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/413395?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dcousens",
        "html_url": "https://github.com/dcousens",
        "followers_url": "https://api.github.com/users/dcousens/followers",
        "following_url": "https://api.github.com/users/dcousens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dcousens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dcousens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dcousens/subscriptions",
        "organizations_url": "https://api.github.com/users/dcousens/orgs",
        "repos_url": "https://api.github.com/users/dcousens/repos",
        "events_url": "https://api.github.com/users/dcousens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dcousens/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-19T01:43:02Z",
      "updated_at": "2016-05-19T01:43:02Z",
      "author_association": "CONTRIBUTOR",
      "body": "LGTM :)\n",
      "user": {
        "login": "dcousens",
        "id": 413395,
        "node_id": "MDQ6VXNlcjQxMzM5NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/413395?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dcousens",
        "html_url": "https://github.com/dcousens",
        "followers_url": "https://api.github.com/users/dcousens/followers",
        "following_url": "https://api.github.com/users/dcousens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dcousens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dcousens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dcousens/subscriptions",
        "organizations_url": "https://api.github.com/users/dcousens/orgs",
        "repos_url": "https://api.github.com/users/dcousens/repos",
        "events_url": "https://api.github.com/users/dcousens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dcousens/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/389#issuecomment-220206444",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/389"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6MjBhODQyMjQ0YmJkZjg1YzM2YjE2NTQ0ZGVmMjYxYjlkYTA5NDhkYQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/20a842244bbdf85c36b16544def261b9da0948da",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/20a842244bbdf85c36b16544def261b9da0948da",
      "tree": {
        "sha": "6ea37b1b8c7c94cd884f9bbf72948b7ddf0a5b15",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/6ea37b1b8c7c94cd884f9bbf72948b7ddf0a5b15"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/f65541bf262cde0437add6e754f115ad0ec01a9c",
          "sha": "f65541bf262cde0437add6e754f115ad0ec01a9c",
          "html_url": "https://github.com/bitcoin/bips/commit/f65541bf262cde0437add6e754f115ad0ec01a9c"
        }
      ],
      "message": "Add compact-block bip",
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-05-23T01:21:32Z"
      },
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-04-28T04:19:57Z"
      },
      "sha": "20a842244bbdf85c36b16544def261b9da0948da"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 668387009,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NjY4Mzg3MDA5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/668387009",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-23T01:21:38Z"
    },
    {
      "event": "commented",
      "id": 220869485,
      "node_id": "MDEyOklzc3VlQ29tbWVudDIyMDg2OTQ4NQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/220869485",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-23T01:21:54Z",
      "updated_at": "2016-05-23T01:21:54Z",
      "author_association": "MEMBER",
      "body": "Fixed nits\n",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/389#issuecomment-220869485",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/389"
    },
    {
      "event": "merged",
      "id": 668765126,
      "node_id": "MDExOk1lcmdlZEV2ZW50NjY4NzY1MTI2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/668765126",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4c61338ccb6bb801397dfd91989b1737dbfacede",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/4c61338ccb6bb801397dfd91989b1737dbfacede",
      "created_at": "2016-05-23T10:30:36Z"
    },
    {
      "event": "closed",
      "id": 668765127,
      "node_id": "MDExOkNsb3NlZEV2ZW50NjY4NzY1MTI3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/668765127",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-05-23T10:30:36Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63641853",
      "pull_request_review_id": null,
      "id": 63641853,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjQxODUz",
      "diff_hunk": "@@ -0,0 +1,212 @@\n+<pre>\n+  BIP: 152\n+  Title: Compact block relay\n+  Author: Matt Corallo <bip@bluematt.me>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2016-04-27\n+</pre>\n+\n+==Abstract==\n+\n+Compact blocks on the wire as a way to save bandwidth for nodes on the P2P network.\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n+\n+==Motivation==\n+\n+Historically, the Bitcoin P2P protocol has not been very bandwidth efficient for block relay. Every transaction in a block is included when relayed, even though a large number of the transactions in a given block are already available to nodes before the block is relayed. This causes moderate inbound bandwidth spikes for nodes when receiving blocks, but can cause very significant outbound bandwidth spikes for some nodes which receive a block before their peers. When such spikes occur, buffer bloat can make consumer-grade internet connections temporarily unusable, and can delay the relay of blocks to remote peers who may choose to wait instead of redundantly requesting the same block from other, less congested, peers.\n+\n+Thus, decreasing the bandwidth used during block relay is very useful for many individuals running nodes.\n+\n+While the goal of this work is explicitly not to reduce block transfer latency, it does, as a side effect reduce block transfer latencies in some rather significant ways. Additionally, this work forms a foundation for future work explicitly targeting low-latency block transfer.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+<img src=bip-0152/protocol-flow.png></img>\n+\n+The protocol is intended to be used in two ways, depending on the peers and bandwidth available, as discussed [[#Implementation_Details|later]]. The \"high-bandwidth\" mode, which nodes may only enable for a few of their peers, is enabled by setting the first boolean to 1 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the short transaction IDs already (via a cmpctblock message), possibly even before fully validating the block (as indicated by the grey box in the image above). In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual immediately. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the best-case latency to the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage.\n+\n+The \"low-bandwidth\" mode is enabled by setting the first boolean to 0 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the usual inv/headers announcements (as per BIP130, and after fully validating the block). The receiving peer may then request the block using a MSG_CMPCT_BLOCK getdata request, which will receive a response of the header and short transaction IDs. In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual, taking the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the latency to at least 2.5*RTT in this case, again with significantly less bandwidth usage than today. Because TCP often exhibits worse transfer latency for larger data sizes (as a multiple of RTT), total latency is expected to be reduced even when the full 2.5*RTT transfer mechanism is used.\n+\n+===New data structures===\n+Several new data structures are added to the P2P network to relay compact blocks: PrefilledTransaction, HeaderAndShortIDs, BlockTransactionsRequest, and BlockTransactions. Additionally, we introduce a new variable-length integer encoding for use in these data structures.\n+\n+For the purposes of this section, CompactSize refers to the variable-length integer encoding used across the existing P2P protocol to encode array lengths, among other things, in 1, 3, 5 or 9 bytes.\n+\n+====New VarInt====\n+TODO: I just copied this out of the src...Something that is wiki-formatted and more descriptive should be used here instead.\n+\n+ Variable-length integers: bytes are a MSB base-128 encoding of the number.\n+ The high bit in each byte signifies whether another digit follows. To make\n+ sure the encoding is one-to-one, one is subtracted from all but the last digit.\n+ Thus, the byte sequence a[] with length len, where all but the last byte\n+ has bit 128 set, encodes the number:\n+\n+ (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))\n+\n+ Properties:\n+ * Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)\n+ * Every integer has exactly one encoding\n+ * Encoding does not depend on size of original integer type\n+ * No redundancy: every (infinite) byte sequence corresponds to a list\n+   of encoded integers.\n+\n+ 0:         [0x00]  256:        [0x81 0x00]\n+ 1:         [0x01]  16383:      [0xFE 0x7F]\n+ 127:       [0x7F]  16384:      [0xFF 0x00]\n+ 128:  [0x80 0x00]  16511: [0x80 0xFF 0x7F]\n+ 255:  [0x80 0x7F]  65535: [0x82 0xFD 0x7F]\n+ 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]\n+\n+Several uses of New VarInts below are \"differentially encoded\". For these, instead of using raw indexes, the number encoded is the difference between the current index and the previous index, minus one. For example, a first index of 0 implies a real index of 0, a second index of 0 thereafter refers to a real index of 1, etc.\n+\n+====PrefilledTransaction====\n+A PrefilledTransaction structure is used in HeaderAndShortIDs to provide a list of a few transactions explicitly.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|index||New VarInt||1-3 bytes||[[#New_VarInt|New VarInt]], differentially encoded since the last PrefilledTransaction in a list||The index into the block at which this transaction is\n+|-\n+|tx||Transaction||variable||As encoded in \"tx\" messages||The transaction which is in the block at index index.\n+|}\n+\n+====HeaderAndShortIDs====\n+A HeaderAndShortIDs structure is used to relay a block header, the short transactions IDs used for matching already-available transactions, and a select few transactions which we expect a peer may be missing.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|header||Block header||80 bytes||First 80 bytes of the block as defined by the encoding used by \"block\" messages||The header of the block being provided\n+|-\n+|nonce||uint64_t||8 bytes||Little Endian||A nonce for use in short transaction ID calculations\n+|-\n+|shortids_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of short transaction IDs in shortids (ie block tx count - prefilledtxn_length)\n+|-\n+|shortids||List of 6-byte integers||6*shortids_length bytes||Little Endian||The short transaction IDs calculated from the transactions which were not provided explicitly in prefilledtxn\n+|-\n+|prefilledtxn_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of prefilled transactions in prefilledtxn (ie block tx count - shortids_length)\n+|-\n+|prefilledtxn||List of PrefilledTransactions||variable size*prefilledtxn_length||As defined by PrefilledTransaction definition, above||Used to provide the coinbase transaction and a select few which we expect a peer may be missing\n+|}\n+\n+====BlockTransactionsRequest====\n+A BlockTransactionsRequest structure is used to list transaction indexes in a block being requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being requested are in\n+|-\n+|indexes_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of transactions being requested\n+|-\n+|indexes||List of New VarInts||1-3 bytes*indexes_length||As defined in [[#New_VarInt|New VarInt]], differentially encoded||The indexes of the transactions being requested in the block\n+|}\n+\n+====BlockTransactions====\n+A BlockTransactions structure is used to provide some of the transactions in a block, as requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being provided are in\n+|-\n+|transactions_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of transactions provided\n+|-\n+|transactions||List of Transactions||variable||As encoded in \"tx\" messages||The transactions provided\n+|}\n+\n+====Short transaction IDs====\n+Short transaction IDs are used to represent a transaction without sending a full 256-bit hash. They are calculated by:\n+# single-SHA256 hashing the block header with the nonce appended (in little-endian)\n+# Running SipHash2-4 with the input being the transaction ID and the keys (k0/k1) set to the first two little-endian 64-bit integers from the above hash, respectively.\n+# Dropping the 2 most significant bytes from the SipHash output to make it 6 bytes.\n+\n+===New messages===\n+A new inv type (MSG_CMPCT_BLOCK == 4) and several new protocol messages are added: sendcmpct, cmpctblock, getblocktxn, and blocktxn.\n+\n+====sendcmpct====\n+# The sendcmpct message is defined as a message containing a 1-byte integer followed by a 8-byte integer where pchCommand == \"sendcmpct\".\n+# The first integer SHALL be interpreted as a boolean (and MUST have a value of either 1 or 0)\n+# The second integer SHALL be interpreted as a little-endian version number. Nodes sending a sendcmpct message MUST currently set this value to 1.\n+# Upon receipt of a \"sendcmpct\" message with the first and second integers set to 1, the node SHOULD announce new blocks by sending a cmpctblock message.\n+# Upon receipt of a \"sendcmpct\" message with the first integer set to 0, the node SHOULD NOT announce new blocks by sending a cmpctblock message, but SHOULD announce new blocks by sending invs or headers, as defined by BIP130.\n+# Upon receipt of a \"sendcmpct\" message with the second integer set to something other than 1, nodes MUST treat the peer as if they had not received the message (as it indicates the peer will provide an unexpected encoding in cmpctblock, and/or other, messages). This allows future versions to send duplicate sendcmpct messages with different versions as a part of a version handshake for future versions.\n+# Nodes SHOULD check for a protocol version of >= 70014 before sending sendcmpct messages.\n+# Nodes MUST NOT send a request for a MSG_CMPCT_BLOCK object to a peer before having received a sendcmpct message from that peer.\n+\n+====MSG_CMPCT_BLOCK====\n+# getdata messages may now contain requests for MSG_CMPCT_BLOCK objects.\n+# Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK object with the hash of a block which was recently announced and after having sent the requesting peer a sendcmpct message, nodes MUST respond with a cmpctblock message containing appropriate data representing the block being requested.\n+# MSG_CMPCT_BLOCK inv objects MUST NOT appear anywhere except for in getdata messages.\n+\n+====cmpctblock====\n+# The cmpctblock message is defined as as a message containing a serialized HeaderAndShortIDs message and pchCommand == \"cmpctblock\".\n+# Upon receipt of a cmpctblock message after sending a sendcmpct message, nodes SHOULD calculate the short transaction ID for each unconfirmed transaction they have available (ie in their mempool) and compare each to each short transaction ID in the cmpctblock message.\n+# After finding already-available transactions, nodes which do not have all transactions available to reconstruct the full block SHOULD request the missing transactions using a getblocktxn message.\n+# A node MUST NOT send a cmpctblock message unless they are able to respond to a getblocktxn message which requests every transaction in the block.\n+# A node MUST NOT send a cmpctblock message without having validated that the header properly commits to each transaction in the block, and properly builds on top of the existing chain with a valid proof-of-work. A node MAY send a cmpctblock before validating that each transaction in the block validly spends existing UTXO set entries.\n+\n+====getblocktxn====\n+# The getblocktxn message is defined as as a message containing a serialized BlockTransactionsRequest message and pchCommand == \"getblocktxn\".\n+# Upon receipt of a properly-formatted getblocktxnmessage, nodes which recently provided the sender of such a message a cmpctblock for the block hash identified in this message MUST respond with an appropriate blocktxn message. Such a blocktxn message MUST contain exactly and only each transaction which is present in the appropriate block at the index specified in the getblocktxn indexes list, in the order requested.\n+\n+====blocktxn====\n+# The blocktxn message is defined as as a message containing a serialized BlockTransactions message and pchCommand == \"blocktxn\".\n+# Upon receipt of a properly-formatted requested blocktxn message, nodes SHOULD attempt to reconstruct the full block by:\n+## Taking the prefilledtxn transactions from the original cmpctblock and placing them in the marked positions.\n+## For each short transaction ID from the original cmpctblock, in order, find the corresponding transaction either from the blocktxn message or from other sources and place it in the first available position in the block.\n+# Once the block has been reconstructed, it shall be processed as normal, keeping in mind that short transaction IDs are expected to occasionally collide, and that nodes MUST NOT be penalized for such collisions, wherever they appear.\n+\n+===Implementation Notes===\n+# For nodes which have sufficient inbound bandwidth, sending a sendcmpct message with the first integer set to 1 to up to 3 peers is RECOMMENDED. If possible, it is RECOMMENDED that those peers be selected based on their past performance in providing blocks quickly (eg the three peers which provided the highest number of the recent N blocks the quickest), allowing nodes to receive blocks which come from those peers in only 0.5*RTT.\n+\n+# Nodes MUST NOT send such sendcmpct messages to more than three peers, as it encourages wasting outbound bandwidth across the network.\n+\n+# All nodes SHOULD send a sendcmpct message to all appropriate peers. This will reduce their outbound bandwidth usage by allowing their peers to request compact blocks instead of full blocks.\n+\n+# Nodes with limited inbound bandwidth SHOULD request blocks using MSG_CMPCT_BLOCK/getblocktxn requests, when possible. While this increases worst-case message round-trips, it is expected to reduce overall transfer latency as TCP is more likely to exhibit poor throughput on low-bandwidth nodes.\n+\n+# Nodes sending cmpctblock messages SHOULD limit prefilledtxn to 10KB of transactions. When in doubt, nodes SHOULD only include the coinbase transaction in prefilledtxn.\n+\n+# Nodes MAY pick one nonce per block they wish to send, and only build a cmpctblock message once for all peers which they wish to send a given block to. Nodes SHOULD NOT use the same nonce across multiple different blocks.\n+\n+# Nodes MAY impose additional requirements on when they announce new blocks by sending cmpctblock messages. For example, nodes with limited outbound bandwidth MAY choose to announce new blocks using inv/header messages (as per BIP130) to conserve outbound bandwidth.\n+\n+# Note that the MSG_CMPCT_BLOCK section does not require that nodes respond to MSG_CMPCT_BLOCK getdata requests for blocks which they did not recently announce. This allows nodes to calculate cmpctblock messages at announce-time instead of at request-time. Thus, nodes MUST NOT request blocks using MSG_CMPCT_BLOCK getdatas unless it is in response to an inv/headers block announcement (as per BIP130), and MUST NOT request blocks using MSG_CMPCT_BLOCK getdatas in response to headers messages which were, themselves, responses to getheaders requests.\n+\n+# While the current version sends transactions with the same encodings as is used in tx messages and elsewhere in the protocol, the version field in sendcmpct is intended to allow this to change in the future. For this reason, it is recommended that the code used to decode PrefilledTransaction and BlockTransactions messages be prepared to take a different transaction encoding, if and when the version field in sendcmpct changes in a future BIP.\n+\n+==Justification==\n+\n+====Protocol design====\n+There have been many proposals to save wire bytes when relaying blocks. Many of them have a two-fold goal of reducing block relay time and thus rely on the use of significant processing power in order to avoid introducing additional worst-case RTTs. Because this work is not focused primarily on reducing block relay time, its design is much simpler (ie does not rely on set reconciliation protocols). Still, in testing at the time of writing, nodes are able to relay blocks without the extra getblocktxn/blocktxn RTT around 90% of the time. With a smart compact-block-announcement policy, it is thus expected that this work might allow blocks to be relayed between nodes in 0.5*RTT instead of 1.5*RTT at least 75% of the time.\n+\n+====Use of New VarInts====\n+Bitcoin has long had a variable-length integer implementation (referred to as CompactSize in this document), making a second a strange protocol quirk. However, in this protocol most of our variable-length integers are between 0 and 2000. For both encodings, small numbers (<100) are encoded as 1-byte. For numbers over 250, the CompactSize encoding begins to use 3 bytes instead of 1, whereas the New VarInt encoding uses 2. Because the primary motivation for this work is to save bytes during block relay, the extra byte of saving per transaction-difference is considered worth the extra design complexity.\n+",
      "path": "bip-0152.mediawiki",
      "position": null,
      "original_position": 189,
      "commit_id": "20a842244bbdf85c36b16544def261b9da0948da",
      "original_commit_id": "3250edf3029cbbf21cb2462b77a5ee48812bd0ff",
      "in_reply_to_id": null,
      "user": {
        "login": "dcousens",
        "id": 413395,
        "node_id": "MDQ6VXNlcjQxMzM5NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/413395?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dcousens",
        "html_url": "https://github.com/dcousens",
        "followers_url": "https://api.github.com/users/dcousens/followers",
        "following_url": "https://api.github.com/users/dcousens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dcousens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dcousens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dcousens/subscriptions",
        "organizations_url": "https://api.github.com/users/dcousens/orgs",
        "repos_url": "https://api.github.com/users/dcousens/repos",
        "events_url": "https://api.github.com/users/dcousens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dcousens/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Are there any statistics that support this savings to be non-trivial?\nI can't foresee it saving more than say 5-10 kB per block,  but I may be underestimating. \n\nIMHO,  that added complexity and design quirks [of this new VarInt] more than offsets the potential savings if it is less than ~10%.\n",
      "created_at": "2016-05-18T03:55:08Z",
      "updated_at": "2016-05-23T01:21:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/389#discussion_r63641853",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63641853"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63643139",
      "pull_request_review_id": null,
      "id": 63643139,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjQzMTM5",
      "diff_hunk": "@@ -0,0 +1,212 @@\n+<pre>\n+  BIP: 152\n+  Title: Compact block relay\n+  Author: Matt Corallo <bip@bluematt.me>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2016-04-27\n+</pre>\n+\n+==Abstract==\n+\n+Compact blocks on the wire as a way to save bandwidth for nodes on the P2P network.\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n+\n+==Motivation==\n+\n+Historically, the Bitcoin P2P protocol has not been very bandwidth efficient for block relay. Every transaction in a block is included when relayed, even though a large number of the transactions in a given block are already available to nodes before the block is relayed. This causes moderate inbound bandwidth spikes for nodes when receiving blocks, but can cause very significant outbound bandwidth spikes for some nodes which receive a block before their peers. When such spikes occur, buffer bloat can make consumer-grade internet connections temporarily unusable, and can delay the relay of blocks to remote peers who may choose to wait instead of redundantly requesting the same block from other, less congested, peers.\n+\n+Thus, decreasing the bandwidth used during block relay is very useful for many individuals running nodes.\n+\n+While the goal of this work is explicitly not to reduce block transfer latency, it does, as a side effect reduce block transfer latencies in some rather significant ways. Additionally, this work forms a foundation for future work explicitly targeting low-latency block transfer.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+<img src=bip-0152/protocol-flow.png></img>\n+\n+The protocol is intended to be used in two ways, depending on the peers and bandwidth available, as discussed [[#Implementation_Details|later]]. The \"high-bandwidth\" mode, which nodes may only enable for a few of their peers, is enabled by setting the first boolean to 1 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the short transaction IDs already (via a cmpctblock message), possibly even before fully validating the block (as indicated by the grey box in the image above). In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual immediately. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the best-case latency to the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage.\n+\n+The \"low-bandwidth\" mode is enabled by setting the first boolean to 0 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the usual inv/headers announcements (as per BIP130, and after fully validating the block). The receiving peer may then request the block using a MSG_CMPCT_BLOCK getdata request, which will receive a response of the header and short transaction IDs. In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual, taking the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the latency to at least 2.5*RTT in this case, again with significantly less bandwidth usage than today. Because TCP often exhibits worse transfer latency for larger data sizes (as a multiple of RTT), total latency is expected to be reduced even when the full 2.5*RTT transfer mechanism is used.\n+\n+===New data structures===\n+Several new data structures are added to the P2P network to relay compact blocks: PrefilledTransaction, HeaderAndShortIDs, BlockTransactionsRequest, and BlockTransactions. Additionally, we introduce a new variable-length integer encoding for use in these data structures.\n+\n+For the purposes of this section, CompactSize refers to the variable-length integer encoding used across the existing P2P protocol to encode array lengths, among other things, in 1, 3, 5 or 9 bytes.\n+\n+====New VarInt====\n+TODO: I just copied this out of the src...Something that is wiki-formatted and more descriptive should be used here instead.\n+\n+ Variable-length integers: bytes are a MSB base-128 encoding of the number.\n+ The high bit in each byte signifies whether another digit follows. To make\n+ sure the encoding is one-to-one, one is subtracted from all but the last digit.\n+ Thus, the byte sequence a[] with length len, where all but the last byte\n+ has bit 128 set, encodes the number:\n+\n+ (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))\n+\n+ Properties:\n+ * Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)\n+ * Every integer has exactly one encoding\n+ * Encoding does not depend on size of original integer type\n+ * No redundancy: every (infinite) byte sequence corresponds to a list\n+   of encoded integers.\n+\n+ 0:         [0x00]  256:        [0x81 0x00]\n+ 1:         [0x01]  16383:      [0xFE 0x7F]\n+ 127:       [0x7F]  16384:      [0xFF 0x00]\n+ 128:  [0x80 0x00]  16511: [0x80 0xFF 0x7F]\n+ 255:  [0x80 0x7F]  65535: [0x82 0xFD 0x7F]\n+ 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]\n+\n+Several uses of New VarInts below are \"differentially encoded\". For these, instead of using raw indexes, the number encoded is the difference between the current index and the previous index, minus one. For example, a first index of 0 implies a real index of 0, a second index of 0 thereafter refers to a real index of 1, etc.\n+\n+====PrefilledTransaction====\n+A PrefilledTransaction structure is used in HeaderAndShortIDs to provide a list of a few transactions explicitly.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|index||New VarInt||1-3 bytes||[[#New_VarInt|New VarInt]], differentially encoded since the last PrefilledTransaction in a list||The index into the block at which this transaction is\n+|-\n+|tx||Transaction||variable||As encoded in \"tx\" messages||The transaction which is in the block at index index.\n+|}\n+\n+====HeaderAndShortIDs====\n+A HeaderAndShortIDs structure is used to relay a block header, the short transactions IDs used for matching already-available transactions, and a select few transactions which we expect a peer may be missing.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|header||Block header||80 bytes||First 80 bytes of the block as defined by the encoding used by \"block\" messages||The header of the block being provided\n+|-\n+|nonce||uint64_t||8 bytes||Little Endian||A nonce for use in short transaction ID calculations\n+|-\n+|shortids_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of short transaction IDs in shortids (ie block tx count - prefilledtxn_length)\n+|-\n+|shortids||List of 6-byte integers||6*shortids_length bytes||Little Endian||The short transaction IDs calculated from the transactions which were not provided explicitly in prefilledtxn\n+|-\n+|prefilledtxn_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of prefilled transactions in prefilledtxn (ie block tx count - shortids_length)\n+|-\n+|prefilledtxn||List of PrefilledTransactions||variable size*prefilledtxn_length||As defined by PrefilledTransaction definition, above||Used to provide the coinbase transaction and a select few which we expect a peer may be missing\n+|}\n+\n+====BlockTransactionsRequest====\n+A BlockTransactionsRequest structure is used to list transaction indexes in a block being requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being requested are in\n+|-\n+|indexes_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of transactions being requested\n+|-\n+|indexes||List of New VarInts||1-3 bytes*indexes_length||As defined in [[#New_VarInt|New VarInt]], differentially encoded||The indexes of the transactions being requested in the block\n+|}\n+\n+====BlockTransactions====\n+A BlockTransactions structure is used to provide some of the transactions in a block, as requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being provided are in\n+|-\n+|transactions_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of transactions provided\n+|-\n+|transactions||List of Transactions||variable||As encoded in \"tx\" messages||The transactions provided\n+|}\n+\n+====Short transaction IDs====\n+Short transaction IDs are used to represent a transaction without sending a full 256-bit hash. They are calculated by:\n+# single-SHA256 hashing the block header with the nonce appended (in little-endian)\n+# Running SipHash2-4 with the input being the transaction ID and the keys (k0/k1) set to the first two little-endian 64-bit integers from the above hash, respectively.\n+# Dropping the 2 most significant bytes from the SipHash output to make it 6 bytes.\n+\n+===New messages===\n+A new inv type (MSG_CMPCT_BLOCK == 4) and several new protocol messages are added: sendcmpct, cmpctblock, getblocktxn, and blocktxn.\n+\n+====sendcmpct====\n+# The sendcmpct message is defined as a message containing a 1-byte integer followed by a 8-byte integer where pchCommand == \"sendcmpct\".\n+# The first integer SHALL be interpreted as a boolean (and MUST have a value of either 1 or 0)\n+# The second integer SHALL be interpreted as a little-endian version number. Nodes sending a sendcmpct message MUST currently set this value to 1.\n+# Upon receipt of a \"sendcmpct\" message with the first and second integers set to 1, the node SHOULD announce new blocks by sending a cmpctblock message.\n+# Upon receipt of a \"sendcmpct\" message with the first integer set to 0, the node SHOULD NOT announce new blocks by sending a cmpctblock message, but SHOULD announce new blocks by sending invs or headers, as defined by BIP130.\n+# Upon receipt of a \"sendcmpct\" message with the second integer set to something other than 1, nodes MUST treat the peer as if they had not received the message (as it indicates the peer will provide an unexpected encoding in cmpctblock, and/or other, messages). This allows future versions to send duplicate sendcmpct messages with different versions as a part of a version handshake for future versions.\n+# Nodes SHOULD check for a protocol version of >= 70014 before sending sendcmpct messages.\n+# Nodes MUST NOT send a request for a MSG_CMPCT_BLOCK object to a peer before having received a sendcmpct message from that peer.\n+\n+====MSG_CMPCT_BLOCK====\n+# getdata messages may now contain requests for MSG_CMPCT_BLOCK objects.\n+# Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK object with the hash of a block which was recently announced and after having sent the requesting peer a sendcmpct message, nodes MUST respond with a cmpctblock message containing appropriate data representing the block being requested.\n+# MSG_CMPCT_BLOCK inv objects MUST NOT appear anywhere except for in getdata messages.\n+\n+====cmpctblock====\n+# The cmpctblock message is defined as as a message containing a serialized HeaderAndShortIDs message and pchCommand == \"cmpctblock\".\n+# Upon receipt of a cmpctblock message after sending a sendcmpct message, nodes SHOULD calculate the short transaction ID for each unconfirmed transaction they have available (ie in their mempool) and compare each to each short transaction ID in the cmpctblock message.\n+# After finding already-available transactions, nodes which do not have all transactions available to reconstruct the full block SHOULD request the missing transactions using a getblocktxn message.\n+# A node MUST NOT send a cmpctblock message unless they are able to respond to a getblocktxn message which requests every transaction in the block.\n+# A node MUST NOT send a cmpctblock message without having validated that the header properly commits to each transaction in the block, and properly builds on top of the existing chain with a valid proof-of-work. A node MAY send a cmpctblock before validating that each transaction in the block validly spends existing UTXO set entries.\n+\n+====getblocktxn====\n+# The getblocktxn message is defined as as a message containing a serialized BlockTransactionsRequest message and pchCommand == \"getblocktxn\".\n+# Upon receipt of a properly-formatted getblocktxnmessage, nodes which recently provided the sender of such a message a cmpctblock for the block hash identified in this message MUST respond with an appropriate blocktxn message. Such a blocktxn message MUST contain exactly and only each transaction which is present in the appropriate block at the index specified in the getblocktxn indexes list, in the order requested.\n+\n+====blocktxn====\n+# The blocktxn message is defined as as a message containing a serialized BlockTransactions message and pchCommand == \"blocktxn\".\n+# Upon receipt of a properly-formatted requested blocktxn message, nodes SHOULD attempt to reconstruct the full block by:\n+## Taking the prefilledtxn transactions from the original cmpctblock and placing them in the marked positions.\n+## For each short transaction ID from the original cmpctblock, in order, find the corresponding transaction either from the blocktxn message or from other sources and place it in the first available position in the block.\n+# Once the block has been reconstructed, it shall be processed as normal, keeping in mind that short transaction IDs are expected to occasionally collide, and that nodes MUST NOT be penalized for such collisions, wherever they appear.\n+\n+===Implementation Notes===\n+# For nodes which have sufficient inbound bandwidth, sending a sendcmpct message with the first integer set to 1 to up to 3 peers is RECOMMENDED. If possible, it is RECOMMENDED that those peers be selected based on their past performance in providing blocks quickly (eg the three peers which provided the highest number of the recent N blocks the quickest), allowing nodes to receive blocks which come from those peers in only 0.5*RTT.\n+\n+# Nodes MUST NOT send such sendcmpct messages to more than three peers, as it encourages wasting outbound bandwidth across the network.\n+\n+# All nodes SHOULD send a sendcmpct message to all appropriate peers. This will reduce their outbound bandwidth usage by allowing their peers to request compact blocks instead of full blocks.\n+\n+# Nodes with limited inbound bandwidth SHOULD request blocks using MSG_CMPCT_BLOCK/getblocktxn requests, when possible. While this increases worst-case message round-trips, it is expected to reduce overall transfer latency as TCP is more likely to exhibit poor throughput on low-bandwidth nodes.\n+\n+# Nodes sending cmpctblock messages SHOULD limit prefilledtxn to 10KB of transactions. When in doubt, nodes SHOULD only include the coinbase transaction in prefilledtxn.\n+\n+# Nodes MAY pick one nonce per block they wish to send, and only build a cmpctblock message once for all peers which they wish to send a given block to. Nodes SHOULD NOT use the same nonce across multiple different blocks.\n+\n+# Nodes MAY impose additional requirements on when they announce new blocks by sending cmpctblock messages. For example, nodes with limited outbound bandwidth MAY choose to announce new blocks using inv/header messages (as per BIP130) to conserve outbound bandwidth.\n+\n+# Note that the MSG_CMPCT_BLOCK section does not require that nodes respond to MSG_CMPCT_BLOCK getdata requests for blocks which they did not recently announce. This allows nodes to calculate cmpctblock messages at announce-time instead of at request-time. Thus, nodes MUST NOT request blocks using MSG_CMPCT_BLOCK getdatas unless it is in response to an inv/headers block announcement (as per BIP130), and MUST NOT request blocks using MSG_CMPCT_BLOCK getdatas in response to headers messages which were, themselves, responses to getheaders requests.\n+\n+# While the current version sends transactions with the same encodings as is used in tx messages and elsewhere in the protocol, the version field in sendcmpct is intended to allow this to change in the future. For this reason, it is recommended that the code used to decode PrefilledTransaction and BlockTransactions messages be prepared to take a different transaction encoding, if and when the version field in sendcmpct changes in a future BIP.\n+\n+==Justification==\n+\n+====Protocol design====\n+There have been many proposals to save wire bytes when relaying blocks. Many of them have a two-fold goal of reducing block relay time and thus rely on the use of significant processing power in order to avoid introducing additional worst-case RTTs. Because this work is not focused primarily on reducing block relay time, its design is much simpler (ie does not rely on set reconciliation protocols). Still, in testing at the time of writing, nodes are able to relay blocks without the extra getblocktxn/blocktxn RTT around 90% of the time. With a smart compact-block-announcement policy, it is thus expected that this work might allow blocks to be relayed between nodes in 0.5*RTT instead of 1.5*RTT at least 75% of the time.\n+\n+====Use of New VarInts====\n+Bitcoin has long had a variable-length integer implementation (referred to as CompactSize in this document), making a second a strange protocol quirk. However, in this protocol most of our variable-length integers are between 0 and 2000. For both encodings, small numbers (<100) are encoded as 1-byte. For numbers over 250, the CompactSize encoding begins to use 3 bytes instead of 1, whereas the New VarInt encoding uses 2. Because the primary motivation for this work is to save bytes during block relay, the extra byte of saving per transaction-difference is considered worth the extra design complexity.\n+",
      "path": "bip-0152.mediawiki",
      "position": null,
      "original_position": 189,
      "commit_id": "20a842244bbdf85c36b16544def261b9da0948da",
      "original_commit_id": "3250edf3029cbbf21cb2462b77a5ee48812bd0ff",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Please do discussion of the actual proposal on the bitcoin-dev ML.\n",
      "created_at": "2016-05-18T04:20:41Z",
      "updated_at": "2016-05-23T01:21:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/389#discussion_r63643139",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63643139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63647771",
      "pull_request_review_id": null,
      "id": 63647771,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjQ3Nzcx",
      "diff_hunk": "@@ -0,0 +1,212 @@\n+<pre>\n+  BIP: 152\n+  Title: Compact block relay\n+  Author: Matt Corallo <bip@bluematt.me>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2016-04-27\n+</pre>\n+\n+==Abstract==\n+\n+Compact blocks on the wire as a way to save bandwidth for nodes on the P2P network.\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n+\n+==Motivation==\n+\n+Historically, the Bitcoin P2P protocol has not been very bandwidth efficient for block relay. Every transaction in a block is included when relayed, even though a large number of the transactions in a given block are already available to nodes before the block is relayed. This causes moderate inbound bandwidth spikes for nodes when receiving blocks, but can cause very significant outbound bandwidth spikes for some nodes which receive a block before their peers. When such spikes occur, buffer bloat can make consumer-grade internet connections temporarily unusable, and can delay the relay of blocks to remote peers who may choose to wait instead of redundantly requesting the same block from other, less congested, peers.\n+\n+Thus, decreasing the bandwidth used during block relay is very useful for many individuals running nodes.\n+\n+While the goal of this work is explicitly not to reduce block transfer latency, it does, as a side effect reduce block transfer latencies in some rather significant ways. Additionally, this work forms a foundation for future work explicitly targeting low-latency block transfer.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+<img src=bip-0152/protocol-flow.png></img>\n+\n+The protocol is intended to be used in two ways, depending on the peers and bandwidth available, as discussed [[#Implementation_Details|later]]. The \"high-bandwidth\" mode, which nodes may only enable for a few of their peers, is enabled by setting the first boolean to 1 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the short transaction IDs already (via a cmpctblock message), possibly even before fully validating the block (as indicated by the grey box in the image above). In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual immediately. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the best-case latency to the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage.\n+\n+The \"low-bandwidth\" mode is enabled by setting the first boolean to 0 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the usual inv/headers announcements (as per BIP130, and after fully validating the block). The receiving peer may then request the block using a MSG_CMPCT_BLOCK getdata request, which will receive a response of the header and short transaction IDs. In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual, taking the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the latency to at least 2.5*RTT in this case, again with significantly less bandwidth usage than today. Because TCP often exhibits worse transfer latency for larger data sizes (as a multiple of RTT), total latency is expected to be reduced even when the full 2.5*RTT transfer mechanism is used.\n+\n+===New data structures===\n+Several new data structures are added to the P2P network to relay compact blocks: PrefilledTransaction, HeaderAndShortIDs, BlockTransactionsRequest, and BlockTransactions. Additionally, we introduce a new variable-length integer encoding for use in these data structures.\n+\n+For the purposes of this section, CompactSize refers to the variable-length integer encoding used across the existing P2P protocol to encode array lengths, among other things, in 1, 3, 5 or 9 bytes.\n+\n+====New VarInt====\n+TODO: I just copied this out of the src...Something that is wiki-formatted and more descriptive should be used here instead.\n+\n+ Variable-length integers: bytes are a MSB base-128 encoding of the number.\n+ The high bit in each byte signifies whether another digit follows. To make\n+ sure the encoding is one-to-one, one is subtracted from all but the last digit.\n+ Thus, the byte sequence a[] with length len, where all but the last byte\n+ has bit 128 set, encodes the number:\n+\n+ (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))\n+\n+ Properties:\n+ * Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)\n+ * Every integer has exactly one encoding\n+ * Encoding does not depend on size of original integer type\n+ * No redundancy: every (infinite) byte sequence corresponds to a list\n+   of encoded integers.\n+\n+ 0:         [0x00]  256:        [0x81 0x00]\n+ 1:         [0x01]  16383:      [0xFE 0x7F]\n+ 127:       [0x7F]  16384:      [0xFF 0x00]\n+ 128:  [0x80 0x00]  16511: [0x80 0xFF 0x7F]\n+ 255:  [0x80 0x7F]  65535: [0x82 0xFD 0x7F]\n+ 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]\n+\n+Several uses of New VarInts below are \"differentially encoded\". For these, instead of using raw indexes, the number encoded is the difference between the current index and the previous index, minus one. For example, a first index of 0 implies a real index of 0, a second index of 0 thereafter refers to a real index of 1, etc.\n+\n+====PrefilledTransaction====\n+A PrefilledTransaction structure is used in HeaderAndShortIDs to provide a list of a few transactions explicitly.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|index||New VarInt||1-3 bytes||[[#New_VarInt|New VarInt]], differentially encoded since the last PrefilledTransaction in a list||The index into the block at which this transaction is\n+|-\n+|tx||Transaction||variable||As encoded in \"tx\" messages||The transaction which is in the block at index index.\n+|}\n+\n+====HeaderAndShortIDs====\n+A HeaderAndShortIDs structure is used to relay a block header, the short transactions IDs used for matching already-available transactions, and a select few transactions which we expect a peer may be missing.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|header||Block header||80 bytes||First 80 bytes of the block as defined by the encoding used by \"block\" messages||The header of the block being provided\n+|-\n+|nonce||uint64_t||8 bytes||Little Endian||A nonce for use in short transaction ID calculations\n+|-\n+|shortids_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of short transaction IDs in shortids (ie block tx count - prefilledtxn_length)\n+|-\n+|shortids||List of 6-byte integers||6*shortids_length bytes||Little Endian||The short transaction IDs calculated from the transactions which were not provided explicitly in prefilledtxn\n+|-\n+|prefilledtxn_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of prefilled transactions in prefilledtxn (ie block tx count - shortids_length)\n+|-\n+|prefilledtxn||List of PrefilledTransactions||variable size*prefilledtxn_length||As defined by PrefilledTransaction definition, above||Used to provide the coinbase transaction and a select few which we expect a peer may be missing\n+|}\n+\n+====BlockTransactionsRequest====\n+A BlockTransactionsRequest structure is used to list transaction indexes in a block being requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being requested are in\n+|-\n+|indexes_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of transactions being requested\n+|-\n+|indexes||List of New VarInts||1-3 bytes*indexes_length||As defined in [[#New_VarInt|New VarInt]], differentially encoded||The indexes of the transactions being requested in the block\n+|}\n+\n+====BlockTransactions====\n+A BlockTransactions structure is used to provide some of the transactions in a block, as requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being provided are in\n+|-\n+|transactions_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of transactions provided\n+|-\n+|transactions||List of Transactions||variable||As encoded in \"tx\" messages||The transactions provided\n+|}\n+\n+====Short transaction IDs====\n+Short transaction IDs are used to represent a transaction without sending a full 256-bit hash. They are calculated by:\n+# single-SHA256 hashing the block header with the nonce appended (in little-endian)\n+# Running SipHash2-4 with the input being the transaction ID and the keys (k0/k1) set to the first two little-endian 64-bit integers from the above hash, respectively.\n+# Dropping the 2 most significant bytes from the SipHash output to make it 6 bytes.\n+\n+===New messages===\n+A new inv type (MSG_CMPCT_BLOCK == 4) and several new protocol messages are added: sendcmpct, cmpctblock, getblocktxn, and blocktxn.\n+\n+====sendcmpct====\n+# The sendcmpct message is defined as a message containing a 1-byte integer followed by a 8-byte integer where pchCommand == \"sendcmpct\".\n+# The first integer SHALL be interpreted as a boolean (and MUST have a value of either 1 or 0)\n+# The second integer SHALL be interpreted as a little-endian version number. Nodes sending a sendcmpct message MUST currently set this value to 1.\n+# Upon receipt of a \"sendcmpct\" message with the first and second integers set to 1, the node SHOULD announce new blocks by sending a cmpctblock message.\n+# Upon receipt of a \"sendcmpct\" message with the first integer set to 0, the node SHOULD NOT announce new blocks by sending a cmpctblock message, but SHOULD announce new blocks by sending invs or headers, as defined by BIP130.\n+# Upon receipt of a \"sendcmpct\" message with the second integer set to something other than 1, nodes MUST treat the peer as if they had not received the message (as it indicates the peer will provide an unexpected encoding in cmpctblock, and/or other, messages). This allows future versions to send duplicate sendcmpct messages with different versions as a part of a version handshake for future versions.\n+# Nodes SHOULD check for a protocol version of >= 70014 before sending sendcmpct messages.\n+# Nodes MUST NOT send a request for a MSG_CMPCT_BLOCK object to a peer before having received a sendcmpct message from that peer.\n+\n+====MSG_CMPCT_BLOCK====\n+# getdata messages may now contain requests for MSG_CMPCT_BLOCK objects.\n+# Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK object with the hash of a block which was recently announced and after having sent the requesting peer a sendcmpct message, nodes MUST respond with a cmpctblock message containing appropriate data representing the block being requested.\n+# MSG_CMPCT_BLOCK inv objects MUST NOT appear anywhere except for in getdata messages.\n+\n+====cmpctblock====\n+# The cmpctblock message is defined as as a message containing a serialized HeaderAndShortIDs message and pchCommand == \"cmpctblock\".\n+# Upon receipt of a cmpctblock message after sending a sendcmpct message, nodes SHOULD calculate the short transaction ID for each unconfirmed transaction they have available (ie in their mempool) and compare each to each short transaction ID in the cmpctblock message.\n+# After finding already-available transactions, nodes which do not have all transactions available to reconstruct the full block SHOULD request the missing transactions using a getblocktxn message.\n+# A node MUST NOT send a cmpctblock message unless they are able to respond to a getblocktxn message which requests every transaction in the block.\n+# A node MUST NOT send a cmpctblock message without having validated that the header properly commits to each transaction in the block, and properly builds on top of the existing chain with a valid proof-of-work. A node MAY send a cmpctblock before validating that each transaction in the block validly spends existing UTXO set entries.\n+\n+====getblocktxn====\n+# The getblocktxn message is defined as as a message containing a serialized BlockTransactionsRequest message and pchCommand == \"getblocktxn\".\n+# Upon receipt of a properly-formatted getblocktxnmessage, nodes which recently provided the sender of such a message a cmpctblock for the block hash identified in this message MUST respond with an appropriate blocktxn message. Such a blocktxn message MUST contain exactly and only each transaction which is present in the appropriate block at the index specified in the getblocktxn indexes list, in the order requested.\n+\n+====blocktxn====\n+# The blocktxn message is defined as as a message containing a serialized BlockTransactions message and pchCommand == \"blocktxn\".\n+# Upon receipt of a properly-formatted requested blocktxn message, nodes SHOULD attempt to reconstruct the full block by:\n+## Taking the prefilledtxn transactions from the original cmpctblock and placing them in the marked positions.\n+## For each short transaction ID from the original cmpctblock, in order, find the corresponding transaction either from the blocktxn message or from other sources and place it in the first available position in the block.\n+# Once the block has been reconstructed, it shall be processed as normal, keeping in mind that short transaction IDs are expected to occasionally collide, and that nodes MUST NOT be penalized for such collisions, wherever they appear.\n+\n+===Implementation Notes===\n+# For nodes which have sufficient inbound bandwidth, sending a sendcmpct message with the first integer set to 1 to up to 3 peers is RECOMMENDED. If possible, it is RECOMMENDED that those peers be selected based on their past performance in providing blocks quickly (eg the three peers which provided the highest number of the recent N blocks the quickest), allowing nodes to receive blocks which come from those peers in only 0.5*RTT.\n+\n+# Nodes MUST NOT send such sendcmpct messages to more than three peers, as it encourages wasting outbound bandwidth across the network.\n+\n+# All nodes SHOULD send a sendcmpct message to all appropriate peers. This will reduce their outbound bandwidth usage by allowing their peers to request compact blocks instead of full blocks.\n+\n+# Nodes with limited inbound bandwidth SHOULD request blocks using MSG_CMPCT_BLOCK/getblocktxn requests, when possible. While this increases worst-case message round-trips, it is expected to reduce overall transfer latency as TCP is more likely to exhibit poor throughput on low-bandwidth nodes.\n+\n+# Nodes sending cmpctblock messages SHOULD limit prefilledtxn to 10KB of transactions. When in doubt, nodes SHOULD only include the coinbase transaction in prefilledtxn.\n+\n+# Nodes MAY pick one nonce per block they wish to send, and only build a cmpctblock message once for all peers which they wish to send a given block to. Nodes SHOULD NOT use the same nonce across multiple different blocks.\n+\n+# Nodes MAY impose additional requirements on when they announce new blocks by sending cmpctblock messages. For example, nodes with limited outbound bandwidth MAY choose to announce new blocks using inv/header messages (as per BIP130) to conserve outbound bandwidth.\n+\n+# Note that the MSG_CMPCT_BLOCK section does not require that nodes respond to MSG_CMPCT_BLOCK getdata requests for blocks which they did not recently announce. This allows nodes to calculate cmpctblock messages at announce-time instead of at request-time. Thus, nodes MUST NOT request blocks using MSG_CMPCT_BLOCK getdatas unless it is in response to an inv/headers block announcement (as per BIP130), and MUST NOT request blocks using MSG_CMPCT_BLOCK getdatas in response to headers messages which were, themselves, responses to getheaders requests.\n+\n+# While the current version sends transactions with the same encodings as is used in tx messages and elsewhere in the protocol, the version field in sendcmpct is intended to allow this to change in the future. For this reason, it is recommended that the code used to decode PrefilledTransaction and BlockTransactions messages be prepared to take a different transaction encoding, if and when the version field in sendcmpct changes in a future BIP.\n+\n+==Justification==\n+\n+====Protocol design====\n+There have been many proposals to save wire bytes when relaying blocks. Many of them have a two-fold goal of reducing block relay time and thus rely on the use of significant processing power in order to avoid introducing additional worst-case RTTs. Because this work is not focused primarily on reducing block relay time, its design is much simpler (ie does not rely on set reconciliation protocols). Still, in testing at the time of writing, nodes are able to relay blocks without the extra getblocktxn/blocktxn RTT around 90% of the time. With a smart compact-block-announcement policy, it is thus expected that this work might allow blocks to be relayed between nodes in 0.5*RTT instead of 1.5*RTT at least 75% of the time.\n+\n+====Use of New VarInts====\n+Bitcoin has long had a variable-length integer implementation (referred to as CompactSize in this document), making a second a strange protocol quirk. However, in this protocol most of our variable-length integers are between 0 and 2000. For both encodings, small numbers (<100) are encoded as 1-byte. For numbers over 250, the CompactSize encoding begins to use 3 bytes instead of 1, whereas the New VarInt encoding uses 2. Because the primary motivation for this work is to save bytes during block relay, the extra byte of saving per transaction-difference is considered worth the extra design complexity.\n+",
      "path": "bip-0152.mediawiki",
      "position": null,
      "original_position": 189,
      "commit_id": "20a842244bbdf85c36b16544def261b9da0948da",
      "original_commit_id": "3250edf3029cbbf21cb2462b77a5ee48812bd0ff",
      "in_reply_to_id": null,
      "user": {
        "login": "dcousens",
        "id": 413395,
        "node_id": "MDQ6VXNlcjQxMzM5NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/413395?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dcousens",
        "html_url": "https://github.com/dcousens",
        "followers_url": "https://api.github.com/users/dcousens/followers",
        "following_url": "https://api.github.com/users/dcousens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dcousens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dcousens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dcousens/subscriptions",
        "organizations_url": "https://api.github.com/users/dcousens/orgs",
        "repos_url": "https://api.github.com/users/dcousens/repos",
        "events_url": "https://api.github.com/users/dcousens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dcousens/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@luke-jr is there any alternative to the ML for those of us that find it a pain to keep track of?  It just seems that given GitHub is set up as a collaboration platform that most development already occurs on,  discussion would be easier (for some) here.\n",
      "created_at": "2016-05-18T05:41:34Z",
      "updated_at": "2016-05-23T01:21:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/389#discussion_r63647771",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63647771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63652491",
      "pull_request_review_id": null,
      "id": 63652491,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjUyNDkx",
      "diff_hunk": "@@ -0,0 +1,212 @@\n+<pre>\n+  BIP: 152\n+  Title: Compact block relay",
      "path": "bip-0152.mediawiki",
      "position": null,
      "original_position": 3,
      "commit_id": "20a842244bbdf85c36b16544def261b9da0948da",
      "original_commit_id": "3250edf3029cbbf21cb2462b77a5ee48812bd0ff",
      "in_reply_to_id": null,
      "user": {
        "login": "btcdrak",
        "id": 7275704,
        "node_id": "MDQ6VXNlcjcyNzU3MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7275704?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/btcdrak",
        "html_url": "https://github.com/btcdrak",
        "followers_url": "https://api.github.com/users/btcdrak/followers",
        "following_url": "https://api.github.com/users/btcdrak/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/btcdrak/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/btcdrak/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/btcdrak/subscriptions",
        "organizations_url": "https://api.github.com/users/btcdrak/orgs",
        "repos_url": "https://api.github.com/users/btcdrak/repos",
        "events_url": "https://api.github.com/users/btcdrak/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/btcdrak/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/Compact block relay/Compact Block Relay/ to match README.md (or vice versa)\n",
      "created_at": "2016-05-18T06:40:19Z",
      "updated_at": "2016-05-23T01:21:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/389#discussion_r63652491",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63652491"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63652600",
      "pull_request_review_id": null,
      "id": 63652600,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjUyNjAw",
      "diff_hunk": "@@ -0,0 +1,212 @@\n+<pre>\n+  BIP: 152\n+  Title: Compact block relay\n+  Author: Matt Corallo <bip@bluematt.me>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2016-04-27\n+</pre>\n+\n+==Abstract==\n+\n+Compact blocks on the wire as a way to save bandwidth for nodes on the P2P network.\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n+\n+==Motivation==\n+\n+Historically, the Bitcoin P2P protocol has not been very bandwidth efficient for block relay. Every transaction in a block is included when relayed, even though a large number of the transactions in a given block are already available to nodes before the block is relayed. This causes moderate inbound bandwidth spikes for nodes when receiving blocks, but can cause very significant outbound bandwidth spikes for some nodes which receive a block before their peers. When such spikes occur, buffer bloat can make consumer-grade internet connections temporarily unusable, and can delay the relay of blocks to remote peers who may choose to wait instead of redundantly requesting the same block from other, less congested, peers.\n+\n+Thus, decreasing the bandwidth used during block relay is very useful for many individuals running nodes.\n+\n+While the goal of this work is explicitly not to reduce block transfer latency, it does, as a side effect reduce block transfer latencies in some rather significant ways. Additionally, this work forms a foundation for future work explicitly targeting low-latency block transfer.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+<img src=bip-0152/protocol-flow.png></img>\n+\n+The protocol is intended to be used in two ways, depending on the peers and bandwidth available, as discussed [[#Implementation_Details|later]]. The \"high-bandwidth\" mode, which nodes may only enable for a few of their peers, is enabled by setting the first boolean to 1 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the short transaction IDs already (via a cmpctblock message), possibly even before fully validating the block (as indicated by the grey box in the image above). In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual immediately. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the best-case latency to the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage.\n+\n+The \"low-bandwidth\" mode is enabled by setting the first boolean to 0 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the usual inv/headers announcements (as per BIP130, and after fully validating the block). The receiving peer may then request the block using a MSG_CMPCT_BLOCK getdata request, which will receive a response of the header and short transaction IDs. In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual, taking the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the latency to at least 2.5*RTT in this case, again with significantly less bandwidth usage than today. Because TCP often exhibits worse transfer latency for larger data sizes (as a multiple of RTT), total latency is expected to be reduced even when the full 2.5*RTT transfer mechanism is used.\n+\n+===New data structures===\n+Several new data structures are added to the P2P network to relay compact blocks: PrefilledTransaction, HeaderAndShortIDs, BlockTransactionsRequest, and BlockTransactions. Additionally, we introduce a new variable-length integer encoding for use in these data structures.\n+\n+For the purposes of this section, CompactSize refers to the variable-length integer encoding used across the existing P2P protocol to encode array lengths, among other things, in 1, 3, 5 or 9 bytes.\n+\n+====New VarInt====\n+TODO: I just copied this out of the src...Something that is wiki-formatted and more descriptive should be used here instead.\n+\n+ Variable-length integers: bytes are a MSB base-128 encoding of the number.\n+ The high bit in each byte signifies whether another digit follows. To make\n+ sure the encoding is one-to-one, one is subtracted from all but the last digit.\n+ Thus, the byte sequence a[] with length len, where all but the last byte\n+ has bit 128 set, encodes the number:\n+\n+ (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))\n+\n+ Properties:\n+ * Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)\n+ * Every integer has exactly one encoding\n+ * Encoding does not depend on size of original integer type\n+ * No redundancy: every (infinite) byte sequence corresponds to a list\n+   of encoded integers.\n+\n+ 0:         [0x00]  256:        [0x81 0x00]\n+ 1:         [0x01]  16383:      [0xFE 0x7F]\n+ 127:       [0x7F]  16384:      [0xFF 0x00]\n+ 128:  [0x80 0x00]  16511: [0x80 0xFF 0x7F]\n+ 255:  [0x80 0x7F]  65535: [0x82 0xFD 0x7F]\n+ 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]\n+\n+Several uses of New VarInts below are \"differentially encoded\". For these, instead of using raw indexes, the number encoded is the difference between the current index and the previous index, minus one. For example, a first index of 0 implies a real index of 0, a second index of 0 thereafter refers to a real index of 1, etc.\n+\n+====PrefilledTransaction====\n+A PrefilledTransaction structure is used in HeaderAndShortIDs to provide a list of a few transactions explicitly.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|index||New VarInt||1-3 bytes||[[#New_VarInt|New VarInt]], differentially encoded since the last PrefilledTransaction in a list||The index into the block at which this transaction is\n+|-\n+|tx||Transaction||variable||As encoded in \"tx\" messages||The transaction which is in the block at index index.\n+|}\n+\n+====HeaderAndShortIDs====\n+A HeaderAndShortIDs structure is used to relay a block header, the short transactions IDs used for matching already-available transactions, and a select few transactions which we expect a peer may be missing.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|header||Block header||80 bytes||First 80 bytes of the block as defined by the encoding used by \"block\" messages||The header of the block being provided\n+|-\n+|nonce||uint64_t||8 bytes||Little Endian||A nonce for use in short transaction ID calculations\n+|-\n+|shortids_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of short transaction IDs in shortids (ie block tx count - prefilledtxn_length)\n+|-\n+|shortids||List of 6-byte integers||6*shortids_length bytes||Little Endian||The short transaction IDs calculated from the transactions which were not provided explicitly in prefilledtxn\n+|-\n+|prefilledtxn_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of prefilled transactions in prefilledtxn (ie block tx count - shortids_length)\n+|-\n+|prefilledtxn||List of PrefilledTransactions||variable size*prefilledtxn_length||As defined by PrefilledTransaction definition, above||Used to provide the coinbase transaction and a select few which we expect a peer may be missing\n+|}\n+\n+====BlockTransactionsRequest====\n+A BlockTransactionsRequest structure is used to list transaction indexes in a block being requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being requested are in\n+|-\n+|indexes_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of transactions being requested\n+|-\n+|indexes||List of New VarInts||1-3 bytes*indexes_length||As defined in [[#New_VarInt|New VarInt]], differentially encoded||The indexes of the transactions being requested in the block\n+|}\n+\n+====BlockTransactions====\n+A BlockTransactions structure is used to provide some of the transactions in a block, as requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being provided are in\n+|-\n+|transactions_length||New VarInt||1-3 bytes||As defined in [[#New_VarInt|New VarInt]]||The number of transactions provided\n+|-\n+|transactions||List of Transactions||variable||As encoded in \"tx\" messages||The transactions provided\n+|}\n+\n+====Short transaction IDs====\n+Short transaction IDs are used to represent a transaction without sending a full 256-bit hash. They are calculated by:\n+# single-SHA256 hashing the block header with the nonce appended (in little-endian)\n+# Running SipHash2-4 with the input being the transaction ID and the keys (k0/k1) set to the first two little-endian 64-bit integers from the above hash, respectively.\n+# Dropping the 2 most significant bytes from the SipHash output to make it 6 bytes.\n+\n+===New messages===\n+A new inv type (MSG_CMPCT_BLOCK == 4) and several new protocol messages are added: sendcmpct, cmpctblock, getblocktxn, and blocktxn.\n+\n+====sendcmpct====\n+# The sendcmpct message is defined as a message containing a 1-byte integer followed by a 8-byte integer where pchCommand == \"sendcmpct\".\n+# The first integer SHALL be interpreted as a boolean (and MUST have a value of either 1 or 0)\n+# The second integer SHALL be interpreted as a little-endian version number. Nodes sending a sendcmpct message MUST currently set this value to 1.\n+# Upon receipt of a \"sendcmpct\" message with the first and second integers set to 1, the node SHOULD announce new blocks by sending a cmpctblock message.\n+# Upon receipt of a \"sendcmpct\" message with the first integer set to 0, the node SHOULD NOT announce new blocks by sending a cmpctblock message, but SHOULD announce new blocks by sending invs or headers, as defined by BIP130.\n+# Upon receipt of a \"sendcmpct\" message with the second integer set to something other than 1, nodes MUST treat the peer as if they had not received the message (as it indicates the peer will provide an unexpected encoding in cmpctblock, and/or other, messages). This allows future versions to send duplicate sendcmpct messages with different versions as a part of a version handshake for future versions.\n+# Nodes SHOULD check for a protocol version of >= 70014 before sending sendcmpct messages.\n+# Nodes MUST NOT send a request for a MSG_CMPCT_BLOCK object to a peer before having received a sendcmpct message from that peer.\n+\n+====MSG_CMPCT_BLOCK====\n+# getdata messages may now contain requests for MSG_CMPCT_BLOCK objects.\n+# Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK object with the hash of a block which was recently announced and after having sent the requesting peer a sendcmpct message, nodes MUST respond with a cmpctblock message containing appropriate data representing the block being requested.\n+# MSG_CMPCT_BLOCK inv objects MUST NOT appear anywhere except for in getdata messages.\n+\n+====cmpctblock====\n+# The cmpctblock message is defined as as a message containing a serialized HeaderAndShortIDs message and pchCommand == \"cmpctblock\".\n+# Upon receipt of a cmpctblock message after sending a sendcmpct message, nodes SHOULD calculate the short transaction ID for each unconfirmed transaction they have available (ie in their mempool) and compare each to each short transaction ID in the cmpctblock message.\n+# After finding already-available transactions, nodes which do not have all transactions available to reconstruct the full block SHOULD request the missing transactions using a getblocktxn message.\n+# A node MUST NOT send a cmpctblock message unless they are able to respond to a getblocktxn message which requests every transaction in the block.\n+# A node MUST NOT send a cmpctblock message without having validated that the header properly commits to each transaction in the block, and properly builds on top of the existing chain with a valid proof-of-work. A node MAY send a cmpctblock before validating that each transaction in the block validly spends existing UTXO set entries.\n+\n+====getblocktxn====\n+# The getblocktxn message is defined as as a message containing a serialized BlockTransactionsRequest message and pchCommand == \"getblocktxn\".\n+# Upon receipt of a properly-formatted getblocktxnmessage, nodes which recently provided the sender of such a message a cmpctblock for the block hash identified in this message MUST respond with an appropriate blocktxn message. Such a blocktxn message MUST contain exactly and only each transaction which is present in the appropriate block at the index specified in the getblocktxn indexes list, in the order requested.\n+\n+====blocktxn====\n+# The blocktxn message is defined as as a message containing a serialized BlockTransactions message and pchCommand == \"blocktxn\".\n+# Upon receipt of a properly-formatted requested blocktxn message, nodes SHOULD attempt to reconstruct the full block by:\n+## Taking the prefilledtxn transactions from the original cmpctblock and placing them in the marked positions.\n+## For each short transaction ID from the original cmpctblock, in order, find the corresponding transaction either from the blocktxn message or from other sources and place it in the first available position in the block.\n+# Once the block has been reconstructed, it shall be processed as normal, keeping in mind that short transaction IDs are expected to occasionally collide, and that nodes MUST NOT be penalized for such collisions, wherever they appear.\n+\n+===Implementation Notes===\n+# For nodes which have sufficient inbound bandwidth, sending a sendcmpct message with the first integer set to 1 to up to 3 peers is RECOMMENDED. If possible, it is RECOMMENDED that those peers be selected based on their past performance in providing blocks quickly (eg the three peers which provided the highest number of the recent N blocks the quickest), allowing nodes to receive blocks which come from those peers in only 0.5*RTT.\n+\n+# Nodes MUST NOT send such sendcmpct messages to more than three peers, as it encourages wasting outbound bandwidth across the network.\n+\n+# All nodes SHOULD send a sendcmpct message to all appropriate peers. This will reduce their outbound bandwidth usage by allowing their peers to request compact blocks instead of full blocks.\n+\n+# Nodes with limited inbound bandwidth SHOULD request blocks using MSG_CMPCT_BLOCK/getblocktxn requests, when possible. While this increases worst-case message round-trips, it is expected to reduce overall transfer latency as TCP is more likely to exhibit poor throughput on low-bandwidth nodes.\n+\n+# Nodes sending cmpctblock messages SHOULD limit prefilledtxn to 10KB of transactions. When in doubt, nodes SHOULD only include the coinbase transaction in prefilledtxn.\n+\n+# Nodes MAY pick one nonce per block they wish to send, and only build a cmpctblock message once for all peers which they wish to send a given block to. Nodes SHOULD NOT use the same nonce across multiple different blocks.\n+\n+# Nodes MAY impose additional requirements on when they announce new blocks by sending cmpctblock messages. For example, nodes with limited outbound bandwidth MAY choose to announce new blocks using inv/header messages (as per BIP130) to conserve outbound bandwidth.\n+\n+# Note that the MSG_CMPCT_BLOCK section does not require that nodes respond to MSG_CMPCT_BLOCK getdata requests for blocks which they did not recently announce. This allows nodes to calculate cmpctblock messages at announce-time instead of at request-time. Thus, nodes MUST NOT request blocks using MSG_CMPCT_BLOCK getdatas unless it is in response to an inv/headers block announcement (as per BIP130), and MUST NOT request blocks using MSG_CMPCT_BLOCK getdatas in response to headers messages which were, themselves, responses to getheaders requests.\n+\n+# While the current version sends transactions with the same encodings as is used in tx messages and elsewhere in the protocol, the version field in sendcmpct is intended to allow this to change in the future. For this reason, it is recommended that the code used to decode PrefilledTransaction and BlockTransactions messages be prepared to take a different transaction encoding, if and when the version field in sendcmpct changes in a future BIP.\n+\n+==Justification==\n+\n+====Protocol design====\n+There have been many proposals to save wire bytes when relaying blocks. Many of them have a two-fold goal of reducing block relay time and thus rely on the use of significant processing power in order to avoid introducing additional worst-case RTTs. Because this work is not focused primarily on reducing block relay time, its design is much simpler (ie does not rely on set reconciliation protocols). Still, in testing at the time of writing, nodes are able to relay blocks without the extra getblocktxn/blocktxn RTT around 90% of the time. With a smart compact-block-announcement policy, it is thus expected that this work might allow blocks to be relayed between nodes in 0.5*RTT instead of 1.5*RTT at least 75% of the time.\n+\n+====Use of New VarInts====\n+Bitcoin has long had a variable-length integer implementation (referred to as CompactSize in this document), making a second a strange protocol quirk. However, in this protocol most of our variable-length integers are between 0 and 2000. For both encodings, small numbers (<100) are encoded as 1-byte. For numbers over 250, the CompactSize encoding begins to use 3 bytes instead of 1, whereas the New VarInt encoding uses 2. Because the primary motivation for this work is to save bytes during block relay, the extra byte of saving per transaction-difference is considered worth the extra design complexity.\n+",
      "path": "bip-0152.mediawiki",
      "position": null,
      "original_position": 189,
      "commit_id": "20a842244bbdf85c36b16544def261b9da0948da",
      "original_commit_id": "3250edf3029cbbf21cb2462b77a5ee48812bd0ff",
      "in_reply_to_id": null,
      "user": {
        "login": "btcdrak",
        "id": 7275704,
        "node_id": "MDQ6VXNlcjcyNzU3MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7275704?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/btcdrak",
        "html_url": "https://github.com/btcdrak",
        "followers_url": "https://api.github.com/users/btcdrak/followers",
        "following_url": "https://api.github.com/users/btcdrak/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/btcdrak/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/btcdrak/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/btcdrak/subscriptions",
        "organizations_url": "https://api.github.com/users/btcdrak/orgs",
        "repos_url": "https://api.github.com/users/btcdrak/repos",
        "events_url": "https://api.github.com/users/btcdrak/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/btcdrak/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@dcousens the thread is here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012624.html\n",
      "created_at": "2016-05-18T06:41:35Z",
      "updated_at": "2016-05-23T01:21:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/389#discussion_r63652600",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63652600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63654982",
      "pull_request_review_id": null,
      "id": 63654982,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjU0OTgy",
      "diff_hunk": "@@ -0,0 +1,212 @@\n+<pre>\n+  BIP: 152\n+  Title: Compact block relay\n+  Author: Matt Corallo <bip@bluematt.me>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2016-04-27\n+</pre>\n+\n+==Abstract==\n+\n+Compact blocks on the wire as a way to save bandwidth for nodes on the P2P network.\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n+\n+==Motivation==\n+\n+Historically, the Bitcoin P2P protocol has not been very bandwidth efficient for block relay. Every transaction in a block is included when relayed, even though a large number of the transactions in a given block are already available to nodes before the block is relayed. This causes moderate inbound bandwidth spikes for nodes when receiving blocks, but can cause very significant outbound bandwidth spikes for some nodes which receive a block before their peers. When such spikes occur, buffer bloat can make consumer-grade internet connections temporarily unusable, and can delay the relay of blocks to remote peers who may choose to wait instead of redundantly requesting the same block from other, less congested, peers.\n+\n+Thus, decreasing the bandwidth used during block relay is very useful for many individuals running nodes.\n+\n+While the goal of this work is explicitly not to reduce block transfer latency, it does, as a side effect reduce block transfer latencies in some rather significant ways. Additionally, this work forms a foundation for future work explicitly targeting low-latency block transfer.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+<img src=bip-0152/protocol-flow.png></img>\n+\n+The protocol is intended to be used in two ways, depending on the peers and bandwidth available, as discussed [[#Implementation_Details|later]]. The \"high-bandwidth\" mode, which nodes may only enable for a few of their peers, is enabled by setting the first boolean to 1 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the short transaction IDs already (via a cmpctblock message), possibly even before fully validating the block (as indicated by the grey box in the image above). In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual immediately. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the best-case latency to the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage.",
      "path": "bip-0152.mediawiki",
      "position": null,
      "original_position": 29,
      "commit_id": "20a842244bbdf85c36b16544def261b9da0948da",
      "original_commit_id": "3250edf3029cbbf21cb2462b77a5ee48812bd0ff",
      "in_reply_to_id": null,
      "user": {
        "login": "btcdrak",
        "id": 7275704,
        "node_id": "MDQ6VXNlcjcyNzU3MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7275704?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/btcdrak",
        "html_url": "https://github.com/btcdrak",
        "followers_url": "https://api.github.com/users/btcdrak/followers",
        "following_url": "https://api.github.com/users/btcdrak/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/btcdrak/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/btcdrak/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/btcdrak/subscriptions",
        "organizations_url": "https://api.github.com/users/btcdrak/orgs",
        "repos_url": "https://api.github.com/users/btcdrak/repos",
        "events_url": "https://api.github.com/users/btcdrak/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/btcdrak/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe put `cmpctblock` etc  in backticks to make it clear it's protocol message, otherwise it reads like a spelling mistake/typo.\n",
      "created_at": "2016-05-18T07:07:11Z",
      "updated_at": "2016-05-23T01:21:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/389#discussion_r63654982",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63654982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63655748",
      "pull_request_review_id": null,
      "id": 63655748,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjU1NzQ4",
      "diff_hunk": "@@ -0,0 +1,212 @@\n+<pre>\n+  BIP: 152\n+  Title: Compact block relay\n+  Author: Matt Corallo <bip@bluematt.me>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2016-04-27\n+</pre>\n+\n+==Abstract==\n+\n+Compact blocks on the wire as a way to save bandwidth for nodes on the P2P network.\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n+\n+==Motivation==\n+\n+Historically, the Bitcoin P2P protocol has not been very bandwidth efficient for block relay. Every transaction in a block is included when relayed, even though a large number of the transactions in a given block are already available to nodes before the block is relayed. This causes moderate inbound bandwidth spikes for nodes when receiving blocks, but can cause very significant outbound bandwidth spikes for some nodes which receive a block before their peers. When such spikes occur, buffer bloat can make consumer-grade internet connections temporarily unusable, and can delay the relay of blocks to remote peers who may choose to wait instead of redundantly requesting the same block from other, less congested, peers.\n+\n+Thus, decreasing the bandwidth used during block relay is very useful for many individuals running nodes.\n+\n+While the goal of this work is explicitly not to reduce block transfer latency, it does, as a side effect reduce block transfer latencies in some rather significant ways. Additionally, this work forms a foundation for future work explicitly targeting low-latency block transfer.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+<img src=bip-0152/protocol-flow.png></img>\n+\n+The protocol is intended to be used in two ways, depending on the peers and bandwidth available, as discussed [[#Implementation_Details|later]]. The \"high-bandwidth\" mode, which nodes may only enable for a few of their peers, is enabled by setting the first boolean to 1 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the short transaction IDs already (via a cmpctblock message), possibly even before fully validating the block (as indicated by the grey box in the image above). In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual immediately. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the best-case latency to the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage.\n+\n+The \"low-bandwidth\" mode is enabled by setting the first boolean to 0 in a \"sendcmpct\" message. In this mode, peers send new block announcements with the usual inv/headers announcements (as per BIP130, and after fully validating the block). The receiving peer may then request the block using a MSG_CMPCT_BLOCK getdata request, which will receive a response of the header and short transaction IDs. In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual, taking the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage. When some transactions were not available from local sources (ie mempool), a getblocktxn/blocktxn roundtrip is necessary, bringing the latency to at least 2.5*RTT in this case, again with significantly less bandwidth usage than today. Because TCP often exhibits worse transfer latency for larger data sizes (as a multiple of RTT), total latency is expected to be reduced even when the full 2.5*RTT transfer mechanism is used.\n+\n+===New data structures===\n+Several new data structures are added to the P2P network to relay compact blocks: PrefilledTransaction, HeaderAndShortIDs, BlockTransactionsRequest, and BlockTransactions. Additionally, we introduce a new variable-length integer encoding for use in these data structures.\n+\n+For the purposes of this section, CompactSize refers to the variable-length integer encoding used across the existing P2P protocol to encode array lengths, among other things, in 1, 3, 5 or 9 bytes.\n+\n+====New VarInt====\n+TODO: I just copied this out of the src...Something that is wiki-formatted and more descriptive should be used here instead.",
      "path": "bip-0152.mediawiki",
      "position": null,
      "original_position": 39,
      "commit_id": "20a842244bbdf85c36b16544def261b9da0948da",
      "original_commit_id": "3250edf3029cbbf21cb2462b77a5ee48812bd0ff",
      "in_reply_to_id": null,
      "user": {
        "login": "btcdrak",
        "id": 7275704,
        "node_id": "MDQ6VXNlcjcyNzU3MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7275704?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/btcdrak",
        "html_url": "https://github.com/btcdrak",
        "followers_url": "https://api.github.com/users/btcdrak/followers",
        "following_url": "https://api.github.com/users/btcdrak/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/btcdrak/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/btcdrak/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/btcdrak/subscriptions",
        "organizations_url": "https://api.github.com/users/btcdrak/orgs",
        "repos_url": "https://api.github.com/users/btcdrak/repos",
        "events_url": "https://api.github.com/users/btcdrak/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/btcdrak/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "you can just enclose it in `<pre> </pre>` tags.\n",
      "created_at": "2016-05-18T07:15:56Z",
      "updated_at": "2016-05-23T01:21:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/389#discussion_r63655748",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63655748"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63798198",
      "pull_request_review_id": null,
      "id": 63798198,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNzk4MTk4",
      "diff_hunk": "@@ -0,0 +1,186 @@\n+<pre>\n+  BIP: 152\n+  Title: Compact Block Relay\n+  Author: Matt Corallo <bip@bluematt.me>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2016-04-27\n+</pre>\n+\n+==Abstract==\n+\n+Compact blocks on the wire as a way to save bandwidth for nodes on the P2P network.\n+\n+The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.\n+\n+==Motivation==\n+\n+Historically, the Bitcoin P2P protocol has not been very bandwidth efficient for block relay. Every transaction in a block is included when relayed, even though a large number of the transactions in a given block are already available to nodes before the block is relayed. This causes moderate inbound bandwidth spikes for nodes when receiving blocks, but can cause very significant outbound bandwidth spikes for some nodes which receive a block before their peers. When such spikes occur, buffer bloat can make consumer-grade internet connections temporarily unusable, and can delay the relay of blocks to remote peers who may choose to wait instead of redundantly requesting the same block from other, less congested, peers.\n+\n+Thus, decreasing the bandwidth used during block relay is very useful for many individuals running nodes.\n+\n+While the goal of this work is explicitly not to reduce block transfer latency, it does, as a side effect reduce block transfer latencies in some rather significant ways. Additionally, this work forms a foundation for future work explicitly targeting low-latency block transfer.\n+\n+==Specification==\n+\n+===Intended Protocol Flow===\n+<img src=bip-0152/protocol-flow.png></img>\n+\n+The protocol is intended to be used in two ways, depending on the peers and bandwidth available, as discussed [[#Implementation_Details|later]]. The \"high-bandwidth\" mode, which nodes may only enable for a few of their peers, is enabled by setting the first boolean to 1 in a <code>sendcmpct</code> message. In this mode, peers send new block announcements with the short transaction IDs already (via a <code>cmpctblock</code> message), possibly even before fully validating the block (as indicated by the grey box in the image above). In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual immediately. When some transactions were not available from local sources (ie mempool), a <code>getblocktxn</code>/<code>blocktxn</code> roundtrip is necessary, bringing the best-case latency to the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage.\n+\n+The \"low-bandwidth\" mode is enabled by setting the first boolean to 0 in a <code>sendcmpct</code> message. In this mode, peers send new block announcements with the usual inv/headers announcements (as per BIP130, and after fully validating the block). The receiving peer may then request the block using a MSG_CMPCT_BLOCK <code>getdata</code> request, which will receive a response of the header and short transaction IDs. In some cases no further round-trip is needed, and the receiver can reconstruct the block and process it as usual, taking the same 1.5*RTT minimum time that nodes take today, though with significantly less bandwidth usage. When some transactions were not available from local sources (ie mempool), a <code>getblocktxn</code>/<code>blocktxn</code> roundtrip is necessary, bringing the latency to at least 2.5*RTT in this case, again with significantly less bandwidth usage than today. Because TCP often exhibits worse transfer latency for larger data sizes (as a multiple of RTT), total latency is expected to be reduced even when the full 2.5*RTT transfer mechanism is used.\n+\n+===New data structures===\n+Several new data structures are added to the P2P network to relay compact blocks: PrefilledTransaction, HeaderAndShortIDs, BlockTransactionsRequest, and BlockTransactions.\n+\n+For the purposes of this section, CompactSize refers to the variable-length integer encoding used across the existing P2P protocol to encode array lengths, among other things, in 1, 3, 5 or 9 bytes. Only CompactSize encodings which are minimally-encoded (ie the shortest length possible) are used by this spec. Any other CompactSize encodings are left with undefined behavior.\n+\n+Several uses of CompactSize below are \"differentially encoded\". For these, instead of using raw indexes, the number encoded is the difference between the current index and the previous index, minus one. For example, a first index of 0 implies a real index of 0, a second index of 0 thereafter refers to a real index of 1, etc.\n+\n+====PrefilledTransaction====\n+A PrefilledTransaction structure is used in HeaderAndShortIDs to provide a list of a few transactions explicitly.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|index||CompactSize||1, 3 bytes||Compact Size, differentially encoded since the last PrefilledTransaction in a list||The index into the block at which this transaction is\n+|-\n+|tx||Transaction||variable||As encoded in \"tx\" messages||The transaction which is in the block at index index.\n+|}\n+\n+====HeaderAndShortIDs====\n+A HeaderAndShortIDs structure is used to relay a block header, the short transactions IDs used for matching already-available transactions, and a select few transactions which we expect a peer may be missing.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|header||Block header||80 bytes||First 80 bytes of the block as defined by the encoding used by \"block\" messages||The header of the block being provided\n+|-\n+|nonce||uint64_t||8 bytes||Little Endian||A nonce for use in short transaction ID calculations\n+|-\n+|shortids_length||CompactSize||1 or 3 bytes||As used to encode array lengths elsewhere||||The number of short transaction IDs in shortids (ie block tx count - prefilledtxn_length)\n+|-\n+|shortids||List of 6-byte integers||6*shortids_length bytes||Little Endian||The short transaction IDs calculated from the transactions which were not provided explicitly in prefilledtxn\n+|-\n+|prefilledtxn_length||CompactSize||1 or 3 bytes||As used to encode array lengths elsewhere||||The number of prefilled transactions in prefilledtxn (ie block tx count - shortids_length)\n+|-\n+|prefilledtxn||List of PrefilledTransactions||variable size*prefilledtxn_length||As defined by PrefilledTransaction definition, above||Used to provide the coinbase transaction and a select few which we expect a peer may be missing\n+|}\n+\n+====BlockTransactionsRequest====\n+A BlockTransactionsRequest structure is used to list transaction indexes in a block being requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being requested are in\n+|-\n+|indexes_length||CompactSize||1 or 3 bytes||As used to encode array lengths elsewhere||||The number of transactions being requested\n+|-\n+|indexes||List of CompactSizes||1 or 3 bytes*indexes_length||Differentially encoded||The indexes of the transactions being requested in the block\n+|}\n+\n+====BlockTransactions====\n+A BlockTransactions structure is used to provide some of the transactions in a block, as requested.\n+\n+{|\n+|Field Name||Type||Size||Encoding||Purpose\n+|-\n+|blockhash||Binary blob||32 bytes||The output from a double-SHA256 of the block header, as used elsewhere||The blockhash of the block which the transactions being provided are in\n+|-\n+|transactions_length||CompactSize||1 or 3 bytes||As used to encode array lengths elsewhere||||The number of transactions provided\n+|-\n+|transactions||List of Transactions||variable||As encoded in \"tx\" messages||The transactions provided\n+|}\n+\n+====Short transaction IDs====\n+Short transaction IDs are used to represent a transaction without sending a full 256-bit hash. They are calculated by:\n+# single-SHA256 hashing the block header with the nonce appended (in little-endian)\n+# Running SipHash2-4 with the input being the transaction ID and the keys (k0/k1) set to the first two little-endian 64-bit integers from the above hash, respectively.",
      "path": "bip-0152.mediawiki",
      "position": null,
      "original_position": 99,
      "commit_id": "20a842244bbdf85c36b16544def261b9da0948da",
      "original_commit_id": "eefc2755b649d1e20b358f91cd6956177a766652",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: SipHash-2-4\n",
      "created_at": "2016-05-18T23:02:12Z",
      "updated_at": "2016-05-23T01:21:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/389#discussion_r63798198",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/63798198"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    }
  ]
}