{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1793",
    "id": 2396778495,
    "node_id": "PR_kwDOAN28mc6O2-__",
    "html_url": "https://github.com/bitcoin/bips/pull/1793",
    "diff_url": "https://github.com/bitcoin/bips/pull/1793.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1793.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1793/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
    "number": 1793,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "BIP draft: OP_CHECKCONTRACTVERIFY",
    "user": {
      "login": "bigspider",
      "id": 6681844,
      "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bigspider",
      "html_url": "https://github.com/bigspider",
      "followers_url": "https://api.github.com/users/bigspider/followers",
      "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
      "organizations_url": "https://api.github.com/users/bigspider/orgs",
      "repos_url": "https://api.github.com/users/bigspider/repos",
      "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/bigspider/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Hi all,\r\n\r\nThis is a draft for the formal specifications of the `OP_CHECKCONTRACTVERIFY` (`CCV`) opcode.\r\n\r\n`CCV` enables to build Script-based state machines that span across multiple transactions, by providing an ergonomic tool to commit to - and introspect - the Script and possibly some _data_ that is committed inside inputs or outputs.\r\n\r\nRelated to this PR:\r\n- [Implementation in bitcoin-core](https://github.com/bitcoin/bitcoin/pull/32080)\r\n- [Post on delving bitcoin](https://delvingbitcoin.org/t/op-checkcontractverify-and-its-amount-semantic/1527), focusing on the amount logic of the opcode.\r\n\r\nNot covered in this draft:\r\n- sigops budget (benchmarks needed)\r\n- activation logic\r\n- policy considerations (if any)\r\n\r\nI recommend delving bitcoin for high level discussions about alternative implementations, applications, etc.",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2025-03-17T05:58:38Z",
    "updated_at": "2025-03-25T23:52:32Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merged": false,
    "merge_commit_sha": "c377daffb16a0d168738d2446d77b77dd8f8fb1c",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "Merkleize:ccv",
      "ref": "ccv",
      "sha": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "user": {
        "login": "Merkleize",
        "id": 116372855,
        "node_id": "O_kgDOBu-1dw",
        "avatar_url": "https://avatars.githubusercontent.com/u/116372855?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Merkleize",
        "html_url": "https://github.com/Merkleize",
        "followers_url": "https://api.github.com/users/Merkleize/followers",
        "following_url": "https://api.github.com/users/Merkleize/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Merkleize/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Merkleize/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Merkleize/subscriptions",
        "organizations_url": "https://api.github.com/users/Merkleize/orgs",
        "repos_url": "https://api.github.com/users/Merkleize/repos",
        "events_url": "https://api.github.com/users/Merkleize/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Merkleize/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 902777682,
        "node_id": "R_kgDONc9LUg",
        "name": "bips",
        "full_name": "Merkleize/bips",
        "owner": {
          "login": "Merkleize",
          "id": 116372855,
          "node_id": "O_kgDOBu-1dw",
          "avatar_url": "https://avatars.githubusercontent.com/u/116372855?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/Merkleize",
          "html_url": "https://github.com/Merkleize",
          "followers_url": "https://api.github.com/users/Merkleize/followers",
          "following_url": "https://api.github.com/users/Merkleize/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/Merkleize/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/Merkleize/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/Merkleize/subscriptions",
          "organizations_url": "https://api.github.com/users/Merkleize/orgs",
          "repos_url": "https://api.github.com/users/Merkleize/repos",
          "events_url": "https://api.github.com/users/Merkleize/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/Merkleize/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/Merkleize/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/Merkleize/bips",
        "archive_url": "https://api.github.com/repos/Merkleize/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/Merkleize/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/Merkleize/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/Merkleize/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/Merkleize/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/Merkleize/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/Merkleize/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/Merkleize/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/Merkleize/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/Merkleize/bips/contributors",
        "deployments_url": "https://api.github.com/repos/Merkleize/bips/deployments",
        "downloads_url": "https://api.github.com/repos/Merkleize/bips/downloads",
        "events_url": "https://api.github.com/repos/Merkleize/bips/events",
        "forks_url": "https://api.github.com/repos/Merkleize/bips/forks",
        "git_commits_url": "https://api.github.com/repos/Merkleize/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/Merkleize/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/Merkleize/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/Merkleize/bips.git",
        "issue_comment_url": "https://api.github.com/repos/Merkleize/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/Merkleize/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/Merkleize/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/Merkleize/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/Merkleize/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/Merkleize/bips/languages",
        "merges_url": "https://api.github.com/repos/Merkleize/bips/merges",
        "milestones_url": "https://api.github.com/repos/Merkleize/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/Merkleize/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/Merkleize/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/Merkleize/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:Merkleize/bips.git",
        "stargazers_url": "https://api.github.com/repos/Merkleize/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/Merkleize/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/Merkleize/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/Merkleize/bips/subscription",
        "tags_url": "https://api.github.com/repos/Merkleize/bips/tags",
        "teams_url": "https://api.github.com/repos/Merkleize/bips/teams",
        "trees_url": "https://api.github.com/repos/Merkleize/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/Merkleize/bips.git",
        "hooks_url": "https://api.github.com/repos/Merkleize/bips/hooks",
        "svn_url": "https://github.com/Merkleize/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 15434,
        "default_branch": "ccv",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-22T18:18:29Z",
        "created_at": "2024-12-13T08:49:05Z",
        "updated_at": "2025-03-22T18:18:33Z",
        "allow_forking": true
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "00c13baff0dc4a3a250d9725129b0d2c8d0be6a9",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5549,
        "stargazers_count": 9811,
        "watchers_count": 9811,
        "size": 15459,
        "default_branch": "master",
        "open_issues_count": 31,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-24T18:55:28Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2025-03-25T20:28:04Z",
        "allow_forking": true
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 420,
    "deletions": 0,
    "changed_files": 5,
    "commits": 3,
    "review_comments": 25,
    "comments": 5
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDQyNDBmYThmYjFiYTgzNGVlYTFjNTJjMGQxYzBkOWFmMTQzODg3MmM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "tree": {
        "sha": "4e4b163d72d21e02f43ff953299e38f799430e3e",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/4e4b163d72d21e02f43ff953299e38f799430e3e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4e4b163d72d21e02f43ff953299e38f799430e3e\nparent 00c13baff0dc4a3a250d9725129b0d2c8d0be6a9\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1733697520 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742191365 +0100\n\nBIP draft for OP_CHECKCONTRACTVERIFY\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmfXuwUACgkQdAYP+Bsz\n5Pi6SAv8Da4XCyEPEfeaaGia2URq5O4YyOiqIOTmkZOxWmTEa0JBq2DSrHt5M07Q\nZVYThqsudWxpVv0RLkc/h97VeArzo5OkTGE1+2dDuvL/ZQ8QlnNE6OMnpVoveWmp\nXTLqko8NRPSWroq434aKo+vPfYnfDD1FV6lmbxtgY3+p5SPAqFGDER1mpTUNj5Yi\n1Jt15aOgXvAHiQTzXQn2A5BICccwqvUkWz+5y28DIToScSmOGGL04cI5df/PkmjC\n8dJoxWVweDRCfvByu1CNHEMiSS+oOGp8hmk9sY9PmDSQGwlOS4+XERKzpovXB49w\nkDAECLgisxC1ja7PaBtmXU6+3JD9jsjD0lGpQTBdTcZ9BUGJBwk9B6XqR69Fu7/J\neenSoUkAV/TmxnRtWx2ctrBaNQlkwaSTPcgyErMM5CLJOQUKk33nyRdO8THk3hB9\nG62G6AJbfkiBH4uM0koeDQcW1jRbG5EOSZ0AA7lIRYI20fqfTS3zEHWC/e38RSZY\nxAvEE1zZ\n=O1Hl\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/00c13baff0dc4a3a250d9725129b0d2c8d0be6a9",
          "sha": "00c13baff0dc4a3a250d9725129b0d2c8d0be6a9",
          "html_url": "https://github.com/bitcoin/bips/commit/00c13baff0dc4a3a250d9725129b0d2c8d0be6a9"
        }
      ],
      "message": "BIP draft for OP_CHECKCONTRACTVERIFY",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-17T06:02:45Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2024-12-08T22:38:40Z"
      },
      "sha": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16795030288,
      "node_id": "HRFPE_lADOAN28mc6uRj3YzwAAAAPpD9MQ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16795030288",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": "https://api.github.com/repos/Merkleize/bips/commits/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "created_at": "2025-03-17T06:02:49Z"
    },
    {
      "event": "labeled",
      "id": 16795496149,
      "node_id": "LE_lADOAN28mc6uRj3YzwAAAAPpFu7V",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16795496149",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-17T06:37:02Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "reviewed",
      "id": 2690410810,
      "node_id": "PRR_kwDOAN28mc6gXGk6",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2690410810",
      "submitted_at": "2025-03-17T13:02:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2693778798,
      "node_id": "PRR_kwDOAN28mc6gj81u",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "jirijakes",
        "id": 1381856,
        "node_id": "MDQ6VXNlcjEzODE4NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1381856?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jirijakes",
        "html_url": "https://github.com/jirijakes",
        "followers_url": "https://api.github.com/users/jirijakes/followers",
        "following_url": "https://api.github.com/users/jirijakes/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jirijakes/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jirijakes/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jirijakes/subscriptions",
        "organizations_url": "https://api.github.com/users/jirijakes/orgs",
        "repos_url": "https://api.github.com/users/jirijakes/repos",
        "events_url": "https://api.github.com/users/jirijakes/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jirijakes/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2693778798",
      "submitted_at": "2025-03-18T10:03:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695286980,
      "node_id": "PRR_kwDOAN28mc6gptDE",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695286980",
      "submitted_at": "2025-03-18T16:21:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "commented",
      "id": 2734121346,
      "node_id": "IC_kwDOAN28mc6i92GC",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2734121346",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T17:25:05Z",
      "updated_at": "2025-03-18T17:47:09Z",
      "author_association": "MEMBER",
      "body": "Some initial questions that come to mind:\r\n\r\n1. Do you really need inputs to check other inputs? What does that enable? Otherwise my sense is that evaluating each input independently of others makes life easier (but you'll find out when implementing).\r\n\r\n2. Can you make it so the output ordering doesn't matter?\r\n\r\n3. You bring up \"vector commitments\" with no further comment, but it would be good to at least briefly explain what they're good for.\r\n\r\nAnd see inline.\r\n\r\n---\r\n\r\nupdate:\r\n1) maybe it's not too bad, because you're only checking the `scriptPubKey` other inputs are spending",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2734121346",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "reviewed",
      "id": 2695539462,
      "node_id": "PRR_kwDOAN28mc6gqqsG",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695539462",
      "submitted_at": "2025-03-18T17:25:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695547018,
      "node_id": "PRR_kwDOAN28mc6gqsiK",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695547018",
      "submitted_at": "2025-03-18T17:28:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695549014,
      "node_id": "PRR_kwDOAN28mc6gqtBW",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695549014",
      "submitted_at": "2025-03-18T17:28:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695556405,
      "node_id": "PRR_kwDOAN28mc6gqu01",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695556405",
      "submitted_at": "2025-03-18T17:30:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695572302,
      "node_id": "PRR_kwDOAN28mc6gqytO",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695572302",
      "submitted_at": "2025-03-18T17:34:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2695587204,
      "node_id": "PRR_kwDOAN28mc6gq2WE",
      "url": null,
      "actor": null,
      "commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2695587204",
      "submitted_at": "2025-03-18T17:38:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGIyMTk5OTUwNTBiYTczNDQ2ZDNhZWVmMzFkYzMwNGUxNWM5YTZiNGU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b219995050ba73446d3aeef31dc304e15c9a6b4e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/b219995050ba73446d3aeef31dc304e15c9a6b4e",
      "tree": {
        "sha": "938b30d8b98d31aeeebfc7a9645375418bc03296",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/938b30d8b98d31aeeebfc7a9645375418bc03296"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 938b30d8b98d31aeeebfc7a9645375418bc03296\nparent 4240fa8fb1ba834eea1c52c0d1c0d9af1438872c\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742666885 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742666885 +0100\n\nAddress some comments from review\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmfe/IUACgkQdAYP+Bsz\n5PilSwv9HnwQJv0o7a7D8mYcc/bDrNDhMrIuUOQE65wBNzvFHxuKrUT3KSNsuh5S\nT1QixDTBgffNqBb96+GNjJEPmkaZm9M4k16KpR2tkN31A0mvxVt1Q4TQ2A7IoDud\nXEEuaKI5G7meeqtwF7+sB1zaKzWBBwwuPhsU4221WimLKUejpmc/8wFBSfb8/1Gq\ncWMtBrn7wPSoJTdAt51Jzm0/ogCmG6CTlR6M2EPvdub7qSbetSoAjv1oqka1C1k9\nF/+R1On2bQl/4YJ1MbxO7AgOysfa7mufhYXlBk93dt9go8LRtSl0tIxIQrfUO37B\n9tl8jQX5xjHg1lLjBCxfr/GyAwmIcCwWBbpeFUVYrlIdqHXMVnVUy5Qr0w0v7tzJ\n3P5rRVPSVLQ/OXkjEfklgvqXv1gVwdN7Qqq6IkWsDah481ufL6+Cn1M78DLIinv9\ncaX+FCX7AFKfRnRXql9gK71U9gJ48OGwVSqbqg/EX5upQxPU4TbTif2D+6WRJ08i\nxehZV5bn\n=xQWH\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
          "sha": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
          "html_url": "https://github.com/bitcoin/bips/commit/4240fa8fb1ba834eea1c52c0d1c0d9af1438872c"
        }
      ],
      "message": "Address some comments from review",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-22T18:08:05Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-22T18:08:05Z"
      },
      "sha": "b219995050ba73446d3aeef31dc304e15c9a6b4e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGFhMjkxYzIzZmJkM2E0NmY4NWI5NGIwZmI4NmVkNDc1ZjBkYWY3NDY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "tree": {
        "sha": "4f1dfd2efba6b9afc40bbd5aeaa243d3269db47a",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/4f1dfd2efba6b9afc40bbd5aeaa243d3269db47a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4f1dfd2efba6b9afc40bbd5aeaa243d3269db47a\nparent b219995050ba73446d3aeef31dc304e15c9a6b4e\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742667502 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1742667502 +0100\n\nFix formatting inside the blockquote\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmfe/u4ACgkQdAYP+Bsz\n5Pjragv+MoGMUIOpX8wd/e0H2IacMbvym7an6kqu4fbjSxcfKc0VcvvF4xfvPYOB\nwnFtB7d/LxlwZeA/F8y856jISo85hP4Qd/YpKsoUxukn4+eBHNlhoGd9+RCbvVHo\nXARxgMHjX/4+X1ZtKK6kif1UKdO5Ah/FkzT5kiqvFVFmnxoqXZLPYGrd9XywHtUw\nRoAgyNM8D2cgGaXjmW7SPR4N5N6Y+gYCJ6O5FyiOiR0YjuOofyty7pqMmOPAxzqn\nXwfZZqMIR17usN/S5teCX9QK6VN/EmQ7/X6ahlS9/TtACx3kbR3y6r6xg00G2ken\nTNzXKUzvK3FCWVUvf7bj4FJSvSVGuaOyTcd4q5qzxzyxqyK/adexJZRBVrJsGyMb\nUiD9BZJ9rtXFNafA1aW6axpAx+0HrA028KB3bv2DAF4qPzZcLHwkS9OtOkkzK5pX\nKCOyHPSbZye+X/gJQeM5jVVlHMFZWDgVHVgV3kn2h8fPbSXxWQV81GwycxCWFSSr\n9DUfCbmq\n=NzUa\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b219995050ba73446d3aeef31dc304e15c9a6b4e",
          "sha": "b219995050ba73446d3aeef31dc304e15c9a6b4e",
          "html_url": "https://github.com/bitcoin/bips/commit/b219995050ba73446d3aeef31dc304e15c9a6b4e"
        }
      ],
      "message": "Fix formatting inside the blockquote",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-22T18:18:22Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2025-03-22T18:18:22Z"
      },
      "sha": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746"
    },
    {
      "event": "commented",
      "id": 2745410697,
      "node_id": "IC_kwDOAN28mc6jo6SJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2745410697",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-22T18:57:44Z",
      "updated_at": "2025-03-22T18:57:44Z",
      "author_association": "CONTRIBUTOR",
      "body": "> 1. Do you really need inputs to check other inputs? What does that enable? Otherwise my sense is that evaluating each input independently of others makes life easier (but you'll find out when implementing).\r\n\r\nI don't think it would make it easier; in fact, apart from the amount semantic (amounts are not checked when you CCV-check and input), the opcode's behavior is currently very symmetric. So in a way, I think the current formulation is simpler by not restricting to just the current input (while staying more general).\r\n\r\nIn everything I worked on so far (even in combinations with other opcodes, e.g. see [pymatt](https://github.com/Merkleize/pymatt)), checking just the current input is indeed sufficient. However, I think it's likely that it would be useful in some more advanced constructions. For example, you could create a separate _sentinel_ UTXO, and have some spending condition (possibly for many UTXOs at the same time) be only available if the sentinel UTXO is present in the transaction. Once the sentinel is spent, those spending conditions become unavailable for all the remaining. That seems similar in spirit to the _connector outputs_  used in Ark, but without presigned transactions, so I suspect it's useful.\r\n\r\n> 2. Can you make it so the output ordering doesn't matter?\r\n\r\nYou can leave flexibility as to where outputs must be by either\r\n- using -1 for the output index (meaning, the corresponding output must be in the same position as the input index); this would for example allow batching multiple 1-input-1-output CCV-encumbered spends (where each input must \"produce\" its own output, without aggregation) in the same transaction\r\n- passing the `<index>` parameter in the witness of the transaction. E.g. in the [vault example](https://github.com/bitcoin/bitcoin/pull/32080/files#diff-e796b699bc9cf1f5b7f2eb10c2d88f5c47b7701d5835ca7734fbfafd7d72e87c), the _revault index_ and the _trigger index_ of the `trigger_and_revault` clause are arbitrary in this way.\r\n\r\n> 3. You bring up \"vector commitments\" with no further comment, but it would be good to at least briefly explain what they're good for.\r\n\r\nI'll add a footnote, thanks!\r\n",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2745410697",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "reviewed",
      "id": 2711501789,
      "node_id": "PRR_kwDOAN28mc6hnjvd",
      "url": null,
      "actor": null,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2711501789",
      "submitted_at": "2025-03-24T19:51:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "reviewed",
      "id": 2711548786,
      "node_id": "PRR_kwDOAN28mc6hnvNy",
      "url": null,
      "actor": null,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#pullrequestreview-2711548786",
      "submitted_at": "2025-03-24T19:59:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
    },
    {
      "event": "commented",
      "id": 2749295131,
      "node_id": "IC_kwDOAN28mc6j3uob",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2749295131",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-24T20:17:40Z",
      "updated_at": "2025-03-24T20:19:32Z",
      "author_association": "MEMBER",
      "body": "Do you have any thoughts on what this could look like in terms of descriptors? Either in the general case of anything that can be expressed in miniscript, or more narrowly for something like a vault?\r\n\r\nE.g. fresh vault deposit addresses could be generated from something like `tr(cold,{trigger_leaf})`, where `trigger_leaf` could be something like `ccv(-1,{withdraw_leaf,recover_leaf},0,...)`, and `recover_leaf` is `tr(cold)`, etc.\r\n\r\nSince programs can take arbitrary data, e.g. a withdrawal address for a vault, I could imagine that when a wallet signs (or detects an unauthorized) a trigger transaction it generates a descriptor for that, so that it knows how to spend it (and when).\r\n\r\nFor the first part the wallet software doesn't even need to know what a vault is. For the second part it probably does need to \"understand\" it in order to know what descriptors to generate, and in order to prompt the user for the right action.\r\n\r\nBut how generalisable is that?",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2749295131",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "commented",
      "id": 2751483735,
      "node_id": "IC_kwDOAN28mc6kAE9X",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2751483735",
      "actor": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T14:37:02Z",
      "updated_at": "2025-03-25T14:37:02Z",
      "author_association": "MEMBER",
      "body": ">> Do you really need inputs to check other inputs? What does that enable?\r\n\r\n> However, I think it's likely that it would be useful in some more advanced constructions. For example, you could create a separate sentinel UTXO,\r\n\r\nJust saw the mailinglist thread about this from 2023: https://gnusha.org/pi/bitcoindev/CALZpt+F251k7gSpogwFYHxFtGxc_tZjB4UU4SVEr=WvrsyMVMQ@mail.gmail.com/\r\n\r\nThe BIP should probably address the pros and cons of \"cross-input inspection\".",
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2751483735",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "commented",
      "id": 2752789566,
      "node_id": "IC_kwDOAN28mc6kFDw-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/2752789566",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T23:52:31Z",
      "updated_at": "2025-03-25T23:52:31Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Do you have any thoughts on what this could look like in terms of descriptors? Either in the general case of anything that can be expressed in miniscript, or more narrowly for something like a vault?\r\n\r\n@sanket1729 has given several great talks on generalizing miniscript for covenant use cases, you can look for those if you're interested.\r\n\r\nMy general take is that descriptors are the wrong tool for this purpose: a spend from UTXO X to UTXO Y where f(Y) = X needs to somehow encode the relation between X and Y as a _predicate_. While you could do that (every program is a predicate, and every program expressible in Script is a predicate that can be expressed in a tree structure like miniscript...) it quickly becomes unmanageable.\r\n\r\nFor CCV, what works well (kinda by design) is to think in terms of _states_ and _state transitions_. You can check [these docs](https://github.com/Merkleize/pymatt/blob/master/docs/contracts.md) and the code examples in the [pymatt](https://github.com/Merkleize/pymatt) repo if you're interested in more details in how I'm framing it - the PR in bitcoin-core strips most of those useful abstractions for the sake of conciseness, but that's certainly not how one would write those contracts in practice.\r\n\r\nThe framework has some nice properties: once you define the contracts, all you need to know is the contract definition, and the initial parameters. Everything else can be deterministically derived from that, and the blockchain. You can scan for the initial UTXOs matching that contract, and given a transaction spending those UTXOs, you can deterministically deduce what are the next states, parameters (and data, if any) of the new UTXOs that are produced. That's even when someone else in the contract made transactions, as it's easy to 'decode' the witness to understand what _clause_ (tapleaf) was used, and with what arguments. \r\n\r\n> Just saw the mailinglist thread about this from 2023: https://gnusha.org/pi/bitcoindev/CALZpt+F251k7gSpogwFYHxFtGxc_tZjB4UU4SVEr=WvrsyMVMQ@mail.gmail.com/\r\n> \r\n> The BIP should probably address the pros and cons of \"cross-input inspection\".\r\n\r\nI personally think speculation on all the possible ways people might use (and abuse) the opcode is out of scope, and it quickly gets unmanageable - because there is an infinite number of ways of (per-)using the opcode. For example, both [`OP_CAT`](https://github.com/bitcoin/bips/blob/master/bip-0347.mediawiki) and [`OP_TXHASH`](https://github.com/bitcoin/bips/pull/1500) both enable fine-grained introspection of other inputs, and would therefore raise the same concern - if one thinks that is a valid concern; yet the BIPs don't discuss this.\r\n\r\nIMHO that kind of discussion would be more fitting for a BIP describing a proposal to activate a certain package of opcodes as a soft-fork. OP_CCV is not meant to be activated as a stand-alone opcode (that would be kinda silly for a number of reasons). Such a BIP could in fact focus on the _capabilities_, ignoring the exact details of the opcodes (that are not interesting in that context).",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1793#issuecomment-2752789566",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1793"
    },
    {
      "event": "mentioned",
      "id": 16983356260,
      "node_id": "MEE_lADOAN28mc6uRj3YzwAAAAP0SXNk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16983356260",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T23:52:32Z"
    },
    {
      "event": "subscribed",
      "id": 16983356271,
      "node_id": "SE_lADOAN28mc6uRj3YzwAAAAP0SXNv",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/16983356271",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-25T23:52:32Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1998687605",
      "pull_request_review_id": 2690410810,
      "id": 1998687605,
      "node_id": "PRRC_kwDOAN28mc53IY11",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    return success()  # undefined flags are OP_SUCCESS\n+\n+  if index == -1:\n+    index = this_input_index\n+\n+  if flags == CCV_FLAG_CHECK_INPUT:\n+    if index < 0 or index >= n_inputs:\n+      return fail()  # input index out of bounds\n+\n+    target_script = inputs[index].scriptPubKey\n+  else:\n+    if index < 0 or index >= n_outputs:\n+      return fail()  # output index out of bounds\n+\n+    target_script = outputs[index].scriptPubKey\n+\n+  if taptree == <-1>:\n+    taptree = this_input_taptree\n+\n+  if pk == <0>:\n+    naked_key = BIP341_NUMS_KEY\n+  elif pk == <-1>:\n+    naked_key = this_input_internal_key\n+  elif len(pk) == 32:\n+    naked_key = pk\n+  else:\n+    return fail()\n+\n+  # Verify the target contract data and program\n+  _, internal_key = tweak_embed_data(naked_key, data)\n+\n+  if len(taptree) != 0:\n+    if len(taptree) != 32:\n+      return fail()\n+\n+    _, final_key = taproot_tweak_pubkey(internal_key, taptree)\n+  else:\n+    final_key = internal_key\n+\n+  if target_script != P2TR(final_key):\n+    return fail()\n+\n+  # Amount checks\n+\n+  if flags == 0:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 252,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n  if flags == CCV_FLAG_CHECK_OUTPUT:\r\n```",
      "created_at": "2025-03-17T13:02:45Z",
      "updated_at": "2025-03-17T13:02:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r1998687605",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1998687605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2000644722",
      "pull_request_review_id": 2693778798,
      "id": 2000644722,
      "node_id": "PRRC_kwDOAN28mc53P2py",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 122,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "jirijakes",
        "id": 1381856,
        "node_id": "MDQ6VXNlcjEzODE4NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1381856?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jirijakes",
        "html_url": "https://github.com/jirijakes",
        "followers_url": "https://api.github.com/users/jirijakes/followers",
        "following_url": "https://api.github.com/users/jirijakes/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jirijakes/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jirijakes/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jirijakes/subscriptions",
        "organizations_url": "https://api.github.com/users/jirijakes/orgs",
        "repos_url": "https://api.github.com/users/jirijakes/repos",
        "events_url": "https://api.github.com/users/jirijakes/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jirijakes/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This [renders](https://github.com/Merkleize/bips/blob/ccv/bip-ccv.mediawiki#specification) as a code block without wrapping ⇒ have to scroll to the right to read it. Plain text (or blockquote, if you want to emphasize) might be better.",
      "created_at": "2025-03-18T10:03:16Z",
      "updated_at": "2025-03-18T10:03:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2000644722",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2000644722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001438768",
      "pull_request_review_id": 2695265611,
      "id": 2001438768,
      "node_id": "PRRC_kwDOAN28mc53S4gw",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 122,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2000644722,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The phrasing \"input/output\" followed by \"is a P2TR output\" is also confusing. Maybe just have a separate sentence to explain the input handling. And in particular whether inputs can refer to other inputs.",
      "created_at": "2025-03-18T16:17:00Z",
      "updated_at": "2025-03-18T16:19:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001438768",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001438768"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001452568",
      "pull_request_review_id": 2695286980,
      "id": 2001452568,
      "node_id": "PRRC_kwDOAN28mc53S74Y",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 146,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I assume you mean that first flags are checked. If they're different the transaction is valid. And only after that the other params are checked? In other words, params can be changed / added / removed in later soft forks by introducing a new flag?",
      "created_at": "2025-03-18T16:21:45Z",
      "updated_at": "2025-03-18T16:21:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001452568",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001452568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001583011",
      "pull_request_review_id": 2695539462,
      "id": 2001583011,
      "node_id": "PRRC_kwDOAN28mc53Tbuj",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.",
      "path": "bip-ccv.mediawiki",
      "position": 97,
      "original_position": 95,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It would be good to elaborate with an example.",
      "created_at": "2025-03-18T17:25:55Z",
      "updated_at": "2025-03-18T17:25:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001583011",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001583011"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 97,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001589006",
      "pull_request_review_id": 2695547018,
      "id": 2001589006,
      "node_id": "PRRC_kwDOAN28mc53TdMO",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.",
      "path": "bip-ccv.mediawiki",
      "position": 33,
      "original_position": 33,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Having a vault example with OP_CCV would be useful, doesn't have to be perfectly identical to `OP_VAULT`.",
      "created_at": "2025-03-18T17:28:16Z",
      "updated_at": "2025-03-18T17:28:16Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001589006",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001589006"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001590488",
      "pull_request_review_id": 2695549014,
      "id": 2001590488,
      "node_id": "PRRC_kwDOAN28mc53TdjY",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.",
      "path": "bip-ccv.mediawiki",
      "position": 34,
      "original_position": 34,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Ditto: having an example that (roughly) replicates `OP_CTV` would be useful",
      "created_at": "2025-03-18T17:28:52Z",
      "updated_at": "2025-03-18T17:28:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001590488",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001590488"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 34,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001595938",
      "pull_request_review_id": 2695556405,
      "id": 2001595938,
      "node_id": "PRRC_kwDOAN28mc53Te4i",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.",
      "path": "bip-ccv.mediawiki",
      "position": 37,
      "original_position": 37,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Out of scope for a BIP, but maybe someone who works on BitVM can demonstrate the equivalent with `OP_CCV`? Presumably it doesn't completely replace it, but makes certain aspects more compact. Do they need additional op codes? Etc.",
      "created_at": "2025-03-18T17:30:53Z",
      "updated_at": "2025-03-18T17:30:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001595938",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001595938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 37,
      "original_line": 37,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001605770",
      "pull_request_review_id": 2695572302,
      "id": 2001605770,
      "node_id": "PRRC_kwDOAN28mc53ThSK",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm confused by what you mean with \"data\", as opposed to a \"program\". Does this \"party\" have to know the pre-image or just the hash? And why is that helpful. Hopefully the future examples can illustrate this.\r\n",
      "created_at": "2025-03-18T17:34:41Z",
      "updated_at": "2025-03-18T17:35:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001605770",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001605770"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001612619",
      "pull_request_review_id": 2695587204,
      "id": 2001612619,
      "node_id": "PRRC_kwDOAN28mc53Ti9L",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    return success()  # undefined flags are OP_SUCCESS\n+\n+  if index == -1:\n+    index = this_input_index\n+\n+  if flags == CCV_FLAG_CHECK_INPUT:\n+    if index < 0 or index >= n_inputs:\n+      return fail()  # input index out of bounds\n+\n+    target_script = inputs[index].scriptPubKey\n+  else:\n+    if index < 0 or index >= n_outputs:\n+      return fail()  # output index out of bounds\n+\n+    target_script = outputs[index].scriptPubKey\n+\n+  if taptree == <-1>:\n+    taptree = this_input_taptree\n+\n+  if pk == <0>:\n+    naked_key = BIP341_NUMS_KEY\n+  elif pk == <-1>:\n+    naked_key = this_input_internal_key\n+  elif len(pk) == 32:\n+    naked_key = pk\n+  else:\n+    return fail()\n+\n+  # Verify the target contract data and program\n+  _, internal_key = tweak_embed_data(naked_key, data)\n+\n+  if len(taptree) != 0:\n+    if len(taptree) != 32:\n+      return fail()\n+\n+    _, final_key = taproot_tweak_pubkey(internal_key, taptree)\n+  else:\n+    final_key = internal_key\n+\n+  if target_script != P2TR(final_key):\n+    return fail()\n+\n+  # Amount checks\n+\n+  if flags == 0:\n+    # default amount semantic\n+    if output_checked_deduct[index]:\n+      return fail()\n+\n+    output_min_amount[index] += residual_input_amount\n+    residual_input_amount = 0\n+\n+    if outputs[index].amount < output_min_amount[index]:\n+      return fail()\n+\n+    output_checked_default[index] = True\n+  elif flags == CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    # 'deduct' amount semantic\n+    if residual_input_amount < outputs[index].amount:\n+      return fail()\n+\n+    if output_checked_default[index] or output_checked_deduct[index]:\n+      return fail()\n+\n+    residual_input_amount = residual_input_amount - outputs[index].amount\n+    output_checked_deduct[index] = True\n+\n+  stack.pop(5)  # drop all 5 stack elements\n+</source>\n+\n+==== sigops budget ====\n+\n+TODO\n+\n+== Policy changes ==\n+\n+TODO\n+\n+== Implementation ==\n+\n+A reference implementation is provided here:\n+\n+TODO\n+\n+== Examples ==\n+\n+This section documents some common Script fragments that use <code>OP_CHECKCONTRACTVERIFY</code> for various common choices of the parameters. Depending on the use case, some of the parameters might be passed via the witness stack.\n+In these examples, <code><></code> (empty buffer) and <code>0</code> both refer to an empty stack element.",
      "path": "bip-ccv.mediawiki",
      "position": 299,
      "original_position": 295,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Can you frame these examples in the context of an actual application?",
      "created_at": "2025-03-18T17:38:23Z",
      "updated_at": "2025-03-18T17:38:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001612619",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001612619"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 299,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001617429",
      "pull_request_review_id": 2695595829,
      "id": 2001617429,
      "node_id": "PRRC_kwDOAN28mc53TkIV",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001605770,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The implementation uses the term \"double tweak\". Perhaps that's a helpful term to explain the concept better? \r\n\r\nAnd IIUC maybe use the term \"single tweak\" instead of \"naked\".",
      "created_at": "2025-03-18T17:40:42Z",
      "updated_at": "2025-03-18T17:42:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001617429",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001617429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001660190",
      "pull_request_review_id": 2695686169,
      "id": 2001660190,
      "node_id": "PRRC_kwDOAN28mc53Tuke",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.",
      "path": "bip-ccv.mediawiki",
      "position": 33,
      "original_position": 33,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001589006,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Just saw this: https://github.com/Merkleize/bitcoin/blob/ccv-core/test/functional/feature_checkcontractverify_vaults.py",
      "created_at": "2025-03-18T17:58:31Z",
      "updated_at": "2025-03-18T18:00:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2001660190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2001660190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 33,
      "original_line": 33,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008830091",
      "pull_request_review_id": 2708111516,
      "id": 2008830091,
      "node_id": "PRRC_kwDOAN28mc53vFCL",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:\n+    return success()  # undefined flags are OP_SUCCESS\n+\n+  if index == -1:\n+    index = this_input_index\n+\n+  if flags == CCV_FLAG_CHECK_INPUT:\n+    if index < 0 or index >= n_inputs:\n+      return fail()  # input index out of bounds\n+\n+    target_script = inputs[index].scriptPubKey\n+  else:\n+    if index < 0 or index >= n_outputs:\n+      return fail()  # output index out of bounds\n+\n+    target_script = outputs[index].scriptPubKey\n+\n+  if taptree == <-1>:\n+    taptree = this_input_taptree\n+\n+  if pk == <0>:\n+    naked_key = BIP341_NUMS_KEY\n+  elif pk == <-1>:\n+    naked_key = this_input_internal_key\n+  elif len(pk) == 32:\n+    naked_key = pk\n+  else:\n+    return fail()\n+\n+  # Verify the target contract data and program\n+  _, internal_key = tweak_embed_data(naked_key, data)\n+\n+  if len(taptree) != 0:\n+    if len(taptree) != 32:\n+      return fail()\n+\n+    _, final_key = taproot_tweak_pubkey(internal_key, taptree)\n+  else:\n+    final_key = internal_key\n+\n+  if target_script != P2TR(final_key):\n+    return fail()\n+\n+  # Amount checks\n+\n+  if flags == 0:",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 252,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 1998687605,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done in b2199950, thanks!",
      "created_at": "2025-03-22T18:09:17Z",
      "updated_at": "2025-03-22T18:09:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2008830091",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008830091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008832251",
      "pull_request_review_id": 2708113809,
      "id": 2008832251,
      "node_id": "PRRC_kwDOAN28mc53vFj7",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 122,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2000644722,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "b2199950\r\nI added the blockquote, and rephrased a bit - saying P2TR UTXO instead of the ambiguous 'output'. Does this make it clearer?",
      "created_at": "2025-03-22T18:22:19Z",
      "updated_at": "2025-03-22T18:22:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2008832251",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008832251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008832670",
      "pull_request_review_id": 2708114205,
      "id": 2008832670,
      "node_id": "PRRC_kwDOAN28mc53vFqe",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+  Verify that the input/output with the given <code>index</code> is a P2TR output where the public key is obtained from <code><pk></code>, tweaked with the hash of <data> (if non-empty), then taptweaked with <code><taptree</code> (if present).\n+\n+If the <code>data</code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the parameters (except the <code><flags></code> as specified above) is invalid, and makes the opcode fail validation immediately.",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 146,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001452568,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, undefined flags (which is more an extension of the opcode) are left for possible future extensions, while that seems dangerous/footgun-prone for the other parameters (which could be passed via the witness)\r\nIn b2199950 I tried to make it more explicit by explicitly listing all the parameters.",
      "created_at": "2025-03-22T18:24:53Z",
      "updated_at": "2025-03-22T18:24:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2008832670",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008832670"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008833828",
      "pull_request_review_id": 2708115276,
      "id": 2008833828,
      "node_id": "PRRC_kwDOAN28mc53vF8k",
      "diff_hunk": "@@ -0,0 +1,416 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, with an ad-hoc opcode called <code>OP_CHECKCONTRACTVERIFY</code>, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data;",
      "path": "bip-ccv.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "4240fa8fb1ba834eea1c52c0d1c0d9af1438872c",
      "in_reply_to_id": 2001605770,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I'm confused by what you mean with \"data\", as opposed to a \"program\". Does this \"party\" have to know the pre-image or just the hash? And why is that helpful. Hopefully the future examples can illustrate this.\r\n\r\nIn b2199950 I added an additional introductory sentence in the paragraph, and also a footnote to explain how this could be used (which is anyway identical to taproot's keypath vs script spending, anyway; the point I'm trying to make is that this feature is not lost when using Scripts with CCV, despite _tampering_ with the internal key).\r\n\r\n\r\n> And IIUC maybe use the term \"single tweak\" instead of \"naked\".\r\n\r\nWhat I call the 'naked key' is the key before any tweak. So if you have no embedded data:\r\n```\r\n      naked_key ==(taptweak)==> taproot output key         (where naked_key == internal key)\r\n```\r\nInstead, if you have embedded data:\r\n```\r\n      naked_key ==(data tweak)==> internal_key ==(taptweak)==> taproot output key\r\n```\r\n",
      "created_at": "2025-03-22T18:32:25Z",
      "updated_at": "2025-03-22T18:32:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2008833828",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2008833828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010815193",
      "pull_request_review_id": 2711501789,
      "id": 2010815193,
      "node_id": "PRRC_kwDOAN28mc532prZ",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.",
      "path": "bip-ccv.mediawiki",
      "position": 137,
      "original_position": 137,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Most flags in Bitcoin Core are usigned integers, which seems easier to read. But I guess this is because the script interpreter uses (variable size) signed integers? On the bright side, it means you can expand the number of bit flags easily...\r\n\r\nWhen this flag is absent, I assume you don't check the input?",
      "created_at": "2025-03-24T19:36:39Z",
      "updated_at": "2025-03-24T19:51:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010815193",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010815193"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 137,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010818123",
      "pull_request_review_id": 2711501789,
      "id": 2010818123,
      "node_id": "PRRC_kwDOAN28mc532qZL",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.",
      "path": "bip-ccv.mediawiki",
      "position": 138,
      "original_position": 138,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When this flag is absent, you don't check the output?\r\n\r\nAnd `CCV_FLAG_CHECK_INPUT` can be used in any combination with `CCV_FLAG_CHECK_INPUT`, including not checking either?",
      "created_at": "2025-03-24T19:39:07Z",
      "updated_at": "2025-03-24T19:51:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010818123",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010818123"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 138,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010821110",
      "pull_request_review_id": 2711501789,
      "id": 2010821110,
      "node_id": "PRRC_kwDOAN28mc532rH2",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.",
      "path": "bip-ccv.mediawiki",
      "position": 140,
      "original_position": 140,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "For these two I assume `CCV_FLAG_CHECK_OUTPUT` must be set? And they can't be both set.",
      "created_at": "2025-03-24T19:41:19Z",
      "updated_at": "2025-03-24T19:51:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010821110",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010821110"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 140,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010828211",
      "pull_request_review_id": 2711501789,
      "id": 2010828211,
      "node_id": "PRRC_kwDOAN28mc532s2z",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.",
      "path": "bip-ccv.mediawiki",
      "position": 145,
      "original_position": 145,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Have you considered using flags for these special cases and then having fewer stack elements? That seems both more space efficient and probably makes scripts easier to read.",
      "created_at": "2025-03-24T19:47:47Z",
      "updated_at": "2025-03-24T19:51:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010828211",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010828211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010845676",
      "pull_request_review_id": 2711548786,
      "id": 2010845676,
      "node_id": "PRRC_kwDOAN28mc532xHs",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters is invalid, and makes the opcode immediately fail validation.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:",
      "path": "bip-ccv.mediawiki",
      "position": 211,
      "original_position": 211,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": null,
      "user": {
        "login": "Sjors",
        "id": 10217,
        "node_id": "MDQ6VXNlcjEwMjE3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10217?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sjors",
        "html_url": "https://github.com/Sjors",
        "followers_url": "https://api.github.com/users/Sjors/followers",
        "following_url": "https://api.github.com/users/Sjors/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sjors/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sjors/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sjors/subscriptions",
        "organizations_url": "https://api.github.com/users/Sjors/orgs",
        "repos_url": "https://api.github.com/users/Sjors/repos",
        "events_url": "https://api.github.com/users/Sjors/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sjors/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I assume you mean to check that no unknown flags are in use? This seems wrong though, because `CCV_FLAG_DEDUCT_OUTPUT_AMOUNT | CCV_FLAG_IGNORE_OUTPUT_AMOUNT > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT`\r\n\r\nProbably more clear to have something like `ALL_FLAGS = ... | CCV_FLAG_DEDUCT_OUTPUT_AMOUNT | CCV_FLAG_IGNORE_OUTPUT_AMOUNT | ...` and check `flags && !ALL_FLAGS == 0`",
      "created_at": "2025-03-24T19:59:31Z",
      "updated_at": "2025-03-24T19:59:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2010845676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2010845676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013047590",
      "pull_request_review_id": 2715387171,
      "id": 2013047590,
      "node_id": "PRRC_kwDOAN28mc53_Ksm",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.",
      "path": "bip-ccv.mediawiki",
      "position": 137,
      "original_position": 137,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010815193,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The flag can't be 'absent', as it's the value of the `flags` parameter. Note that it's not a bitmap: -1 means \"check input\", 0, 1 and 2 are the three defferent _amount_ behaviors for checking the output (default, deduct and ignore).\r\n\r\nPerhaps the confusion comes from calling it `flags` - let me know if you have suggestions for a better name.",
      "created_at": "2025-03-25T23:01:39Z",
      "updated_at": "2025-03-25T23:01:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013047590",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013047590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 137,
      "original_line": 137,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013048066",
      "pull_request_review_id": 2715387866,
      "id": 2013048066,
      "node_id": "PRRC_kwDOAN28mc53_K0C",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.",
      "path": "bip-ccv.mediawiki",
      "position": 138,
      "original_position": 138,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010818123,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As per [this comment](https://github.com/bitcoin/bips/pull/1793#discussion_r2013047590), the defined flags are all mutually exclusive.",
      "created_at": "2025-03-25T23:02:17Z",
      "updated_at": "2025-03-25T23:02:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013048066",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013048066"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 138,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013049325",
      "pull_request_review_id": 2715389809,
      "id": 2013049325,
      "node_id": "PRRC_kwDOAN28mc53_LHt",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.\n+* If the <code><pk></code> is 0, it is replaced with it is replaced with the NUMS x-only pubkey <code>0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in BIP-0340. If the <code><pk></code> is -1, it is replaced with the taproot internal key of the current input.\n+* If the <code><index></code> is -1, it is replaced with the index of the current input.\n+* If the <code><data></code> is the empty buffer, then there is no data tweak for the input/output being checked.\n+\n+Any other value of the <code><taptree></code>, <code><pk></code>, <code><index></code> or <code><data></code> parameters is invalid, and makes the opcode immediately fail validation.\n+\n+=== Script support for <code>OP_CHECKCONTRACTVERIFY</code> ===\n+\n+The specification is divided in three parts:\n+* the transaction-wide initialization;\n+* the input initialization;\n+* the opcode evaluation.\n+\n+The following helper function is a version of <code>taproot_tweak_pubkey</code>, except that a raw 32-byte data is used as the tweak.\n+\n+<source lang=\"python\">\n+def tweak_embed_data(pubkey, data):\n+    assert len(pubkey) == 32\n+\n+    data_tweak = sha256(pubkey + data)\n+\n+    t = int_from_bytes(data_tweak)\n+    if t >= SECP256K1_ORDER:\n+        raise ValueError\n+    P = lift_x(int_from_bytes(pubkey))\n+    if P is None:\n+        raise ValueError\n+    Q = point_add(P, point_mul(G, t))\n+    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n+</source>\n+\n+The <code>taproot_tweak_pubkey</code> from [[bip-0341.mediawiki|BIP341]] is also used as a helper function.\n+\n+The following notations are used in the pseudocode below:\n+* <code>n_inputs</code> and <code>n_outputs</code> are the number of inputs and outputs of the transaction, respectively;\n+* <code>inputs[i]</code> is the i-th input of the transaction;\n+* <code>outputs[i]</code> is the i-th output of the transaction;\n+* <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input, respectively.\n+* <code>P2TR(key)</code> computes the scriptPubKey of the P2TR output with the given key as the taproot output key.\n+\n+==== Transaction-wide initialization ====\n+\n+This is executed once for the entire transaction, before any of the transaction input's Scripts are evaluated. It initializes three arrays that are used to keep track of the amount information of the output.\n+\n+<source lang=\"python\">\n+  output_min_amount = [0] * n_outputs\n+  output_checked_default = [False] * n_outputs\n+  output_checked_deduct = [False] * n_outputs\n+</source>\n+\n+==== Input initialization ====\n+\n+This is executed at the beginning of the evaluation of each input's Script. It initializes the residual amount to equal the full amount of the current input.\n+\n+<source lang=\"python\">\n+  residual_input_amount = input[this_input_index].amount\n+</source>\n+\n+==== <code>OP_CHECKCONTRACTVERIFY</code> evaluation ====\n+\n+The following code is executed every time the <code>OP_CHECKCONTRACTVERIFY</code> opcode is encountered during the evalutation of a taproot Script spend. <code>this_input_index</code>, <code>this_input_internal_key</code> and <code>this_input_taptree</code> are the index, taproot internal key and taproot Merkle root of the current input.\n+\n+<code>BIP341_NUMS_KEY</code> is the x-only provably unspendable key <code>50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code> defined in [[bip-341.mediawiki|BIP-341]].\n+\n+<source lang=\"python\">\n+  if flags < CCV_FLAG_CHECK_INPUT or flags > CCV_FLAG_DEDUCT_OUTPUT_AMOUNT:",
      "path": "bip-ccv.mediawiki",
      "position": 211,
      "original_position": 211,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010845676,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Since flags are mutually exclusive and the defined values are -1, 0, 1, 2, this is just checking if you're out of the range (then, _SUCCESS_ as an upgrade hook to add future flags).",
      "created_at": "2025-03-25T23:04:17Z",
      "updated_at": "2025-03-25T23:04:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013049325",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013049325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 211,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013058681",
      "pull_request_review_id": 2715403904,
      "id": 2013058681,
      "node_id": "PRRC_kwDOAN28mc53_NZ5",
      "diff_hunk": "@@ -0,0 +1,420 @@\n+<pre>\n+  BIP: TBD\n+  Layer: Consensus (soft fork)\n+  Title: OP_CHECKCONTRACTVERIFY\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-TBD\n+  Status: Draft\n+  Type: Standards Track\n+  Created: TBD\n+  License: BSD-3-Clause\n+  Post-History: 2022-11-08: https://gnusha.org/pi/bitcoindev/CAMhCMoH9uZPeAE_2tWH6rf0RndqV+ypjbNzazpFwFnLUpPsZ7g@mail.gmail.com\n+                2023-07-30: https://gnusha.org/pi/bitcoindev/CAMhCMoFYF+9NL1sqKfn=ma3C_mfQv7mj2fqbqO5WXVwd6vyhLw@mail.gmail.com\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes a new tapscript opcode that adds consensus support for an opcode that enables a new type of output restrictions: <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_CCV</code>).\n+\n+This opcode enables users to create UTXOs that carry a dynamic commitment to a piece of data. The commitment can be validated during the execution of the Script, allowing introspection to the committed data. Moreover, a Script can constrain the program (internal public key and taptree) and the data of one or more outputs.\n+\n+In conjunction with an opcode for ''vector commitments'', this allows to create and compose arbitrary state machines that define the possible future outcomes of a UTXO. The validity of a state transition depends on the conditions that can be expressed in the program (Scripts in the taptree).\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+The ability to constrain the future of coins beyond what is possible with presigned transactions is at the core of numerous attempts to improve bitcoin. Some of the proposed applications include:\n+\n+* UTXO sharing schemes like Ark, CoinPools, Timeout Trees, etc. use various types of output restrictions in order to enable multiple parties to share the control of a UTXO, while ensuring that each participant controls their own balance.\n+* <code>OP_VAULT</code><ref>[[bip-0345.mediawiki|BIP-345]]</ref> is a proposed opcode to implement a 2-step withdrawal process, enabling on-chain reactive security.\n+* <code>OP_CHECKTEMPLATEVERIFY</code><ref>[[bip-119.mediawiki|BIP-114]]</ref> is a long-proposed opcode to constrain the transaction to a ''template'' with a fixed set of outputs.\n+* Sidechains and rollups could be implemented via a UTXO encumbered with a recursive covenant, updating the sidechain state root every time it is spent.\n+\n+Constructions like BitVM<ref>https://bitvm.org/</ref> try to side-step the lack of a primitive allowing UTXOs to carry state with a clever use of Lamport Signatures, and optimistic execution of smart contracts. This comes with an extremely high cost in term of complexity, interactivity, and (potentially) in block size occupation, for some of the possible execution paths. Moreover, the design of fully trustless bridges remains elusive.\n+\n+Rather than providing a construct optimized for a specific application, this BIP aims to provide a fundamental building block that is widely applicable, and common to many constructions.\n+\n+== Design ==\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> is an implementation of a new primitive that could be called ''state-carrying UTXOs''. It allows to embed a commitment to a piece of data in a UTXO, and to validate it during the execution of the Script, and ''carry'' a (possibly dyamically computed) piece of data to the new UTXOs that are produced.\n+\n+We consider the ''program'' of a P2TR UTXO to be composed of an x-only public key (that we call the ''naked key''), and a Merkle tree of Scripts. If there is no data committed in the UTXO, then the naked key is the internal key as defined in BIP-341.\n+\n+If the UTXO carries a commitment to a 32-byte hash (the ''data''), the naked key is tweaked with a hash of the data. The resulting key is the taproot internal key per BIP-341.\n+\n+This allows to embed a commitment to the data that can be validated during the Script execution, while staying fully compatible with taproot. Notably:\n+* the committed data does not make the UTXO any larger;\n+* the keypath spend is still available to any party that possesses the private key of the naked key, as long as they have knowledge of the embedded data (or at least their hash)<ref>For example, in a multi-party contract, the naked key could be aggregate key using [[bip-0327.mediawiki|MuSig2]]; the taproot keypath would therefore allow a ''cooperative'' spend, without executing any Script at all. Like for all taproot transactions, this is indeed the cheapest way of spending the UTXO - albeit not always possible in practice.</ref>;\n+* if multiple Scripts are in different leaves of the taptree, only the ones that actually need to access the data have to pay a cost for it, in terms of additional witness bytes.\n+\n+<code>OP_CHECKCONTRACTVERIFY</code> can be applied to introspect the program and data of one of the inputs of the transaction (typically, the current input, in order to access its committed data), or one of the outputs of the transaction (in order to define its program, and possibly its committed data).\n+\n+=== Output amounts ===\n+\n+When checking the Script of one or more output with <code>OP_CHECKCONTRACTVERIFY</code>, it is usually necessary to also check that the amount of the current UTXO is correctly distributed among the outputs in the expected way. Therefore, the opcode already includes an amount semantic that covers the common use cases.\n+\n+There are two main behaviors that the opcode can enforce when checking an output, depending on the value of the flags:\n+* ''default'': the residual amount of the current input must be preserved in the output (aggregate across the inputs that specify the output);\n+* ''deduct'': the amount of the checked output is subtracted from the amount of the current input (the residual amount is then available for further checks);\n+* ''ignore'': the output amount is ignored.\n+\n+The ''default'' logic covers the common case where an input wishes to send the full amount to a specific output.\n+\n+The ''deduct'' logic allows to assign portions of the input amount to one or more outputs; the residual amount, checked with a final check using the ''default'' logic, can be used to enforce that the total amount is preserved.\n+\n+The following figures illustrate some common examples of supported use cases for the amount logic. This list is not exhaustive, as there are many more possible combinations.\n+\n+'''Remark:''' validation fails if the amount of an output is checked with both the ''default'' and the ''deduct'' logic in the same transaction, or multiple times with the ''deduct'' logic. This prevents duplicate or inconsistent counting of the same amounts.\n+\n+'''Remark:''' it is allowed to check for multiple inputs to check the same output with the ''default'' logic. This allows multiple inputs to aggregate (in full or in part) their amounts to the same output.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_1.png|framed|center|alt=1-to-1 amount logic|600px]]\n+::'''Figure 1:''' A UTXO <code>A</code> sends the entire amount to some output contract <code>B</code>, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_2.png|framed|center|alt=3-to-1 aggregate amount logic|600px]]\n+::'''Figure 2:''' Three UTXOs aggregate their amounts towards the same output contract, using <code>CCV</code> with the <i>default</i> semantic.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_3.png|framed|center|alt=split amount logic|600px]]\n+::'''Figure 3:''' A UTXO <code>A</code> sends a portion of its amount to a contract <code>A'</code> identical to itself, and the rest to a different contract <code>B</code>. It would use <code>CCV</code> to introspect its own input's program, then to check the first output with the <i>deduct</i> semantic, then to check the second output with the <i>default</i> semantic to assign the residual amount.\n+\n+-----\n+\n+::[[File:bip-ccv/amount_example_4.png|framed|center|alt=split and aggregate amount logic|600px]]\n+::'''Figure 4:''' Similar to the previous example, but a second input <code>B</code> also checks the same output <code>X</code> with the <i>default</i> semantic, aggregating its input with the residual amount of the first input.\n+\n+-----\n+\n+Note that the ''deduct'' semantic does not allow to check the exact amount of its output. Therefore, in contracts using a scheme similar to figure 3 or 4 above, amounts be constrained with a signature, or with future introspection opcodes that allow fixing the amount.\n+\n+== Specification ==\n+\n+The tapscript opcode <code>OP_SUCCESS187</code> (<code>0xbb</code>) is constrained with new rules to implement <code>OP_CHECKCONTRACTVERIFY</code>.\n+\n+When evaluating <code>OP_CHECKCONTRACTVERIFY</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<flags>\n+<taptree>\n+<pk>\n+<index>\n+<data>\n+</source>\n+\n+where:\n+\n+* <code><flags></code> is a minimally encoded integer, according to one of the values defined below.\n+* <code><taptree></code> is the Merkle root of the taproot tree, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><pk></code> is called the ''naked key'', and it's a valid 32-byte x-only public key, or a minimally encoded <code>-1</code>, or the empty buffer.\n+* <code><index></code> is a minimally encoded -1, or a minimally encoded non-negative integer.\n+* <code><data></code> is a buffer of arbitrary length.\n+\n+In short, the semantics of the opcode with respect to the Script can be summarized as follows:\n+\n+<blockquote>\n+Verify that the input/output with the given 'index' is a P2TR UTXO whose taproot output key is obtained from 'pk', tweaked with the hash of 'data' (if non-empty), then taptweaked with 'taptree' (if non-empty).\n+</blockquote>\n+\n+If the <code><data></code> is non-empty, then the additive tweak for the data is computed as:\n+\n+<source lang=\"python\">\n+  data_tweak = sha256(pk || data)\n+</source>\n+\n+In the following, the ''current input'' is the input whose Script is being executed.\n+\n+The following value of the <code><flags></code> are defined:\n+* <code>CCV_FLAG_CHECK_INPUT = -1</code>: Check an input's script; no amount check.\n+* <code>CCV_FLAG_CHECK_OUTPUT = 0</code>: Check an output's script; preserve the (possibly residual) amount.\n+* <code>CCV_FLAG_IGNORE_OUTPUT_AMOUNT = 1</code>: Check an output's script; ignore amounts.\n+* <code>CCV_FLAG_DEDUCT_OUTPUT_AMOUNT = 2</code>: Check an output's script; deduct the output amount from the input's residual amount.\n+\n+Any other value of the <code><flags></code> makes the opcode succeed validation immediately for the current input<ref>This allows to soft-fork future behavior by introducing new values for the <code><flags></code>. As the flags would always be hard-coded via a push in the Script, the risk of mistakes seems negligible.</ref>.\n+\n+The following values of the other parameters have special meanings:\n+* If the <code><taptree></code> is -1, it is replaced with the Merkle root of the current input's tapscript tree. If the taptree is the empty buffer, then the taptweak is skipped.",
      "path": "bip-ccv.mediawiki",
      "position": 145,
      "original_position": 145,
      "commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "original_commit_id": "aa291c23fbd3a46f85b94b0fb86ed475f0daf746",
      "in_reply_to_id": 2010828211,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "All the flags and the special parameters are encoded as 1-byte push opcodes, so I don't think you can really save much by aggregating them in the flags (e.g. using extra bits that are currently in the `OP_SUCCESS` behavior).\r\nMoreover, I think it would be very inconvenient (both in implementation and in Script readability) if the number of stack arguments is different for different use cases of CCV.",
      "created_at": "2025-03-25T23:15:53Z",
      "updated_at": "2025-03-25T23:15:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1793#discussion_r2013058681",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2013058681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1793"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 145,
      "side": "RIGHT"
    }
  ]
}