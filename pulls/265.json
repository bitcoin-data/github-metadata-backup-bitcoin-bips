{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/265",
    "id": 54431453,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTQ0MzE0NTM=",
    "html_url": "https://github.com/bitcoin/bips/pull/265",
    "diff_url": "https://github.com/bitcoin/bips/pull/265.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/265.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/265",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/265/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/265/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/265/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/90367c065a6d58a1548f690389e2a8b8bcb1d522",
    "number": 265,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "BIP 141: Segregated Witness (Consensus layer)",
    "user": {
      "login": "CodeShark",
      "id": 894059,
      "node_id": "MDQ6VXNlcjg5NDA1OQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/CodeShark",
      "html_url": "https://github.com/CodeShark",
      "followers_url": "https://api.github.com/users/CodeShark/followers",
      "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
      "organizations_url": "https://api.github.com/users/CodeShark/orgs",
      "repos_url": "https://api.github.com/users/CodeShark/repos",
      "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/CodeShark/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "BIP number requested,\n",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2015-12-23T00:46:26Z",
    "updated_at": "2016-01-08T17:54:46Z",
    "closed_at": "2016-01-08T17:54:46Z",
    "mergeable_state": "unknown",
    "merged_at": "2016-01-08T17:54:46Z",
    "merge_commit_sha": "1ea7fc05978600fb775c997ed2a8ab21fe597ef9",
    "assignee": {
      "login": "luke-jr",
      "id": 1095675,
      "node_id": "MDQ6VXNlcjEwOTU2NzU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/luke-jr",
      "html_url": "https://github.com/luke-jr",
      "followers_url": "https://api.github.com/users/luke-jr/followers",
      "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
      "organizations_url": "https://api.github.com/users/luke-jr/orgs",
      "repos_url": "https://api.github.com/users/luke-jr/repos",
      "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/luke-jr/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "CodeShark:segwit",
      "ref": "segwit",
      "sha": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "user": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 15538109,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNTUzODEwOQ==",
        "name": "bips",
        "full_name": "CodeShark/bips",
        "owner": {
          "login": "CodeShark",
          "id": 894059,
          "node_id": "MDQ6VXNlcjg5NDA1OQ==",
          "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/CodeShark",
          "html_url": "https://github.com/CodeShark",
          "followers_url": "https://api.github.com/users/CodeShark/followers",
          "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
          "organizations_url": "https://api.github.com/users/CodeShark/orgs",
          "repos_url": "https://api.github.com/users/CodeShark/repos",
          "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/CodeShark/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/CodeShark/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/CodeShark/bips",
        "archive_url": "https://api.github.com/repos/CodeShark/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/CodeShark/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/CodeShark/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/CodeShark/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/CodeShark/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/CodeShark/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/CodeShark/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/CodeShark/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/CodeShark/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/CodeShark/bips/contributors",
        "deployments_url": "https://api.github.com/repos/CodeShark/bips/deployments",
        "downloads_url": "https://api.github.com/repos/CodeShark/bips/downloads",
        "events_url": "https://api.github.com/repos/CodeShark/bips/events",
        "forks_url": "https://api.github.com/repos/CodeShark/bips/forks",
        "git_commits_url": "https://api.github.com/repos/CodeShark/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/CodeShark/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/CodeShark/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/CodeShark/bips.git",
        "issue_comment_url": "https://api.github.com/repos/CodeShark/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/CodeShark/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/CodeShark/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/CodeShark/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/CodeShark/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/CodeShark/bips/languages",
        "merges_url": "https://api.github.com/repos/CodeShark/bips/merges",
        "milestones_url": "https://api.github.com/repos/CodeShark/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/CodeShark/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/CodeShark/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/CodeShark/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:CodeShark/bips.git",
        "stargazers_url": "https://api.github.com/repos/CodeShark/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/CodeShark/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/CodeShark/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/CodeShark/bips/subscription",
        "tags_url": "https://api.github.com/repos/CodeShark/bips/tags",
        "teams_url": "https://api.github.com/repos/CodeShark/bips/teams",
        "trees_url": "https://api.github.com/repos/CodeShark/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/CodeShark/bips.git",
        "hooks_url": "https://api.github.com/repos/CodeShark/bips/hooks",
        "svn_url": "https://github.com/CodeShark/bips",
        "homepage": "bitcoin.org",
        "language": "Protocol Buffer",
        "forks_count": 3,
        "stargazers_count": 3,
        "watchers_count": 3,
        "size": 2505,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2018-11-09T12:53:28Z",
        "created_at": "2013-12-30T22:39:02Z",
        "updated_at": "2019-11-19T18:39:40Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "2f06ee5006e5fa69d52f0d7c9d60ad510101ab38",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5178,
        "stargazers_count": 8116,
        "watchers_count": 8116,
        "size": 13694,
        "default_branch": "master",
        "open_issues_count": 115,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-08T12:03:37Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-06-12T10:53:19Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 25,
    "deletions": 21,
    "changed_files": 1,
    "commits": 4,
    "review_comments": 20,
    "comments": 3
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 499062236,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDYyMjM2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499062236",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T01:14:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 499066362,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDY2MzYy",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499066362",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T01:27:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 499067987,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDY3OTg3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499067987",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T01:32:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 499072352,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDcyMzUy",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499072352",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T01:45:23Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 499078819,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDc4ODE5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499078819",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T01:54:13Z"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI3OTU6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI3OTc6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "head_ref_force_pushed",
      "id": 499091191,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDkxMTkx",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499091191",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T02:13:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 499092543,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDkyNTQz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499092543",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T02:14:35Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 499093761,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDkzNzYx",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499093761",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T02:16:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 499096424,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDk5MDk2NDI0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/499096424",
      "actor": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-23T02:23:00Z"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MDE6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MDM6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MDU6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MTE6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6M2UzMDA2MTI3ZTdkOWQ2YTRmMTcyZDY5MmRmNTE5NWNmNzQwY2Y3MQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/3e3006127e7d9d6a4f172d692df5195cf740cf71",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/3e3006127e7d9d6a4f172d692df5195cf740cf71",
      "tree": {
        "sha": "06d0530c9c45c324b98787a40b3a896777a1cc1a",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/06d0530c9c45c324b98787a40b3a896777a1cc1a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
          "sha": "894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
          "html_url": "https://github.com/bitcoin/bips/commit/894d8ac1cb8d2717b865d36b342f58fe7253a2c0"
        }
      ],
      "message": "Clarify Backward compatibility",
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@users.noreply.github.com",
        "date": "2015-12-28T17:32:35Z"
      },
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@users.noreply.github.com",
        "date": "2015-12-28T17:32:35Z"
      },
      "sha": "3e3006127e7d9d6a4f172d692df5195cf740cf71"
    },
    {
      "event": "labeled",
      "id": 502922657,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDUwMjkyMjY1Nw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/502922657",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-30T17:12:58Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "labeled",
      "id": 502922658,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDUwMjkyMjY1OA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/502922658",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2015-12-30T17:12:58Z",
      "label": {
        "name": "Needs number assignment",
        "color": "eb6420"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6NjZiYTRlNmZjZjZiODc1MmVjMzhiNzhhODVjN2YyMTIwMTQ4ZDg1Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/66ba4e6fcf6b8752ec38b78a85c7f2120148d856",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/66ba4e6fcf6b8752ec38b78a85c7f2120148d856",
      "tree": {
        "sha": "0cc4e386838050bad8dd69d7fd984b83237bfeb0",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/0cc4e386838050bad8dd69d7fd984b83237bfeb0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/3e3006127e7d9d6a4f172d692df5195cf740cf71",
          "sha": "3e3006127e7d9d6a4f172d692df5195cf740cf71",
          "html_url": "https://github.com/bitcoin/bips/commit/3e3006127e7d9d6a4f172d692df5195cf740cf71"
        }
      ],
      "message": "Separating version byte and witness program",
      "committer": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2015-12-30T19:00:24Z"
      },
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@users.noreply.github.com",
        "date": "2015-12-29T03:11:16Z"
      },
      "sha": "66ba4e6fcf6b8752ec38b78a85c7f2120148d856"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MTc6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MjA6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6MDM4YTRjMWQyZWY2NWZhMTJlNTYzNGZkOTcyOTllM2EyMzNiZTU3YQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/038a4c1d2ef65fa12e5634fd97299e3a233be57a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/038a4c1d2ef65fa12e5634fd97299e3a233be57a",
      "tree": {
        "sha": "0cc4e386838050bad8dd69d7fd984b83237bfeb0",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/0cc4e386838050bad8dd69d7fd984b83237bfeb0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
          "sha": "894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
          "html_url": "https://github.com/bitcoin/bips/commit/894d8ac1cb8d2717b865d36b342f58fe7253a2c0"
        },
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/66ba4e6fcf6b8752ec38b78a85c7f2120148d856",
          "sha": "66ba4e6fcf6b8752ec38b78a85c7f2120148d856",
          "html_url": "https://github.com/bitcoin/bips/commit/66ba4e6fcf6b8752ec38b78a85c7f2120148d856"
        }
      ],
      "message": "Merge pull request #1 from jl2012/patch-7\n\nClarify Backward compatibility and separating version byte and witness program",
      "committer": {
        "name": "Eric Lombrozo",
        "email": "dr_skew@yahoo.com",
        "date": "2016-01-02T01:42:34Z"
      },
      "author": {
        "name": "Eric Lombrozo",
        "email": "dr_skew@yahoo.com",
        "date": "2016-01-02T01:42:34Z"
      },
      "sha": "038a4c1d2ef65fa12e5634fd97299e3a233be57a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6OTAzNjdjMDY1YTZkNThhMTU0OGY2OTAzODllMmE4YjhiY2IxZDUyMg==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "tree": {
        "sha": "f87ce7da50d142f5e07105ae23f0b4538e844979",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/f87ce7da50d142f5e07105ae23f0b4538e844979"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/038a4c1d2ef65fa12e5634fd97299e3a233be57a",
          "sha": "038a4c1d2ef65fa12e5634fd97299e3a233be57a",
          "html_url": "https://github.com/bitcoin/bips/commit/038a4c1d2ef65fa12e5634fd97299e3a233be57a"
        },
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/2f06ee5006e5fa69d52f0d7c9d60ad510101ab38",
          "sha": "2f06ee5006e5fa69d52f0d7c9d60ad510101ab38",
          "html_url": "https://github.com/bitcoin/bips/commit/2f06ee5006e5fa69d52f0d7c9d60ad510101ab38"
        }
      ],
      "message": "Merge pull request #2 from alp-bitcoin/patch-1\n\nFixed typos.",
      "committer": {
        "name": "Eric Lombrozo",
        "email": "dr_skew@yahoo.com",
        "date": "2016-01-02T01:43:34Z"
      },
      "author": {
        "name": "Eric Lombrozo",
        "email": "dr_skew@yahoo.com",
        "date": "2016-01-02T01:43:34Z"
      },
      "sha": "90367c065a6d58a1548f690389e2a8b8bcb1d522"
    },
    {
      "event": "commented",
      "id": 169641674,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTY0MTY3NA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/169641674",
      "actor": {
        "login": "rubensayshi",
        "id": 649160,
        "node_id": "MDQ6VXNlcjY0OTE2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rubensayshi",
        "html_url": "https://github.com/rubensayshi",
        "followers_url": "https://api.github.com/users/rubensayshi/followers",
        "following_url": "https://api.github.com/users/rubensayshi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rubensayshi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rubensayshi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rubensayshi/subscriptions",
        "organizations_url": "https://api.github.com/users/rubensayshi/orgs",
        "repos_url": "https://api.github.com/users/rubensayshi/repos",
        "events_url": "https://api.github.com/users/rubensayshi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rubensayshi/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-07T11:53:33Z",
      "updated_at": "2016-01-07T11:53:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "related BIPs, for easy reference;\n- Segwit peer services https://github.com/bitcoin/bips/pull/272\n- Transaction signature verification for version 0 and version 1 witness program https://github.com/bitcoin/bips/pull/270\n- Address Format for Witness Program https://github.com/bitcoin/bips/pull/267 \n\nand WIP code:\n- https://github.com/sipa/bitcoin/pull/8/files\n",
      "user": {
        "login": "rubensayshi",
        "id": 649160,
        "node_id": "MDQ6VXNlcjY0OTE2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rubensayshi",
        "html_url": "https://github.com/rubensayshi",
        "followers_url": "https://api.github.com/users/rubensayshi/followers",
        "following_url": "https://api.github.com/users/rubensayshi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rubensayshi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rubensayshi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rubensayshi/subscriptions",
        "organizations_url": "https://api.github.com/users/rubensayshi/orgs",
        "repos_url": "https://api.github.com/users/rubensayshi/repos",
        "events_url": "https://api.github.com/users/rubensayshi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rubensayshi/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/265#issuecomment-169641674",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/265"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MjI6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "commented",
      "id": 169741211,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTc0MTIxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/169741211",
      "actor": {
        "login": "rubensayshi",
        "id": 649160,
        "node_id": "MDQ6VXNlcjY0OTE2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rubensayshi",
        "html_url": "https://github.com/rubensayshi",
        "followers_url": "https://api.github.com/users/rubensayshi/followers",
        "following_url": "https://api.github.com/users/rubensayshi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rubensayshi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rubensayshi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rubensayshi/subscriptions",
        "organizations_url": "https://api.github.com/users/rubensayshi/orgs",
        "repos_url": "https://api.github.com/users/rubensayshi/repos",
        "events_url": "https://api.github.com/users/rubensayshi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rubensayshi/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-07T17:22:00Z",
      "updated_at": "2016-01-07T17:22:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "is there a reason why the transaction version is not bumped for the new structure?\n",
      "user": {
        "login": "rubensayshi",
        "id": 649160,
        "node_id": "MDQ6VXNlcjY0OTE2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649160?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rubensayshi",
        "html_url": "https://github.com/rubensayshi",
        "followers_url": "https://api.github.com/users/rubensayshi/followers",
        "following_url": "https://api.github.com/users/rubensayshi/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rubensayshi/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rubensayshi/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rubensayshi/subscriptions",
        "organizations_url": "https://api.github.com/users/rubensayshi/orgs",
        "repos_url": "https://api.github.com/users/rubensayshi/repos",
        "events_url": "https://api.github.com/users/rubensayshi/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rubensayshi/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/265#issuecomment-169741211",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/265"
    },
    {
      "event": "commented",
      "id": 169745801,
      "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTc0NTgwMQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/169745801",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-07T17:29:28Z",
      "updated_at": "2016-01-07T17:29:28Z",
      "author_association": "MEMBER",
      "body": "Yes. There is no need:\n- SegWit transactions are not standard anyway due to the CLEANSTACK rule\n  already.\n- We don't need it for serialization, because we need another mechanism for\n  signaling the presence of witness data anyway.\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/265#issuecomment-169745801",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/265"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwODI4MjQ6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "mentioned",
      "id": 508711879,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NTA4NzExODc5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/508711879",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-07T20:49:46Z"
    },
    {
      "event": "subscribed",
      "id": 508711880,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDUwODcxMTg4MA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/508711880",
      "actor": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-07T20:49:46Z"
    },
    {
      "event": "assigned",
      "id": 509636031,
      "node_id": "MDEzOkFzc2lnbmVkRXZlbnQ1MDk2MzYwMzE=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/509636031",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-08T17:11:18Z",
      "assignee": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "renamed",
      "id": 509662241,
      "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50NTA5NjYyMjQx",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/509662241",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-08T17:34:30Z",
      "rename": {
        "from": "Segwit BIP",
        "to": "BIP 141: Segregated Witness (Consensus layer)"
      }
    },
    {
      "event": "unlabeled",
      "id": 509662288,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NTA5NjYyMjg4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/509662288",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-08T17:34:33Z",
      "label": {
        "name": "Needs number assignment",
        "color": "eb6420"
      }
    },
    {
      "event": "merged",
      "id": 509683747,
      "node_id": "MDExOk1lcmdlZEV2ZW50NTA5NjgzNzQ3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/509683747",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "created_at": "2016-01-08T17:54:46Z"
    },
    {
      "event": "closed",
      "id": 509683748,
      "node_id": "MDExOkNsb3NlZEV2ZW50NTA5NjgzNzQ4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/509683748",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2016-01-08T17:54:46Z"
    },
    {
      "event": "referenced",
      "id": 1433567983,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDE0MzM1Njc5ODM=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/1433567983",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "c93cd75d880c82fb2ff7173a99d9f49abf75f8bf",
      "commit_url": "https://api.github.com/repos/luke-jr/bips/commits/c93cd75d880c82fb2ff7173a99d9f49abf75f8bf",
      "created_at": "2018-01-20T04:21:29Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48317291",
      "pull_request_review_id": null,
      "id": 48317291,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE3Mjkx",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: ",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 4,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "7f196396d34d5cf1ad36491f87880ff6ef25ff90",
      "in_reply_to_id": null,
      "user": {
        "login": "btcdrak",
        "id": 7275704,
        "node_id": "MDQ6VXNlcjcyNzU3MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7275704?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/btcdrak",
        "html_url": "https://github.com/btcdrak",
        "followers_url": "https://api.github.com/users/btcdrak/followers",
        "following_url": "https://api.github.com/users/btcdrak/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/btcdrak/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/btcdrak/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/btcdrak/subscriptions",
        "organizations_url": "https://api.github.com/users/btcdrak/orgs",
        "repos_url": "https://api.github.com/users/btcdrak/repos",
        "events_url": "https://api.github.com/users/btcdrak/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/btcdrak/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "missing authors\n",
      "created_at": "2015-12-23T02:00:55Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48317291",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48317291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48317301",
      "pull_request_review_id": null,
      "id": 48317301,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE3MzAx",
      "diff_hunk": "@@ -0,0 +1,300 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: \n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constriants could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+Maybe a seperate BIP\n+<pre>\n+* CTransaction gets, in addition to vin and vout, a vwit, which\n+contains a CTxInWitness object for each input. A CTxInWitness contains a CScriptWitness object\n+and can potentially be extended to contain other kinds of witness data.\n+A CScriptWitness is a vector of byte vectors (nominally: the input stack to the program, no longer\n+encoded as a CScript, but just the resulting stack directly).\n+* A new serialization for CTransaction is defined: http://blockhawk.net/diagrams/witnesstx.png\n+(int32 nVersion,\n+0x00 marker, 0x01 flag, vector<CTxIn>, vector<CTxOut>,\n+vector<CTxInWitness>, int32 nLockTime) instead of (int32 nVersion,\n+vector<CTxIn>, vector<CTxOut>, int32 nLockTime). This will never parse\n+as a valid transaction (even if parsing succeeds, it means it's\n+interpreted as a transaction with no inputs and 1 output). If all\n+witnesses are empty, the old serialization format is used.\n+- Rationale for not having an independent CWitnessTransaction with\n+its own serialization: this would require separate \"tx\" and \"block\"\n+messages, and all RPC calls operating on raw transactions would need\n+to be duplicated, or need inefficinent or nondeterministic guesswork\n+to know which type is to be used.\n+- Rationale for not using just a single 0x00 byte as marker: that\n+would lead to empty transactions (no inputs, no outputs, which are\n+used in some tests) to be interpreted as new serialized data.\n+- Rationale for the 0x01 flag byte in between: this will allow us to\n+easily add more extra non-committed data to transactions (like txouts\n+being spent, ...). It can be interpreted as a bitvector.\n+\n+* A new message 'havewitness' is sent after receiving 'verack' to\n+indicate that a node can provide witness if requested (similar to\n+'sendheaders')\n+\n+* New inv types MSG_WITNESS_TX and MSG_WITNESS_BLOCK are added, only\n+for use in getdata. Inv itself still use just MSG_TX and MSG_BLOCK,\n+similar to MSG_FILTERED_BLOCK.\n+- Rationale for not advertizing witnessness in invs: we don't always\n+use invs anymore (with 'sendheaders' BIP 130), plus it's not useful:\n+implicitly, every transaction and block have a witness, old ones just\n+have empty ones.\n+\n+* Transactions' GetHash is always computed on the old non-witness\n+serialization. A new CTransaction::GetWitnessHash is added which is\n+computed from the witness-serialization (this means that transactions\n+with an empty witness have witness hash equal to normal hash).\n+</pre>\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Discount for witness data?\n+Virtual block size limit?\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a single push of 2 to 41 bytes gets a new special meaning. The byte vector pushed by it is called the \"witness program\".\n+** In case the scriptPubKey pushes a witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+* The first byte of a witness program is the \"version byte\", an unsigned integer.\n+** If the version byte is 0, the rest of the witness program is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the rest of the witness program must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the witness version byte is 2 or above, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x0076A914{20-byte-hash-value}88AC>\n+\n+The version byte 0x00 is removed. The rest of the witness program is deserialized and becomes:\n+\n+    DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+The script is executed with the data from witness\n+\n+    <signature> <pubkey> DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+Comparing with a P2PKH output, the witness program equivalent occupies 2 more bytes in the scriptPubKey, while moving the signature and public key from scriptSig to witness.\n+\n+=== Version 1 witness program ===\n+\n+The following example is an 1-of-2 multi-signature version 1 witness program.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x01{32-byte-hash-value}>\n+\n+The last item in the witness is popped off, hashed with SHA256, compared against the 32-byte-hash-value in scriptPubKey, and deserialized:\n+\n+    1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+The script is executed with the remaining data from witness:\n+\n+    0 <signature1> 1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+Since the actual program is larger than 40 bytes, it cannot be accommodated in a version 0 witness program. A version 1 witness program allows arbitrarily large script as the 520-byte push limit is bypassed.\n+\n+The scriptPubKey occupies 34 bytes, as opposed to 23 bytes of P2SH. The increased size improves security against possible collision attacks, as 2^80 work is not infeasible anymore (By the end of 2015, 2^84 hashes have been calculated in Bitcoin mining since the creation of Bitcoin). The spending script is same as the one for an equivalent P2SH output but is moved to witness.\n+\n+=== Witness program nested in Pay-to-Script-Hash ===\n+\n+The following example is the same 1-of-2 multi-signature version 1 witness program, but nested in a P2SH output.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    <0x2101{32-byte-hash-value}>\n+    scriptPubKey: HASH160 <20-byte-hash-value> EQUAL\n+\n+The only item in scriptSig is hashed with HASH160, compared against the 20-byte-hash-value in scriptPubKey, and interpreted as a single push of:\n+\n+    <0x01{32-byte-hash-value}>\n+\n+The version 1 witness program is then executed as described in the last example\n+\n+Comparing with the last example, the scriptPubKey is 11 bytes smaller (with reduced security) while witness is the same. However, it also requires 35 bytes in scriptSig, which is not prunable in transmission. Although a nested witness program is less efficient in many ways, its payment address is fully transparent and backward compatible for all Bitcoin reference client since version 0.6.0.\n+\n+=== Trust-free unconfirmed transaction dependency chain ===\n+Segregated witness fixes the problem of transaction malleability fundamentally, which enables the building of unconfirmed transaction dependency chains in a trust-free manner.\n+\n+Two parties, Alice and Bob, may agree to send certain amount of Bitcoin to a 2-of-2 multisig output (the \"funding transaction\"). Without signing the funding transaction, they may create another transaction, time-locked in the future, spending the 2-of-2 multisig output to third account(s) (the \"spending transaction\"). Alice and Bob will sign the spending transaction and exchange the signatures. After examining the signatures, they will sign and commit the funding transaction to the blockchain. Without further action, the spending transaction will be confirmed after the lock-time and release the funding according to the original contract. It also retains the flexibility of revoking the original contract before the lock-time, by another spending transaction with shorter lock-time, but only with mutual-agreement of both parties.\n+\n+Such setups is not possible with BIP62 as the malleability fix, since the spending transaction could not be created without both parties first signing the funding transaction. If Alice reveals the funding transaction signature before Bob does, Bob is able to lock up the funding indefinitely without ever signing the spending transaction.\n+\n+Unconfirmed transaction dependency chain is a fundamental building block of more sophisticated payment networks, such as duplex micropayment channel and the Lightning Network, which have the potential to greatly improve the scalability and efficiency of the Bitcoin system.\n+\n+== Future extensions ==\n+=== Compact fraud proof for SPV nodes ===\n+Bitcoin right now only has two real security models. A user either runs a full-node which validates every block with all rules in the system, or a SPV (Simple Payment Verification) client which only validates the headers as a proof of publication of some transactions. The Bitcoin whitepaper suggested that SPV nodes may accept alerts from full nodes when they detect an invalid block, prompting the SPV node to download the questioned blocks and transactions for validation. This approach, however, could become a DoS attack vector as there is virtually no cost to generate a false alarm. An alarm must come with a compact, yet deterministic fraud proof.\n+\n+In the current Bitcoin protocol, it is possible to generate compact fraud proof for almost all rules except a few:\n+\n+# It is not possible to proof a miner has introduced too many Bitcoins in the coinbase transaction outputs without showing the whole block itself and all input transactions.\n+# It is not possible to prove the violation of any block specific constraints, such as size and sigop limits, without showing the whole block (and all input transactions in the case of sigop limit)\n+# It is not possible to prove the spending of a non-existing input without showing all transaction IDs in the blockchain way back to the genesis block.\n+\n+It is possible to proof the first 2 types of fraud if a block is committed to a Merkle-sum-tree of the fee, size, and sigop count of each transaction. It is also possible to proof the last type of fraud if a block is committed to a Merkle tree with the originating block height and transaction index of all inputs. These commitments could be included in the extensible witness commitment through a soft fork and will be transparent to nodes that do not understand such new rules.\n+\n+=== New script system ===\n+Since all witness programs begin with a version byte, and programs with unknown versions are always considered as anyone-can-spend script, it is possible to introduce any new script system with a soft fork. The witness as a structure is not restricted by any existing script semantics and constraints, the 520-byte push limit in particular, and therefore allows arbitrarily large scripts and signatures.\n+\n+Examples of new script system include Schnorr signatures which reduce the size of multisig transactions dramatically, Lamport signature which is quantum computing resistance, and Merklized abstract syntax trees which allow very compact witness for conditional scripts with extreme complexity.\n+\n+The 41-byte limitation for witness programme could be easily extended through a soft fork in case a stronger hash function is needed in the future. The version byte is also expandable by introducing a secondary version byte for some specific primary version values.\n+\n+=== Per-input lock-time and relative-lock-time ===\n+Currently there is only one nLockTime field in a transaction and all inputs must share the same value. BIP68 enables per-input relative-lock-time using the nSequence field, however, with a limited lock-time period and resolution.\n+\n+With a soft fork, it is possible to introduce a separate witness structure to allow per-input lock-time and relative-lock-time, and a new script system that could sign and manipulate the new data (like BIP65 and BIP112).\n+\n+== Backward compatibility ==\n+As a soft fork, older software will continue to operate without modification.  Non-upgraded nodes, however, will not see nor validate the witness data and will consider all witness programs as anyone-can-spend scripts (except a few edge cases in version 0 witness programs which are provably unspendable with original script semantics). Wallets should always be wary of anyone-can-spend scripts and treat them with suspicion. Non-upgraded nodes are strongly encouraged to upgrade in order to take advantage of the new features.\n+\n+Wallets will be able to migrate in two phases:\n+\n+=== P2SH compatibility ===\n+Witness programs are hashed to 256 bit \"redeemscripts\" which are then hashed to 160 bit P2SH. This format is fully compatible with currently existing wallets that support P2SH. Upgraded wallets will be able to send and receive to and from older wallets without any problems.\n+\n+=== Native outputs ===\n+Witness programs are hashed to a 256 bit output. This format will not be compatible with older wallets but will require less block space and will have better security due to increased collision resistance.\n+\n+== Deployment ==\n+\n+We reuse the double-threshold IsSuperMajority() switchover mechanism used in\n+BIP65 with the same thresholds, but for nVersion = 5. The new rules are\n+in effect for every block (at height H) with nVersion = 5 and at least\n+750 out of 1000 blocks preceding it (with heights H-1000..H-1) also\n+have nVersion >= 5. Furthermore, when 950 out of the 1000 blocks\n+preceding a block do have nVersion >= 5, nVersion < 5 blocks become\n+invalid, and all further blocks enforce the new rules.\n+\n+(It should be noted that BIP9 involves permanently setting a high-order bit to\n+1 which results in nVersion >= all prior IsSuperMajority() soft-forks and thus\n+no bits in nVersion are permanently lost.)\n+\n+\n+=== SPV Clients ===\n+\n+While SPV clients are unable to fully validate blocks,\n+they are able to validate block headers and, thus, can check block version and proof-of-work.\n+SPV clients should reject nVersion < 5 blocks if 950 out of 1000 preceding blocks have\n+nVersion >= 5 to prevent false confirmations from the remaining 5% of\n+non-upgraded miners when the 95% threshold has been reached.\n+\n+== Credits ==\n+",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 298,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "7f196396d34d5cf1ad36491f87880ff6ef25ff90",
      "in_reply_to_id": null,
      "user": {
        "login": "btcdrak",
        "id": 7275704,
        "node_id": "MDQ6VXNlcjcyNzU3MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7275704?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/btcdrak",
        "html_url": "https://github.com/btcdrak",
        "followers_url": "https://api.github.com/users/btcdrak/followers",
        "following_url": "https://api.github.com/users/btcdrak/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/btcdrak/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/btcdrak/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/btcdrak/subscriptions",
        "organizations_url": "https://api.github.com/users/btcdrak/orgs",
        "repos_url": "https://api.github.com/users/btcdrak/repos",
        "events_url": "https://api.github.com/users/btcdrak/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/btcdrak/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Missing copyright statement.\n",
      "created_at": "2015-12-23T02:01:15Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48317301",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48317301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48320183",
      "pull_request_review_id": null,
      "id": 48320183,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMTgz",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Authors: Eric Lombrozo <elombrozo@gmail.com>, Johnson Lau <jl2012@xbt.hk>, Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+Maybe a seperate BIP",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 37,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "181280bed71acbee34ea5c83671b240ed28545dd",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "???\n",
      "created_at": "2015-12-23T03:47:06Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48320183",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48320183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48320218",
      "pull_request_review_id": null,
      "id": 48320218,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMjE4",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Authors: Eric Lombrozo <elombrozo@gmail.com>, Johnson Lau <jl2012@xbt.hk>, Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+Maybe a seperate BIP",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 37,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "181280bed71acbee34ea5c83671b240ed28545dd",
      "in_reply_to_id": null,
      "user": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "the comment refers to the p2p serialization and relay stuff - what follows is the consensus specification, which WILL be in this document.\n",
      "created_at": "2015-12-23T03:49:17Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48320218",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48320218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48320596",
      "pull_request_review_id": null,
      "id": 48320596,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTk2",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Authors: Eric Lombrozo <elombrozo@gmail.com>, Johnson Lau <jl2012@xbt.hk>, Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+Maybe a seperate BIP\n+<pre>\n+* CTransaction gets, in addition to vin and vout, a vwit, which\n+contains a CTxInWitness object for each input. A CTxInWitness contains a CScriptWitness object\n+and can potentially be extended to contain other kinds of witness data.\n+A CScriptWitness is a vector of byte vectors (nominally: the input stack to the program, no longer\n+encoded as a CScript, but just the resulting stack directly).\n+* A new serialization for CTransaction is defined: http://blockhawk.net/diagrams/witnesstx.png\n+(int32 nVersion,\n+0x00 marker, 0x01 flag, vector<CTxIn>, vector<CTxOut>,\n+vector<CTxInWitness>, int32 nLockTime) instead of (int32 nVersion,\n+vector<CTxIn>, vector<CTxOut>, int32 nLockTime). This will never parse\n+as a valid transaction (even if parsing succeeds, it means it's\n+interpreted as a transaction with no inputs and 1 output). If all\n+witnesses are empty, the old serialization format is used.\n+- Rationale for not having an independent CWitnessTransaction with\n+its own serialization: this would require separate \"tx\" and \"block\"\n+messages, and all RPC calls operating on raw transactions would need\n+to be duplicated, or need inefficinent or nondeterministic guesswork\n+to know which type is to be used.\n+- Rationale for not using just a single 0x00 byte as marker: that\n+would lead to empty transactions (no inputs, no outputs, which are\n+used in some tests) to be interpreted as new serialized data.\n+- Rationale for the 0x01 flag byte in between: this will allow us to\n+easily add more extra non-committed data to transactions (like txouts\n+being spent, ...). It can be interpreted as a bitvector.\n+\n+* A new message 'havewitness' is sent after receiving 'verack' to",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 64,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "181280bed71acbee34ea5c83671b240ed28545dd",
      "in_reply_to_id": null,
      "user": {
        "login": "NicolasDorier",
        "id": 3020646,
        "node_id": "MDQ6VXNlcjMwMjA2NDY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/NicolasDorier",
        "html_url": "https://github.com/NicolasDorier",
        "followers_url": "https://api.github.com/users/NicolasDorier/followers",
        "following_url": "https://api.github.com/users/NicolasDorier/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/NicolasDorier/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/NicolasDorier/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
        "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
        "repos_url": "https://api.github.com/users/NicolasDorier/repos",
        "events_url": "https://api.github.com/users/NicolasDorier/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why not using \"version\" service bits ? Having a havewitness message is a pain in the ass for wallet developers, because they need to know whether the node support witness or not. If you use havewitness message, then after the verack we need to wait if there is any havewitness message coming with a timeout to determine if it is supported and deciding if we continue to conversation or not.\n",
      "created_at": "2015-12-23T04:03:47Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48320596",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48320596"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48320911",
      "pull_request_review_id": null,
      "id": 48320911,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwOTEx",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Authors: Eric Lombrozo <elombrozo@gmail.com>, Johnson Lau <jl2012@xbt.hk>, Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+Maybe a seperate BIP\n+<pre>\n+* CTransaction gets, in addition to vin and vout, a vwit, which\n+contains a CTxInWitness object for each input. A CTxInWitness contains a CScriptWitness object\n+and can potentially be extended to contain other kinds of witness data.\n+A CScriptWitness is a vector of byte vectors (nominally: the input stack to the program, no longer\n+encoded as a CScript, but just the resulting stack directly).\n+* A new serialization for CTransaction is defined: http://blockhawk.net/diagrams/witnesstx.png\n+(int32 nVersion,\n+0x00 marker, 0x01 flag, vector<CTxIn>, vector<CTxOut>,\n+vector<CTxInWitness>, int32 nLockTime) instead of (int32 nVersion,\n+vector<CTxIn>, vector<CTxOut>, int32 nLockTime). This will never parse\n+as a valid transaction (even if parsing succeeds, it means it's\n+interpreted as a transaction with no inputs and 1 output). If all\n+witnesses are empty, the old serialization format is used.\n+- Rationale for not having an independent CWitnessTransaction with\n+its own serialization: this would require separate \"tx\" and \"block\"\n+messages, and all RPC calls operating on raw transactions would need\n+to be duplicated, or need inefficinent or nondeterministic guesswork\n+to know which type is to be used.\n+- Rationale for not using just a single 0x00 byte as marker: that\n+would lead to empty transactions (no inputs, no outputs, which are\n+used in some tests) to be interpreted as new serialized data.\n+- Rationale for the 0x01 flag byte in between: this will allow us to\n+easily add more extra non-committed data to transactions (like txouts\n+being spent, ...). It can be interpreted as a bitvector.\n+\n+* A new message 'havewitness' is sent after receiving 'verack' to",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 64,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "181280bed71acbee34ea5c83671b240ed28545dd",
      "in_reply_to_id": null,
      "user": {
        "login": "CodeShark",
        "id": 894059,
        "node_id": "MDQ6VXNlcjg5NDA1OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/894059?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/CodeShark",
        "html_url": "https://github.com/CodeShark",
        "followers_url": "https://api.github.com/users/CodeShark/followers",
        "following_url": "https://api.github.com/users/CodeShark/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/CodeShark/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/CodeShark/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/CodeShark/subscriptions",
        "organizations_url": "https://api.github.com/users/CodeShark/orgs",
        "repos_url": "https://api.github.com/users/CodeShark/repos",
        "events_url": "https://api.github.com/users/CodeShark/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/CodeShark/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This part of the specification (specifically the peer services layer) is still very preliminary and will probably be put into its own BIP. We expect it to undergo substantial changes still.\n",
      "created_at": "2015-12-23T04:16:39Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48320911",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48320911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48321104",
      "pull_request_review_id": null,
      "id": 48321104,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMTA0",
      "diff_hunk": "@@ -0,0 +1,305 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Authors: Eric Lombrozo <elombrozo@gmail.com>, Johnson Lau <jl2012@xbt.hk>, Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+Maybe a seperate BIP\n+<pre>\n+* CTransaction gets, in addition to vin and vout, a vwit, which\n+contains a CTxInWitness object for each input. A CTxInWitness contains a CScriptWitness object\n+and can potentially be extended to contain other kinds of witness data.\n+A CScriptWitness is a vector of byte vectors (nominally: the input stack to the program, no longer\n+encoded as a CScript, but just the resulting stack directly).\n+* A new serialization for CTransaction is defined: http://blockhawk.net/diagrams/witnesstx.png\n+(int32 nVersion,\n+0x00 marker, 0x01 flag, vector<CTxIn>, vector<CTxOut>,\n+vector<CTxInWitness>, int32 nLockTime) instead of (int32 nVersion,\n+vector<CTxIn>, vector<CTxOut>, int32 nLockTime). This will never parse\n+as a valid transaction (even if parsing succeeds, it means it's\n+interpreted as a transaction with no inputs and 1 output). If all\n+witnesses are empty, the old serialization format is used.\n+- Rationale for not having an independent CWitnessTransaction with\n+its own serialization: this would require separate \"tx\" and \"block\"\n+messages, and all RPC calls operating on raw transactions would need\n+to be duplicated, or need inefficinent or nondeterministic guesswork\n+to know which type is to be used.\n+- Rationale for not using just a single 0x00 byte as marker: that\n+would lead to empty transactions (no inputs, no outputs, which are\n+used in some tests) to be interpreted as new serialized data.\n+- Rationale for the 0x01 flag byte in between: this will allow us to\n+easily add more extra non-committed data to transactions (like txouts\n+being spent, ...). It can be interpreted as a bitvector.\n+\n+* A new message 'havewitness' is sent after receiving 'verack' to",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 64,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "181280bed71acbee34ea5c83671b240ed28545dd",
      "in_reply_to_id": null,
      "user": {
        "login": "jl2012",
        "id": 8403418,
        "node_id": "MDQ6VXNlcjg0MDM0MTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jl2012",
        "html_url": "https://github.com/jl2012",
        "followers_url": "https://api.github.com/users/jl2012/followers",
        "following_url": "https://api.github.com/users/jl2012/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jl2012/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jl2012/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
        "organizations_url": "https://api.github.com/users/jl2012/orgs",
        "repos_url": "https://api.github.com/users/jl2012/repos",
        "events_url": "https://api.github.com/users/jl2012/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jl2012/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To avoid confusion, may remove this part from this BIP and say the relay protocol is defined in a separate BIP\n",
      "created_at": "2015-12-23T04:24:59Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48321104",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48321104"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48417276",
      "pull_request_review_id": null,
      "id": 48417276,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE3Mjc2",
      "diff_hunk": "@@ -0,0 +1,263 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a single push of 2 to 41 bytes gets a new special meaning. The byte vector pushed by it is called the \"witness program\".\n+** In case the scriptPubKey pushes a witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+* The first byte of a witness program is the \"version byte\", an unsigned integer.\n+** If the version byte is 0, the rest of the witness program is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the rest of the witness program must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the witness version byte is 2 or above, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x0076A914{20-byte-hash-value}88AC>\n+\n+The version byte 0x00 is removed. The rest of the witness program is deserialized and becomes:\n+\n+    DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+The script is executed with the data from witness\n+\n+    <signature> <pubkey> DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+Comparing with a P2PKH output, the witness program equivalent occupies 2 more bytes in the scriptPubKey, while moving the signature and public key from scriptSig to witness.\n+\n+=== Version 1 witness program ===\n+\n+The following example is an 1-of-2 multi-signature version 1 witness program.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x01{32-byte-hash-value}>\n+\n+The last item in the witness is popped off, hashed with SHA256, compared against the 32-byte-hash-value in scriptPubKey, and deserialized:\n+\n+    1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+The script is executed with the remaining data from witness:\n+\n+    0 <signature1> 1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+Since the actual program is larger than 40 bytes, it cannot be accommodated in a version 0 witness program. A version 1 witness program allows arbitrarily large script as the 520-byte push limit is bypassed.\n+\n+The scriptPubKey occupies 34 bytes, as opposed to 23 bytes of P2SH. The increased size improves security against possible collision attacks, as 2^80 work is not infeasible anymore (By the end of 2015, 2^84 hashes have been calculated in Bitcoin mining since the creation of Bitcoin). The spending script is same as the one for an equivalent P2SH output but is moved to witness.\n+\n+=== Witness program nested in Pay-to-Script-Hash ===\n+\n+The following example is the same 1-of-2 multi-signature version 1 witness program, but nested in a P2SH output.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    <0x2101{32-byte-hash-value}>\n+    scriptPubKey: HASH160 <20-byte-hash-value> EQUAL\n+\n+The only item in scriptSig is hashed with HASH160, compared against the 20-byte-hash-value in scriptPubKey, and interpreted as a single push of:\n+\n+    <0x01{32-byte-hash-value}>\n+\n+The version 1 witness program is then executed as described in the last example\n+\n+Comparing with the last example, the scriptPubKey is 11 bytes smaller (with reduced security) while witness is the same. However, it also requires 35 bytes in scriptSig, which is not prunable in transmission. Although a nested witness program is less efficient in many ways, its payment address is fully transparent and backward compatible for all Bitcoin reference client since version 0.6.0.\n+\n+=== Trust-free unconfirmed transaction dependency chain ===\n+Segregated witness fixes the problem of transaction malleability fundamentally, which enables the building of unconfirmed transaction dependency chains in a trust-free manner.\n+\n+Two parties, Alice and Bob, may agree to send certain amount of Bitcoin to a 2-of-2 multisig output (the \"funding transaction\"). Without signing the funding transaction, they may create another transaction, time-locked in the future, spending the 2-of-2 multisig output to third account(s) (the \"spending transaction\"). Alice and Bob will sign the spending transaction and exchange the signatures. After examining the signatures, they will sign and commit the funding transaction to the blockchain. Without further action, the spending transaction will be confirmed after the lock-time and release the funding according to the original contract. It also retains the flexibility of revoking the original contract before the lock-time, by another spending transaction with shorter lock-time, but only with mutual-agreement of both parties.\n+\n+Such setups is not possible with BIP62 as the malleability fix, since the spending transaction could not be created without both parties first signing the funding transaction. If Alice reveals the funding transaction signature before Bob does, Bob is able to lock up the funding indefinitely without ever signing the spending transaction.\n+\n+Unconfirmed transaction dependency chain is a fundamental building block of more sophisticated payment networks, such as duplex micropayment channel and the Lightning Network, which have the potential to greatly improve the scalability and efficiency of the Bitcoin system.\n+\n+== Future extensions ==\n+=== Compact fraud proof for SPV nodes ===\n+Bitcoin right now only has two real security models. A user either runs a full-node which validates every block with all rules in the system, or a SPV (Simple Payment Verification) client which only validates the headers as a proof of publication of some transactions. The Bitcoin whitepaper suggested that SPV nodes may accept alerts from full nodes when they detect an invalid block, prompting the SPV node to download the questioned blocks and transactions for validation. This approach, however, could become a DoS attack vector as there is virtually no cost to generate a false alarm. An alarm must come with a compact, yet deterministic fraud proof.\n+\n+In the current Bitcoin protocol, it is possible to generate compact fraud proof for almost all rules except a few:\n+\n+# It is not possible to proof a miner has introduced too many Bitcoins in the coinbase transaction outputs without showing the whole block itself and all input transactions.\n+# It is not possible to prove the violation of any block specific constraints, such as size and sigop limits, without showing the whole block (and all input transactions in the case of sigop limit)\n+# It is not possible to prove the spending of a non-existing input without showing all transaction IDs in the blockchain way back to the genesis block.\n+\n+It is possible to proof the first 2 types of fraud if a block is committed to a Merkle-sum-tree of the fee, size, and sigop count of each transaction. It is also possible to proof the last type of fraud if a block is committed to a Merkle tree with the originating block height and transaction index of all inputs. These commitments could be included in the extensible witness commitment through a soft fork and will be transparent to nodes that do not understand such new rules.\n+\n+=== New script system ===\n+Since all witness programs begin with a version byte, and programs with unknown versions are always considered as anyone-can-spend script, it is possible to introduce any new script system with a soft fork. The witness as a structure is not restricted by any existing script semantics and constraints, the 520-byte push limit in particular, and therefore allows arbitrarily large scripts and signatures.",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 213,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
      "in_reply_to_id": null,
      "user": {
        "login": "afk11",
        "id": 5617245,
        "node_id": "MDQ6VXNlcjU2MTcyNDU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afk11",
        "html_url": "https://github.com/afk11",
        "followers_url": "https://api.github.com/users/afk11/followers",
        "following_url": "https://api.github.com/users/afk11/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/afk11/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/afk11/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
        "organizations_url": "https://api.github.com/users/afk11/orgs",
        "repos_url": "https://api.github.com/users/afk11/repos",
        "events_url": "https://api.github.com/users/afk11/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/afk11/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is 'anyone-can-spend script' a new term? I understand why, I just wonder if the term is too similar to ANYONECANPAY. We should define the term, or maybe reword to say unknown versions are simply not evaluated as anything other than pushdata, and won't be evaluated by the witness interpreter?\n",
      "created_at": "2015-12-24T14:52:44Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48417276",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48417276"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48419678",
      "pull_request_review_id": null,
      "id": 48419678,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE5Njc4",
      "diff_hunk": "@@ -0,0 +1,263 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a single push of 2 to 41 bytes gets a new special meaning. The byte vector pushed by it is called the \"witness program\".\n+** In case the scriptPubKey pushes a witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+* The first byte of a witness program is the \"version byte\", an unsigned integer.\n+** If the version byte is 0, the rest of the witness program is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the rest of the witness program must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the witness version byte is 2 or above, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x0076A914{20-byte-hash-value}88AC>\n+\n+The version byte 0x00 is removed. The rest of the witness program is deserialized and becomes:\n+\n+    DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+The script is executed with the data from witness\n+\n+    <signature> <pubkey> DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+Comparing with a P2PKH output, the witness program equivalent occupies 2 more bytes in the scriptPubKey, while moving the signature and public key from scriptSig to witness.\n+\n+=== Version 1 witness program ===\n+\n+The following example is an 1-of-2 multi-signature version 1 witness program.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x01{32-byte-hash-value}>\n+\n+The last item in the witness is popped off, hashed with SHA256, compared against the 32-byte-hash-value in scriptPubKey, and deserialized:\n+\n+    1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+The script is executed with the remaining data from witness:\n+\n+    0 <signature1> 1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+Since the actual program is larger than 40 bytes, it cannot be accommodated in a version 0 witness program. A version 1 witness program allows arbitrarily large script as the 520-byte push limit is bypassed.\n+\n+The scriptPubKey occupies 34 bytes, as opposed to 23 bytes of P2SH. The increased size improves security against possible collision attacks, as 2^80 work is not infeasible anymore (By the end of 2015, 2^84 hashes have been calculated in Bitcoin mining since the creation of Bitcoin). The spending script is same as the one for an equivalent P2SH output but is moved to witness.\n+\n+=== Witness program nested in Pay-to-Script-Hash ===\n+\n+The following example is the same 1-of-2 multi-signature version 1 witness program, but nested in a P2SH output.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    <0x2101{32-byte-hash-value}>\n+    scriptPubKey: HASH160 <20-byte-hash-value> EQUAL\n+\n+The only item in scriptSig is hashed with HASH160, compared against the 20-byte-hash-value in scriptPubKey, and interpreted as a single push of:\n+\n+    <0x01{32-byte-hash-value}>\n+\n+The version 1 witness program is then executed as described in the last example\n+\n+Comparing with the last example, the scriptPubKey is 11 bytes smaller (with reduced security) while witness is the same. However, it also requires 35 bytes in scriptSig, which is not prunable in transmission. Although a nested witness program is less efficient in many ways, its payment address is fully transparent and backward compatible for all Bitcoin reference client since version 0.6.0.\n+\n+=== Trust-free unconfirmed transaction dependency chain ===\n+Segregated witness fixes the problem of transaction malleability fundamentally, which enables the building of unconfirmed transaction dependency chains in a trust-free manner.\n+\n+Two parties, Alice and Bob, may agree to send certain amount of Bitcoin to a 2-of-2 multisig output (the \"funding transaction\"). Without signing the funding transaction, they may create another transaction, time-locked in the future, spending the 2-of-2 multisig output to third account(s) (the \"spending transaction\"). Alice and Bob will sign the spending transaction and exchange the signatures. After examining the signatures, they will sign and commit the funding transaction to the blockchain. Without further action, the spending transaction will be confirmed after the lock-time and release the funding according to the original contract. It also retains the flexibility of revoking the original contract before the lock-time, by another spending transaction with shorter lock-time, but only with mutual-agreement of both parties.\n+\n+Such setups is not possible with BIP62 as the malleability fix, since the spending transaction could not be created without both parties first signing the funding transaction. If Alice reveals the funding transaction signature before Bob does, Bob is able to lock up the funding indefinitely without ever signing the spending transaction.\n+\n+Unconfirmed transaction dependency chain is a fundamental building block of more sophisticated payment networks, such as duplex micropayment channel and the Lightning Network, which have the potential to greatly improve the scalability and efficiency of the Bitcoin system.\n+\n+== Future extensions ==\n+=== Compact fraud proof for SPV nodes ===\n+Bitcoin right now only has two real security models. A user either runs a full-node which validates every block with all rules in the system, or a SPV (Simple Payment Verification) client which only validates the headers as a proof of publication of some transactions. The Bitcoin whitepaper suggested that SPV nodes may accept alerts from full nodes when they detect an invalid block, prompting the SPV node to download the questioned blocks and transactions for validation. This approach, however, could become a DoS attack vector as there is virtually no cost to generate a false alarm. An alarm must come with a compact, yet deterministic fraud proof.\n+\n+In the current Bitcoin protocol, it is possible to generate compact fraud proof for almost all rules except a few:\n+\n+# It is not possible to proof a miner has introduced too many Bitcoins in the coinbase transaction outputs without showing the whole block itself and all input transactions.\n+# It is not possible to prove the violation of any block specific constraints, such as size and sigop limits, without showing the whole block (and all input transactions in the case of sigop limit)\n+# It is not possible to prove the spending of a non-existing input without showing all transaction IDs in the blockchain way back to the genesis block.\n+\n+It is possible to proof the first 2 types of fraud if a block is committed to a Merkle-sum-tree of the fee, size, and sigop count of each transaction. It is also possible to proof the last type of fraud if a block is committed to a Merkle tree with the originating block height and transaction index of all inputs. These commitments could be included in the extensible witness commitment through a soft fork and will be transparent to nodes that do not understand such new rules.\n+\n+=== New script system ===\n+Since all witness programs begin with a version byte, and programs with unknown versions are always considered as anyone-can-spend script, it is possible to introduce any new script system with a soft fork. The witness as a structure is not restricted by any existing script semantics and constraints, the 520-byte push limit in particular, and therefore allows arbitrarily large scripts and signatures.",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 213,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
      "in_reply_to_id": null,
      "user": {
        "login": "jl2012",
        "id": 8403418,
        "node_id": "MDQ6VXNlcjg0MDM0MTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jl2012",
        "html_url": "https://github.com/jl2012",
        "followers_url": "https://api.github.com/users/jl2012/followers",
        "following_url": "https://api.github.com/users/jl2012/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jl2012/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jl2012/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
        "organizations_url": "https://api.github.com/users/jl2012/orgs",
        "repos_url": "https://api.github.com/users/jl2012/repos",
        "events_url": "https://api.github.com/users/jl2012/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jl2012/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's not new: https://en.bitcoin.it/wiki/Script#Anyone-Can-Spend_Outputs\n",
      "created_at": "2015-12-24T16:05:50Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48419678",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48419678"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48491565",
      "pull_request_review_id": null,
      "id": 48491565,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkxNTY1",
      "diff_hunk": "@@ -0,0 +1,263 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a single push of 2 to 41 bytes gets a new special meaning. The byte vector pushed by it is called the \"witness program\".\n+** In case the scriptPubKey pushes a witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+* The first byte of a witness program is the \"version byte\", an unsigned integer.\n+** If the version byte is 0, the rest of the witness program is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the rest of the witness program must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the witness version byte is 2 or above, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x0076A914{20-byte-hash-value}88AC>\n+\n+The version byte 0x00 is removed. The rest of the witness program is deserialized and becomes:\n+\n+    DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+The script is executed with the data from witness\n+\n+    <signature> <pubkey> DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+Comparing with a P2PKH output, the witness program equivalent occupies 2 more bytes in the scriptPubKey, while moving the signature and public key from scriptSig to witness.\n+\n+=== Version 1 witness program ===\n+\n+The following example is an 1-of-2 multi-signature version 1 witness program.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x01{32-byte-hash-value}>\n+\n+The last item in the witness is popped off, hashed with SHA256, compared against the 32-byte-hash-value in scriptPubKey, and deserialized:\n+\n+    1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+The script is executed with the remaining data from witness:\n+\n+    0 <signature1> 1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+Since the actual program is larger than 40 bytes, it cannot be accommodated in a version 0 witness program. A version 1 witness program allows arbitrarily large script as the 520-byte push limit is bypassed.\n+\n+The scriptPubKey occupies 34 bytes, as opposed to 23 bytes of P2SH. The increased size improves security against possible collision attacks, as 2^80 work is not infeasible anymore (By the end of 2015, 2^84 hashes have been calculated in Bitcoin mining since the creation of Bitcoin). The spending script is same as the one for an equivalent P2SH output but is moved to witness.\n+\n+=== Witness program nested in Pay-to-Script-Hash ===\n+\n+The following example is the same 1-of-2 multi-signature version 1 witness program, but nested in a P2SH output.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    <0x2101{32-byte-hash-value}>\n+    scriptPubKey: HASH160 <20-byte-hash-value> EQUAL\n+\n+The only item in scriptSig is hashed with HASH160, compared against the 20-byte-hash-value in scriptPubKey, and interpreted as a single push of:\n+\n+    <0x01{32-byte-hash-value}>\n+\n+The version 1 witness program is then executed as described in the last example\n+\n+Comparing with the last example, the scriptPubKey is 11 bytes smaller (with reduced security) while witness is the same. However, it also requires 35 bytes in scriptSig, which is not prunable in transmission. Although a nested witness program is less efficient in many ways, its payment address is fully transparent and backward compatible for all Bitcoin reference client since version 0.6.0.\n+\n+=== Trust-free unconfirmed transaction dependency chain ===\n+Segregated witness fixes the problem of transaction malleability fundamentally, which enables the building of unconfirmed transaction dependency chains in a trust-free manner.\n+\n+Two parties, Alice and Bob, may agree to send certain amount of Bitcoin to a 2-of-2 multisig output (the \"funding transaction\"). Without signing the funding transaction, they may create another transaction, time-locked in the future, spending the 2-of-2 multisig output to third account(s) (the \"spending transaction\"). Alice and Bob will sign the spending transaction and exchange the signatures. After examining the signatures, they will sign and commit the funding transaction to the blockchain. Without further action, the spending transaction will be confirmed after the lock-time and release the funding according to the original contract. It also retains the flexibility of revoking the original contract before the lock-time, by another spending transaction with shorter lock-time, but only with mutual-agreement of both parties.\n+\n+Such setups is not possible with BIP62 as the malleability fix, since the spending transaction could not be created without both parties first signing the funding transaction. If Alice reveals the funding transaction signature before Bob does, Bob is able to lock up the funding indefinitely without ever signing the spending transaction.\n+\n+Unconfirmed transaction dependency chain is a fundamental building block of more sophisticated payment networks, such as duplex micropayment channel and the Lightning Network, which have the potential to greatly improve the scalability and efficiency of the Bitcoin system.\n+\n+== Future extensions ==\n+=== Compact fraud proof for SPV nodes ===\n+Bitcoin right now only has two real security models. A user either runs a full-node which validates every block with all rules in the system, or a SPV (Simple Payment Verification) client which only validates the headers as a proof of publication of some transactions. The Bitcoin whitepaper suggested that SPV nodes may accept alerts from full nodes when they detect an invalid block, prompting the SPV node to download the questioned blocks and transactions for validation. This approach, however, could become a DoS attack vector as there is virtually no cost to generate a false alarm. An alarm must come with a compact, yet deterministic fraud proof.\n+\n+In the current Bitcoin protocol, it is possible to generate compact fraud proof for almost all rules except a few:\n+\n+# It is not possible to proof a miner has introduced too many Bitcoins in the coinbase transaction outputs without showing the whole block itself and all input transactions.\n+# It is not possible to prove the violation of any block specific constraints, such as size and sigop limits, without showing the whole block (and all input transactions in the case of sigop limit)\n+# It is not possible to prove the spending of a non-existing input without showing all transaction IDs in the blockchain way back to the genesis block.\n+\n+It is possible to proof the first 2 types of fraud if a block is committed to a Merkle-sum-tree of the fee, size, and sigop count of each transaction. It is also possible to proof the last type of fraud if a block is committed to a Merkle tree with the originating block height and transaction index of all inputs. These commitments could be included in the extensible witness commitment through a soft fork and will be transparent to nodes that do not understand such new rules.\n+\n+=== New script system ===\n+Since all witness programs begin with a version byte, and programs with unknown versions are always considered as anyone-can-spend script, it is possible to introduce any new script system with a soft fork. The witness as a structure is not restricted by any existing script semantics and constraints, the 520-byte push limit in particular, and therefore allows arbitrarily large scripts and signatures.\n+\n+Examples of new script system include Schnorr signatures which reduce the size of multisig transactions dramatically, Lamport signature which is quantum computing resistance, and Merklized abstract syntax trees which allow very compact witness for conditional scripts with extreme complexity.\n+\n+The 41-byte limitation for witness programme could be easily extended through a soft fork in case a stronger hash function is needed in the future. The version byte is also expandable by introducing a secondary version byte for some specific primary version values.\n+\n+=== Per-input lock-time and relative-lock-time ===\n+Currently there is only one nLockTime field in a transaction and all inputs must share the same value. BIP68 enables per-input relative-lock-time using the nSequence field, however, with a limited lock-time period and resolution.\n+\n+With a soft fork, it is possible to introduce a separate witness structure to allow per-input lock-time and relative-lock-time, and a new script system that could sign and manipulate the new data (like BIP65 and BIP112).\n+\n+== Backward compatibility ==\n+As a soft fork, older software will continue to operate without modification.  Non-upgraded nodes, however, will not see nor validate the witness data and will consider all witness programs as anyone-can-spend scripts (except a few edge cases in version 0 witness programs which are provably unspendable with original script semantics). Wallets should always be wary of anyone-can-spend scripts and treat them with suspicion. Non-upgraded nodes are strongly encouraged to upgrade in order to take advantage of the new features.\n+\n+=== Version 0 witness programs ===",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 227,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
      "in_reply_to_id": null,
      "user": {
        "login": "morcos",
        "id": 4360349,
        "node_id": "MDQ6VXNlcjQzNjAzNDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/morcos",
        "html_url": "https://github.com/morcos",
        "followers_url": "https://api.github.com/users/morcos/followers",
        "following_url": "https://api.github.com/users/morcos/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/morcos/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/morcos/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
        "organizations_url": "https://api.github.com/users/morcos/orgs",
        "repos_url": "https://api.github.com/users/morcos/repos",
        "events_url": "https://api.github.com/users/morcos/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/morcos/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This was confusing to me.  You're not talking about Version 0 and Version 1 witness programs here are you?  Aren't you just talking about whether or not the witness program is also embedded in a P2SH regardless of what version witness it is?\n",
      "created_at": "2015-12-28T17:04:30Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48491565",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48491565"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48491930",
      "pull_request_review_id": null,
      "id": 48491930,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkxOTMw",
      "diff_hunk": "@@ -0,0 +1,263 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a single push of 2 to 41 bytes gets a new special meaning. The byte vector pushed by it is called the \"witness program\".\n+** In case the scriptPubKey pushes a witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+* The first byte of a witness program is the \"version byte\", an unsigned integer.\n+** If the version byte is 0, the rest of the witness program is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the rest of the witness program must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the witness version byte is 2 or above, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x0076A914{20-byte-hash-value}88AC>\n+\n+The version byte 0x00 is removed. The rest of the witness program is deserialized and becomes:\n+\n+    DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+The script is executed with the data from witness\n+\n+    <signature> <pubkey> DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+Comparing with a P2PKH output, the witness program equivalent occupies 2 more bytes in the scriptPubKey, while moving the signature and public key from scriptSig to witness.\n+\n+=== Version 1 witness program ===\n+\n+The following example is an 1-of-2 multi-signature version 1 witness program.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x01{32-byte-hash-value}>\n+\n+The last item in the witness is popped off, hashed with SHA256, compared against the 32-byte-hash-value in scriptPubKey, and deserialized:\n+\n+    1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+The script is executed with the remaining data from witness:\n+\n+    0 <signature1> 1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+Since the actual program is larger than 40 bytes, it cannot be accommodated in a version 0 witness program. A version 1 witness program allows arbitrarily large script as the 520-byte push limit is bypassed.\n+\n+The scriptPubKey occupies 34 bytes, as opposed to 23 bytes of P2SH. The increased size improves security against possible collision attacks, as 2^80 work is not infeasible anymore (By the end of 2015, 2^84 hashes have been calculated in Bitcoin mining since the creation of Bitcoin). The spending script is same as the one for an equivalent P2SH output but is moved to witness.\n+\n+=== Witness program nested in Pay-to-Script-Hash ===\n+\n+The following example is the same 1-of-2 multi-signature version 1 witness program, but nested in a P2SH output.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    <0x2101{32-byte-hash-value}>\n+    scriptPubKey: HASH160 <20-byte-hash-value> EQUAL\n+\n+The only item in scriptSig is hashed with HASH160, compared against the 20-byte-hash-value in scriptPubKey, and interpreted as a single push of:\n+\n+    <0x01{32-byte-hash-value}>\n+\n+The version 1 witness program is then executed as described in the last example\n+\n+Comparing with the last example, the scriptPubKey is 11 bytes smaller (with reduced security) while witness is the same. However, it also requires 35 bytes in scriptSig, which is not prunable in transmission. Although a nested witness program is less efficient in many ways, its payment address is fully transparent and backward compatible for all Bitcoin reference client since version 0.6.0.\n+\n+=== Trust-free unconfirmed transaction dependency chain ===\n+Segregated witness fixes the problem of transaction malleability fundamentally, which enables the building of unconfirmed transaction dependency chains in a trust-free manner.\n+\n+Two parties, Alice and Bob, may agree to send certain amount of Bitcoin to a 2-of-2 multisig output (the \"funding transaction\"). Without signing the funding transaction, they may create another transaction, time-locked in the future, spending the 2-of-2 multisig output to third account(s) (the \"spending transaction\"). Alice and Bob will sign the spending transaction and exchange the signatures. After examining the signatures, they will sign and commit the funding transaction to the blockchain. Without further action, the spending transaction will be confirmed after the lock-time and release the funding according to the original contract. It also retains the flexibility of revoking the original contract before the lock-time, by another spending transaction with shorter lock-time, but only with mutual-agreement of both parties.\n+\n+Such setups is not possible with BIP62 as the malleability fix, since the spending transaction could not be created without both parties first signing the funding transaction. If Alice reveals the funding transaction signature before Bob does, Bob is able to lock up the funding indefinitely without ever signing the spending transaction.\n+\n+Unconfirmed transaction dependency chain is a fundamental building block of more sophisticated payment networks, such as duplex micropayment channel and the Lightning Network, which have the potential to greatly improve the scalability and efficiency of the Bitcoin system.\n+\n+== Future extensions ==\n+=== Compact fraud proof for SPV nodes ===\n+Bitcoin right now only has two real security models. A user either runs a full-node which validates every block with all rules in the system, or a SPV (Simple Payment Verification) client which only validates the headers as a proof of publication of some transactions. The Bitcoin whitepaper suggested that SPV nodes may accept alerts from full nodes when they detect an invalid block, prompting the SPV node to download the questioned blocks and transactions for validation. This approach, however, could become a DoS attack vector as there is virtually no cost to generate a false alarm. An alarm must come with a compact, yet deterministic fraud proof.\n+\n+In the current Bitcoin protocol, it is possible to generate compact fraud proof for almost all rules except a few:\n+\n+# It is not possible to proof a miner has introduced too many Bitcoins in the coinbase transaction outputs without showing the whole block itself and all input transactions.\n+# It is not possible to prove the violation of any block specific constraints, such as size and sigop limits, without showing the whole block (and all input transactions in the case of sigop limit)\n+# It is not possible to prove the spending of a non-existing input without showing all transaction IDs in the blockchain way back to the genesis block.\n+\n+It is possible to proof the first 2 types of fraud if a block is committed to a Merkle-sum-tree of the fee, size, and sigop count of each transaction. It is also possible to proof the last type of fraud if a block is committed to a Merkle tree with the originating block height and transaction index of all inputs. These commitments could be included in the extensible witness commitment through a soft fork and will be transparent to nodes that do not understand such new rules.\n+\n+=== New script system ===\n+Since all witness programs begin with a version byte, and programs with unknown versions are always considered as anyone-can-spend script, it is possible to introduce any new script system with a soft fork. The witness as a structure is not restricted by any existing script semantics and constraints, the 520-byte push limit in particular, and therefore allows arbitrarily large scripts and signatures.\n+\n+Examples of new script system include Schnorr signatures which reduce the size of multisig transactions dramatically, Lamport signature which is quantum computing resistance, and Merklized abstract syntax trees which allow very compact witness for conditional scripts with extreme complexity.\n+\n+The 41-byte limitation for witness programme could be easily extended through a soft fork in case a stronger hash function is needed in the future. The version byte is also expandable by introducing a secondary version byte for some specific primary version values.\n+\n+=== Per-input lock-time and relative-lock-time ===\n+Currently there is only one nLockTime field in a transaction and all inputs must share the same value. BIP68 enables per-input relative-lock-time using the nSequence field, however, with a limited lock-time period and resolution.\n+\n+With a soft fork, it is possible to introduce a separate witness structure to allow per-input lock-time and relative-lock-time, and a new script system that could sign and manipulate the new data (like BIP65 and BIP112).\n+\n+== Backward compatibility ==\n+As a soft fork, older software will continue to operate without modification.  Non-upgraded nodes, however, will not see nor validate the witness data and will consider all witness programs as anyone-can-spend scripts (except a few edge cases in version 0 witness programs which are provably unspendable with original script semantics). Wallets should always be wary of anyone-can-spend scripts and treat them with suspicion. Non-upgraded nodes are strongly encouraged to upgrade in order to take advantage of the new features.\n+\n+=== Version 0 witness programs ===",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 227,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
      "in_reply_to_id": null,
      "user": {
        "login": "jl2012",
        "id": 8403418,
        "node_id": "MDQ6VXNlcjg0MDM0MTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jl2012",
        "html_url": "https://github.com/jl2012",
        "followers_url": "https://api.github.com/users/jl2012/followers",
        "following_url": "https://api.github.com/users/jl2012/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jl2012/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jl2012/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
        "organizations_url": "https://api.github.com/users/jl2012/orgs",
        "repos_url": "https://api.github.com/users/jl2012/repos",
        "events_url": "https://api.github.com/users/jl2012/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jl2012/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yeah, the description is somewhat inaccurate. I'll edit it\n",
      "created_at": "2015-12-28T17:09:47Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48491930",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48491930"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48680261",
      "pull_request_review_id": null,
      "id": 48680261,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMjYx",
      "diff_hunk": "@@ -0,0 +1,263 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a single push of 2 to 41 bytes gets a new special meaning. The byte vector pushed by it is called the \"witness program\".",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 92,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
      "in_reply_to_id": null,
      "user": {
        "login": "morcos",
        "id": 4360349,
        "node_id": "MDQ6VXNlcjQzNjAzNDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/morcos",
        "html_url": "https://github.com/morcos",
        "followers_url": "https://api.github.com/users/morcos/followers",
        "following_url": "https://api.github.com/users/morcos/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/morcos/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/morcos/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
        "organizations_url": "https://api.github.com/users/morcos/orgs",
        "repos_url": "https://api.github.com/users/morcos/repos",
        "events_url": "https://api.github.com/users/morcos/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/morcos/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "not a single push anymore\n",
      "created_at": "2016-01-01T20:51:05Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48680261",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48680261"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48680265",
      "pull_request_review_id": null,
      "id": 48680265,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMjY1",
      "diff_hunk": "@@ -0,0 +1,263 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a single push of 2 to 41 bytes gets a new special meaning. The byte vector pushed by it is called the \"witness program\".\n+** In case the scriptPubKey pushes a witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+* The first byte of a witness program is the \"version byte\", an unsigned integer.\n+** If the version byte is 0, the rest of the witness program is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the rest of the witness program must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the witness version byte is 2 or above, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: <0x0076A914{20-byte-hash-value}88AC>",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": null,
      "original_position": 143,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "894d8ac1cb8d2717b865d36b342f58fe7253a2c0",
      "in_reply_to_id": null,
      "user": {
        "login": "morcos",
        "id": 4360349,
        "node_id": "MDQ6VXNlcjQzNjAzNDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/morcos",
        "html_url": "https://github.com/morcos",
        "followers_url": "https://api.github.com/users/morcos/followers",
        "following_url": "https://api.github.com/users/morcos/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/morcos/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/morcos/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
        "organizations_url": "https://api.github.com/users/morcos/orgs",
        "repos_url": "https://api.github.com/users/morcos/repos",
        "events_url": "https://api.github.com/users/morcos/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/morcos/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "you need <0x001976A914{20-byte-hash-value}88AC>\n",
      "created_at": "2016-01-01T20:52:01Z",
      "updated_at": "2016-01-02T01:43:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r48680265",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/48680265"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49077429",
      "pull_request_review_id": null,
      "id": 49077429,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDc3NDI5",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a 1-byte push opcode (for 0 to 16) followed by a data push between 2 and 32 bytes gets a new special meaning. The value of the first push is called the \"version byte\". The following byte vector pushed is called the \"witness program\".\n+** In case the scriptPubKey pushes a version byte and witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a version byte and witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+** If the version byte is 0, the WP is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the WP must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 2 to 16, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_0 <0x76A914{20-byte-hash-value}88AC>\n+\n+The OP_0 indicates the following push is a version 0 witness program. The witness program is deserialized and becomes:\n+\n+    DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+The script is executed with the data from witness\n+\n+    <signature> <pubkey> DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+Comparing with a P2PKH output, the witness program equivalent occupies 2 more bytes in the scriptPubKey, while moving the signature and public key from scriptSig to witness.\n+\n+=== Version 1 witness program ===\n+\n+The following example is an 1-of-2 multi-signature version 1 witness program.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_1 <0x{32-byte-hash-value}>\n+\n+The OP_1 in scriptPubKey indicates the following push is a version 1 witness program. The last item in the witness is popped off, hashed with SHA256, compared against the 32-byte-hash-value in scriptPubKey, and deserialized:\n+\n+    1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+The script is executed with the remaining data from witness:\n+\n+    0 <signature1> 1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": 168,
      "original_position": 168,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "in_reply_to_id": null,
      "user": {
        "login": "FelixWeis",
        "id": 551068,
        "node_id": "MDQ6VXNlcjU1MTA2OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/551068?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/FelixWeis",
        "html_url": "https://github.com/FelixWeis",
        "followers_url": "https://api.github.com/users/FelixWeis/followers",
        "following_url": "https://api.github.com/users/FelixWeis/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/FelixWeis/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/FelixWeis/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/FelixWeis/subscriptions",
        "organizations_url": "https://api.github.com/users/FelixWeis/orgs",
        "repos_url": "https://api.github.com/users/FelixWeis/repos",
        "events_url": "https://api.github.com/users/FelixWeis/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/FelixWeis/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The segwit update seems like the perfect moment to get rid of that CHECKMULTISIG bug where one item too many is popped off the stack. Although probably should be done in #270.\n",
      "created_at": "2016-01-07T14:27:22Z",
      "updated_at": "2016-01-07T14:27:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r49077429",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49077429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49083466",
      "pull_request_review_id": null,
      "id": 49083466,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgzNDY2",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a 1-byte push opcode (for 0 to 16) followed by a data push between 2 and 32 bytes gets a new special meaning. The value of the first push is called the \"version byte\". The following byte vector pushed is called the \"witness program\".\n+** In case the scriptPubKey pushes a version byte and witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a version byte and witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+** If the version byte is 0, the WP is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the WP must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 2 to 16, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_0 <0x76A914{20-byte-hash-value}88AC>\n+\n+The OP_0 indicates the following push is a version 0 witness program. The witness program is deserialized and becomes:\n+\n+    DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+The script is executed with the data from witness\n+\n+    <signature> <pubkey> DUP HASH160 <20byte-hash-value> EQUALVERIFY CHECKSIG\n+\n+Comparing with a P2PKH output, the witness program equivalent occupies 2 more bytes in the scriptPubKey, while moving the signature and public key from scriptSig to witness.\n+\n+=== Version 1 witness program ===\n+\n+The following example is an 1-of-2 multi-signature version 1 witness program.\n+\n+    witness:      0 <signature1> <0x5121{33-byte-pubkey1}21{33-byte-pubkey2}52AE>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_1 <0x{32-byte-hash-value}>\n+\n+The OP_1 in scriptPubKey indicates the following push is a version 1 witness program. The last item in the witness is popped off, hashed with SHA256, compared against the 32-byte-hash-value in scriptPubKey, and deserialized:\n+\n+    1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG\n+\n+The script is executed with the remaining data from witness:\n+\n+    0 <signature1> 1 <33-byte-pubkey1> <33-byte-pubkey2> 2 CHECKMULTISIG",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": 168,
      "original_position": 168,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No bikeshedding about what changes to make, please :(\n\nWe have script versions now, so we do not need to fix all inconveniences at\nonce.\n\nThere are two exceptions to this self-imposed rule:\n- Changing the sighashing to not be O(n^2), as it wouldn't be a bugfix to a\n  worst-case scenario if it's optional for an attacker.\n- Amount signing, as I didn't expect that people would accept any sighash\n  change proposal that did not include this...\n",
      "created_at": "2016-01-07T15:22:51Z",
      "updated_at": "2016-01-07T15:22:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r49083466",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49083466"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 168,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49123041",
      "pull_request_review_id": null,
      "id": 49123041,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDQx",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a 1-byte push opcode (for 0 to 16) followed by a data push between 2 and 32 bytes gets a new special meaning. The value of the first push is called the \"version byte\". The following byte vector pushed is called the \"witness program\".\n+** In case the scriptPubKey pushes a version byte and witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a version byte and witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+** If the version byte is 0, the WP is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the WP must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 2 to 16, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_0 <0x76A914{20-byte-hash-value}88AC>",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": 142,
      "original_position": 142,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "in_reply_to_id": null,
      "user": {
        "login": "jonasschnelli",
        "id": 178464,
        "node_id": "MDQ6VXNlcjE3ODQ2NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasschnelli",
        "html_url": "https://github.com/jonasschnelli",
        "followers_url": "https://api.github.com/users/jonasschnelli/followers",
        "following_url": "https://api.github.com/users/jonasschnelli/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasschnelli/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasschnelli/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
        "repos_url": "https://api.github.com/users/jonasschnelli/repos",
        "events_url": "https://api.github.com/users/jonasschnelli/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: use `OP_0 <DUP HASH160 {20-byte-hash-value} EQUALVERIFY CHECKSIG>`?\n",
      "created_at": "2016-01-07T20:42:05Z",
      "updated_at": "2016-01-07T20:42:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r49123041",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49123041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49123197",
      "pull_request_review_id": null,
      "id": 49123197,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMTk3",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a 1-byte push opcode (for 0 to 16) followed by a data push between 2 and 32 bytes gets a new special meaning. The value of the first push is called the \"version byte\". The following byte vector pushed is called the \"witness program\".\n+** In case the scriptPubKey pushes a version byte and witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a version byte and witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+** If the version byte is 0, the WP is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the WP must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 2 to 16, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_0 <0x76A914{20-byte-hash-value}88AC>",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": 142,
      "original_position": 142,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why? Waste of space.\n",
      "created_at": "2016-01-07T20:43:42Z",
      "updated_at": "2016-01-07T20:43:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r49123197",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49123197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49123287",
      "pull_request_review_id": null,
      "id": 49123287,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjg3",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a 1-byte push opcode (for 0 to 16) followed by a data push between 2 and 32 bytes gets a new special meaning. The value of the first push is called the \"version byte\". The following byte vector pushed is called the \"witness program\".\n+** In case the scriptPubKey pushes a version byte and witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a version byte and witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+** If the version byte is 0, the WP is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the WP must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 2 to 16, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_0 <0x76A914{20-byte-hash-value}88AC>",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": 142,
      "original_position": 142,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oops, never mind.\n",
      "created_at": "2016-01-07T20:44:32Z",
      "updated_at": "2016-01-07T20:44:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r49123287",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49123287"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49123884",
      "pull_request_review_id": null,
      "id": 49123884,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzODg0",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a 1-byte push opcode (for 0 to 16) followed by a data push between 2 and 32 bytes gets a new special meaning. The value of the first push is called the \"version byte\". The following byte vector pushed is called the \"witness program\".\n+** In case the scriptPubKey pushes a version byte and witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a version byte and witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+** If the version byte is 0, the WP is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the WP must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 2 to 16, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_0 <0x76A914{20-byte-hash-value}88AC>",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": 142,
      "original_position": 142,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "in_reply_to_id": null,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@jonasschnelli Isn't the deserialized format below?\n",
      "created_at": "2016-01-07T20:49:46Z",
      "updated_at": "2016-01-07T20:49:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r49123884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49123884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49159443",
      "pull_request_review_id": null,
      "id": 49159443,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTU5NDQz",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+<pre>\n+  BIP: x\n+  Title: Segregated Witness (Consensus layer)\n+  Author: Eric Lombrozo <elombrozo@gmail.com>\n+          Johnson Lau <jl2012@xbt.hk>\n+          Pieter Wuille <pieter.wuille@gmail.com>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2015-12-21\n+</pre>\n+\n+==Abstract==\n+\n+This BIP defines a new structure called a \"witness\" that is committed to blocks separately from the transaction merkle tree. This structure contains data required to check transaction validity but not required to determine transaction effects. In particular, scripts and signatures are moved into this new structure.\n+\n+The witness is committed in a tree that is nested into the block's existing merkle root via the coinbase transaction for the purpose of making this BIP soft fork compatible. A future hard fork can place this tree in its own branch.\n+\n+==Motivation==\n+\n+The entirety of the transaction's effects are determined by output consumption (spends) and new output creation. Other transaction data, and signatures in particular, are only required to validate the blockchain state, not to determine it.\n+\n+By removing this data from the transaction structure committed to the transaction merkle tree, several problems are fixed:\n+\n+# '''Nonintentional malleability becomes impossible'''. Since signature data is no longer part of the transaction hash, changes to how the transaction was authorized is no longer relevant to transaction identification. As a solution of transaction malleability, this is superior to the canonical signature approach (BIP62):\n+#* It prevents involuntary transaction malleability for any type of scripts, as long as all inputs are signed (with at least one CHECKSIG or CHECKMULTISIG operation)\n+#* In the case of an m-of-n CHECKMULTISIG script, a transaction is malleable only with agreement of m private key holders (as opposed to only 1 private key holder with BIP62)\n+#* It prevents involuntary transaction malleability due to unknown ECDSA signature malleability\n+#* It allows creation of unconfirmed transaction dependency chains without counterparty risk, an important feature for offchain protocols such as the Lightning Network\n+# '''Transmission of signature data becomes optional'''. It is needed only if a peer is trying to validate a transaction instead of just checking its existence. This reduces the size of SPV proofs and potentially improves the privacy of SPV clients as they can download more transactions using the same bandwidth.\n+# '''Some constraints could be bypassed with a soft fork''' by moving part of the transaction data to a structure unknown to current protocol, for example:\n+#* Size of witness could be ignored / discounted when calculating the block size, effectively increasing the block size to some extent\n+#* Hard coded constants, such as maximum data push size (520 bytes) or sigops limit could be reevaluated or removed\n+#* New script system could be introduced without any limitation from the existing script semantic\n+# '''Additional data required for fraud proofs can be added to witness'''. Extra data can be committed that allows short proofs of block invalidity that SPV nodes can quickly verify.\n+#* Backlinks for the outputs spent by the transaction's inputs can be provided. These backlinks consist of a block hash and an offset that thin clients can easily query and check to verify that the outputs exist.\n+#* Sum trees for transaction inputs and outputs can be committed making it possible to construct short proofs that no new coins are created in any noncoinbase transaction and that the miner does not add excessive fees to the coinbase transaction. \n+\n+==Specification==\n+\n+=== Commitment structure ===\n+\n+!!!DRAFT ONLY!!!\n+\n+A new block rule is added which requires a commitment to the witness hashes in the coinbase (or an OP_RETURN output of a specific transaction, or somewhere else)\n+\n+(Hardfork after x year to move the commitment to block header?)\n+\n+Witness hash is the double SHA256 of a transaction including witnesses: http://blockhawk.net/diagrams/witnesstx.png. For the coinbase transaction, its witness hash is assumed to be 0x0000....0000.\n+\n+A witness root hash is calculated with all those witness hashes as leaves, in a way similar to the hashMerkleRoot in the block header.\n+\n+No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room from spam.\n+\n+==== Proposal 1: balance tree (the current implementation) ====\n+The commitment is a push of exactly 41 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 1 byte is the \"levels bytes\", describes the number of levels in a Merkle tree (0 to 32)\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array of 32 * levels bytes, and are assumed to be the Merkle path to connect the witness root hash to the commitment root hash.\n+\n+====Proposal 2: imbalance tree====\n+The commitment is a push of exactly 40 bytes:\n+*The first 4 bytes are commitment header: 0xaa21a9ed\n+*The next 4 bytes describe a nonce\n+*The next 32 bytes is a commitment root hash (not the witness root hash)\n+\n+Locator of the witness root hash is defined as:\n+\n+<pre>SHA256('WitnessV1\\x00\\x00\\x00\\x00\\x00\\x00\\x00' || nonce)</pre>\n+\n+The first levels bits of locator, interpreted in little endian, are assumed to be the position in the leaves of the Merkle tree where the witness root hash goes.\n+\n+The coinbase's input's witness must consist of a single byte array, which the size must be a multiple of 32 bytes but not bigger than 32*32 bytes. These are assumed to be the Merkle path to connect the witness root hash to the commitment root hash. Depth of the commitment is determined by the length of the path. If the depth of the tree is 0, the path should be represented by 0x00, and the witness root hash will be same as the commitment root hash.\n+\n+=== Block size limit ===\n+Blocks are currently limited to 1 MB total size. We change this restriction as follows:\n+\n+We define a base block size s<sub>b</sub> consisting of the existing header and transactions, a witness size s<sub>w</sub> consisting of only the size of the witness data, and a virtual block size s<sub>v</sub> = s<sub>b</sub> + s<sub>w</sub>/4.\n+\n+The new rule is s<sub>v</sub> <= 1 MB.\n+\n+=== Witness program ===\n+\n+* A scriptPubKey (or redeemScript as defined in BIP16/P2SH) that consists of a 1-byte push opcode (for 0 to 16) followed by a data push between 2 and 32 bytes gets a new special meaning. The value of the first push is called the \"version byte\". The following byte vector pushed is called the \"witness program\".\n+** In case the scriptPubKey pushes a version byte and witness program directly, the scriptSig must be exactly empty.\n+** In case the redeemScript pushes a version byte and witness program, the scriptSig must be exactly the single push of the redeemScript.\n+\n+** If the version byte is 0, the WP is the actual script.\n+*** The script is executed after normal script evaluation but with data from the witness rather than the scriptSig.\n+*** The program must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 1, the WP must be 32 bytes, as a SHA256 hash of the actual script.\n+*** The witness must consist of an input stack to feed to the program, followed by the serialized program.\n+*** The serialized program is popped off the initial witness stack. Hash of the serialized program must match the hash pushed in the witness program.\n+*** The serialized program is deserialized, and executed after normal script evaluation with the remaining witness stack.\n+*** The script must not fail, and result in exactly a single TRUE on the stack.\n+** If the version byte is 2 to 16, no further interpretation of the witness program or witness happens.\n+\n+=== Other consensus critical constraints ===\n+\n+== Block size analysis ==\n+WORK IN PROGRESS\n+\n+Definitions:\n+<pre>\n+ Core block size (CBS): The block size as seen by a non-upgrading full node\n+ Witness size (WS): The total size of witness data in a block\n+ Total block size (TBS): CBS + WS\n+ Witness discount (WD): A discount factor for witness data in VBS calculation (1 = no discount)\n+ Virtual block size (VBS): CBS + (WS * WD)\n+ Witness adoption (WA): Proportion (in size) of new format transactions among all transactions\n+ Prunable ratio (PR): Proportion of signature data size in a transaction\n+</pre>\n+\n+With some transformation it could be shown that:\n+<pre>\n+ TBS = CBS / (1 - WA * PR)\n+     = VBS / (1 - WA * PR * (1 - WD))\n+</pre>\n+\n+In order to keep the proposal as a soft fork, the CBS must not have a upper limit higher than 1MB.\n+\n+The PR heavily depends on the transaction script type and input-output ratio. For example, the PR of 1-in 2-out P2PKH and 1-in 1-out 2-of-2 multisig P2SH are about 47% and 72% respectively. According to the data presented by Pieter Wuille on 7 December 2015, the current average PR on the blockchain is about 60%.\n+\n+\n+\n+== Examples ==\n+\n+=== Version 0 witness program ===\n+\n+The following example is a version 0 witness program, equivalent to the existing Pay-to-Pubkey-Hash (P2PKH) output.\n+\n+    witness:      <signature> <pubkey>\n+    scriptSig:    (empty)\n+    scriptPubKey: OP_0 <0x76A914{20-byte-hash-value}88AC>",
      "path": "bip-codeshark-jl2012-segwit.mediawiki",
      "position": 142,
      "original_position": 142,
      "commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "original_commit_id": "90367c065a6d58a1548f690389e2a8b8bcb1d522",
      "in_reply_to_id": null,
      "user": {
        "login": "jl2012",
        "id": 8403418,
        "node_id": "MDQ6VXNlcjg0MDM0MTg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jl2012",
        "html_url": "https://github.com/jl2012",
        "followers_url": "https://api.github.com/users/jl2012/followers",
        "following_url": "https://api.github.com/users/jl2012/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jl2012/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jl2012/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
        "organizations_url": "https://api.github.com/users/jl2012/orgs",
        "repos_url": "https://api.github.com/users/jl2012/repos",
        "events_url": "https://api.github.com/users/jl2012/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jl2012/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's shown in the deserialized script\n",
      "created_at": "2016-01-08T05:29:33Z",
      "updated_at": "2016-01-08T05:29:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/265#discussion_r49159443",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/49159443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/265"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 142,
      "original_line": null,
      "side": "RIGHT"
    }
  ]
}