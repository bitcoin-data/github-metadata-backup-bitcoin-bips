{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/2004",
    "id": 2915677183,
    "node_id": "PR_kwDOAN28mc6tybP_",
    "html_url": "https://github.com/bitcoin/bips/pull/2004",
    "diff_url": "https://github.com/bitcoin/bips/pull/2004.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/2004.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2004",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/2004/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/2004/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/2004/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/9a47c29dd9e111d0d80641857accba0cc256aab1",
    "number": 2004,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "BIP: Chain Code Delegation for Private Collaborative Custody",
    "user": {
      "login": "jurvis",
      "id": 5944973,
      "node_id": "MDQ6VXNlcjU5NDQ5NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5944973?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jurvis",
      "html_url": "https://github.com/jurvis",
      "followers_url": "https://api.github.com/users/jurvis/followers",
      "following_url": "https://api.github.com/users/jurvis/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jurvis/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jurvis/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jurvis/subscriptions",
      "organizations_url": "https://api.github.com/users/jurvis/orgs",
      "repos_url": "https://api.github.com/users/jurvis/repos",
      "events_url": "https://api.github.com/users/jurvis/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jurvis/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "We propose a new BIP for Chain Code Delegation, a collaborative custody technique that involves privileged participants (delegatee) withholding BIP32 chain codes at key setup time from a delegator, and sharing only enough information for non‑privileged participants to provide their signature.\r\n\r\nFor non-blinded signing, the delegatee derives a per‑spend scalar tweak t from the (withheld) chain code, the delegator computes the child key (x+t, P+tG), and produces a standard signature over the transaction’s sighash. For blind signing, the nonce and challenge are blinded so the delegator returns a blind Schnorr signature that the counterparty unblinds; thanks to Schnorr’s linearity, the same tweak is incorporated without revealing the final message or linkable details (optionally with predicate proofs for policy).\r\n\r\nThis enables participants like collaborative custodians to co‑sign when needed, while avoiding the broad visibility that comes with holding an xpub.\r\n\r\nMore background and discussions can be found: https://delvingbitcoin.org/t/chain-code-delegation-private-access-control-for-bitcoin-keys/1837. \r\n\r\nThis is joint work with @jesseposner. Feedback appreciated! ",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      },
      {
        "id": 276738669,
        "node_id": "MDU6TGFiZWwyNzY3Mzg2Njk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/Needs%20number%20assignment",
        "name": "Needs number assignment",
        "color": "eb6420",
        "default": false
      }
    ],
    "created_at": "2025-10-15T03:28:50Z",
    "updated_at": "2025-11-30T23:39:17Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merged": false,
    "merge_commit_sha": "ddaf97ddf9beac6cad6b8a615fc7b2a13c2315dd",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "jurvis:master",
      "ref": "master",
      "sha": "9a47c29dd9e111d0d80641857accba0cc256aab1",
      "user": {
        "login": "jurvis",
        "id": 5944973,
        "node_id": "MDQ6VXNlcjU5NDQ5NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5944973?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jurvis",
        "html_url": "https://github.com/jurvis",
        "followers_url": "https://api.github.com/users/jurvis/followers",
        "following_url": "https://api.github.com/users/jurvis/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jurvis/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jurvis/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jurvis/subscriptions",
        "organizations_url": "https://api.github.com/users/jurvis/orgs",
        "repos_url": "https://api.github.com/users/jurvis/repos",
        "events_url": "https://api.github.com/users/jurvis/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jurvis/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 1073932771,
        "node_id": "R_kgDOQALp4w",
        "name": "bips",
        "full_name": "jurvis/bips",
        "owner": {
          "login": "jurvis",
          "id": 5944973,
          "node_id": "MDQ6VXNlcjU5NDQ5NzM=",
          "avatar_url": "https://avatars.githubusercontent.com/u/5944973?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/jurvis",
          "html_url": "https://github.com/jurvis",
          "followers_url": "https://api.github.com/users/jurvis/followers",
          "following_url": "https://api.github.com/users/jurvis/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/jurvis/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/jurvis/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/jurvis/subscriptions",
          "organizations_url": "https://api.github.com/users/jurvis/orgs",
          "repos_url": "https://api.github.com/users/jurvis/repos",
          "events_url": "https://api.github.com/users/jurvis/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/jurvis/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/jurvis/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/jurvis/bips",
        "archive_url": "https://api.github.com/repos/jurvis/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/jurvis/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/jurvis/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/jurvis/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/jurvis/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/jurvis/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/jurvis/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/jurvis/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/jurvis/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/jurvis/bips/contributors",
        "deployments_url": "https://api.github.com/repos/jurvis/bips/deployments",
        "downloads_url": "https://api.github.com/repos/jurvis/bips/downloads",
        "events_url": "https://api.github.com/repos/jurvis/bips/events",
        "forks_url": "https://api.github.com/repos/jurvis/bips/forks",
        "git_commits_url": "https://api.github.com/repos/jurvis/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/jurvis/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/jurvis/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/jurvis/bips.git",
        "issue_comment_url": "https://api.github.com/repos/jurvis/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/jurvis/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/jurvis/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/jurvis/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/jurvis/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/jurvis/bips/languages",
        "merges_url": "https://api.github.com/repos/jurvis/bips/merges",
        "milestones_url": "https://api.github.com/repos/jurvis/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/jurvis/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/jurvis/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/jurvis/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:jurvis/bips.git",
        "stargazers_url": "https://api.github.com/repos/jurvis/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/jurvis/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/jurvis/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/jurvis/bips/subscription",
        "tags_url": "https://api.github.com/repos/jurvis/bips/tags",
        "teams_url": "https://api.github.com/repos/jurvis/bips/teams",
        "trees_url": "https://api.github.com/repos/jurvis/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/jurvis/bips.git",
        "hooks_url": "https://api.github.com/repos/jurvis/bips/hooks",
        "svn_url": "https://github.com/jurvis/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 16710,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-11-30T23:37:51Z",
        "created_at": "2025-10-10T21:11:57Z",
        "updated_at": "2025-11-30T23:38:03Z",
        "allow_forking": true
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "1cf41308764916b04ae1a22f391831d6d2230b89",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5829,
        "stargazers_count": 10390,
        "watchers_count": 10390,
        "size": 18434,
        "default_branch": "master",
        "open_issues_count": 71,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-11-26T00:58:17Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2025-11-29T22:59:30Z",
        "allow_forking": true
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/2004"
      }
    },
    "author_association": "NONE",
    "draft": false,
    "additions": 2319,
    "deletions": 0,
    "changed_files": 19,
    "commits": 3,
    "review_comments": 5,
    "comments": 1
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDQyODNlM2VjNTc3NjY4YTA2ZWZiMTRhMWRiYzk2YzQ2ZTg0ZDdkOTY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4283e3ec577668a06efb14a1dbc96c46e84d7d96",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/4283e3ec577668a06efb14a1dbc96c46e84d7d96",
      "tree": {
        "sha": "990d9b20a9a91ce135365701458b918532b87f71",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/990d9b20a9a91ce135365701458b918532b87f71"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 990d9b20a9a91ce135365701458b918532b87f71\nparent 3d0bab3cc211be9d40c0029f62c7e4eebd27ea21\nauthor Jurvis Tan <jurvis@block.xyz> 1760479116 -0700\ncommitter Jurvis Tan <jurvis@block.xyz> 1760498430 -0700\n\nAdd Chaincode Delegation BIP\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEErPbwUu89PegMpABUmARyU2H5m5EFAmjvEv4ACgkQmARyU2H5\nm5G/HRAAsHTCboXcQ6vnc+Je6J07kFie7GI1e2xzvG+uMxd3ku2ApP+2SeyHU6Ij\nwYMRkSrfMtJxacSfsWaXdom332hawNjjFpnPzOm12tfIiQYJhjttwNjbuhMr5PZr\n+IOo2doxun0hoO4ZbUegUa/dL2YUq51h0uEX+pGllAwSAwFTzZjt5hcXDpgdMFTu\n3jG82B8m8Zql1Dx3aWcXvL39lddEvMyamMF5Qlw7ZfgUQLIjj0mS1w8bMwBmGRKe\nfRGqsWYoEGVEHrSdoc5dznz0qNoYNhby91x3bA8ravMcz3Y62k+vk4vCatMxKWyx\nGXaxpR0rMdz1AH6H4TrJ6IkEMU2E1Z9++0gAuaQ8dhn2/Oly2mxN/PQZ6MnmfbH1\nXgQijmFjIRzw9ZPuJVpLDdtDPiHpU/hVadIUywcZDGFn1hAZKXvmHXbYQlD7lvul\npY1U3QnQr9+ja5HgJ+J2ia9WdCzL5bdRCt88x2xL9K5A9FAwHwpleYcfwOaX6hJ9\nOxMLf0MD1LCKKlNGtDaPDGPQqy0M3DwLV+SH2iOhUxLMmLu7c1TibzbGNsjJLonx\n/jUqUvI2BzMYFaKdbNMkoRVCS5162cqXq4l17s0PBoT2QJ16evTy1MQApR0HBEjv\nly1x49XvaIEuO7EeoDLdpMwkouNQLf0LcArmO7EFmuDbCduCwUU=\n=V+FD\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/3d0bab3cc211be9d40c0029f62c7e4eebd27ea21",
          "sha": "3d0bab3cc211be9d40c0029f62c7e4eebd27ea21",
          "html_url": "https://github.com/bitcoin/bips/commit/3d0bab3cc211be9d40c0029f62c7e4eebd27ea21"
        }
      ],
      "message": "Add Chaincode Delegation BIP",
      "committer": {
        "name": "Jurvis Tan",
        "email": "jurvis@block.xyz",
        "date": "2025-10-15T03:20:30Z"
      },
      "author": {
        "name": "Jurvis Tan",
        "email": "jurvis@block.xyz",
        "date": "2025-10-14T21:58:36Z"
      },
      "sha": "4283e3ec577668a06efb14a1dbc96c46e84d7d96"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGVkYjQzNjBmYTcwZjIyMGNhMjIxZTc2NTQzMTdlNDM1Y2UzZjc5ZDQ",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/edb4360fa70f220ca221e7654317e435ce3f79d4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/edb4360fa70f220ca221e7654317e435ce3f79d4",
      "tree": {
        "sha": "bcfa1037d0d840e35a8d69eb97740e9a7ed5eb11",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/bcfa1037d0d840e35a8d69eb97740e9a7ed5eb11"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree bcfa1037d0d840e35a8d69eb97740e9a7ed5eb11\nparent 4283e3ec577668a06efb14a1dbc96c46e84d7d96\nauthor Jesse Posner <jesse.posner@gmail.com> 1760497255 -0700\ncommitter Jurvis Tan <jurvis@block.xyz> 1760498432 -0700\n\nUpdate license to BSD-3-Clause and expand blinded signing documentation\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEErPbwUu89PegMpABUmARyU2H5m5EFAmjvEwAACgkQmARyU2H5\nm5Epyw//cNYlQ1yQFfoRsI4B+pGNz9Z249wVsnIGGog7UOesRr2/RMPTHWdccOk1\nOLRlUgUuKrc8MqbMcAvJt2x/j4iEnG9oLMUVeQAunFYtFgw5qW22Tl1YpWToygB+\nGGJeGztESpBdDGqqCGHXke3w6wdOYcq68KxkvsxD/fuuJb9ETGho27rrGLa1IGyQ\n6ZxKIe3/4i4SMrwu2++BiUXv7IEru3fH79GiqPNAjA/FDGZckfnGwfnnRCUA19qh\nAfs4qBAU4gKciZCvTGVvc+nL5zZJ/PY//GYMHZJte5jgBMZRP9Fa5jXrdZbd1u7M\nfeHYNZL12hwWpFVUBFgsbVxWoX2vcjPAh/NhpSgmE9vHk6VpqTL8No6s9QU2h4BX\nnrCVJYh90j4dx/OzxUglooHr3xsbngKMa4busu3vARsyWSZzOvzhQBP5QF6pFzlK\nW5G8AhvPNq0x0emUL8/MLruPpIQv22jGJwEFpwlobOh0dkSsMnw7yZeMAo+dSAKi\nGk/eq7vAVT6cXc9UmVjbk9+pETi5yiBoZ5UzvMX/NUotpLs0bctAZGd20tsVZZ6t\nB6FSwuv+3iZYn+/R1StV/OQ9JibUn78uZ25hvRCzYCaFqxoHM66f6r4iM1qXc9RH\nd+/Xze09qoav0f+UKq7YQJTFnI6+Cu20KiWl3EX1ZDeYbTzWz74=\n=cnVL\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4283e3ec577668a06efb14a1dbc96c46e84d7d96",
          "sha": "4283e3ec577668a06efb14a1dbc96c46e84d7d96",
          "html_url": "https://github.com/bitcoin/bips/commit/4283e3ec577668a06efb14a1dbc96c46e84d7d96"
        }
      ],
      "message": "Update license to BSD-3-Clause and expand blinded signing documentation",
      "committer": {
        "name": "Jurvis Tan",
        "email": "jurvis@block.xyz",
        "date": "2025-10-15T03:20:32Z"
      },
      "author": {
        "name": "Jesse Posner",
        "email": "jesse.posner@gmail.com",
        "date": "2025-10-15T03:00:55Z"
      },
      "sha": "edb4360fa70f220ca221e7654317e435ce3f79d4"
    },
    {
      "event": "mentioned",
      "id": 20283733317,
      "node_id": "MEE_lADOAN28mc7RlPKJzwAAAAS5ATVF",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/20283733317",
      "actor": {
        "login": "jesseposner",
        "id": 12010116,
        "node_id": "MDQ6VXNlcjEyMDEwMTE2",
        "avatar_url": "https://avatars.githubusercontent.com/u/12010116?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jesseposner",
        "html_url": "https://github.com/jesseposner",
        "followers_url": "https://api.github.com/users/jesseposner/followers",
        "following_url": "https://api.github.com/users/jesseposner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jesseposner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jesseposner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jesseposner/subscriptions",
        "organizations_url": "https://api.github.com/users/jesseposner/orgs",
        "repos_url": "https://api.github.com/users/jesseposner/repos",
        "events_url": "https://api.github.com/users/jesseposner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jesseposner/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-15T03:29:59Z"
    },
    {
      "event": "subscribed",
      "id": 20283733333,
      "node_id": "SE_lADOAN28mc7RlPKJzwAAAAS5ATVV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/20283733333",
      "actor": {
        "login": "jesseposner",
        "id": 12010116,
        "node_id": "MDQ6VXNlcjEyMDEwMTE2",
        "avatar_url": "https://avatars.githubusercontent.com/u/12010116?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jesseposner",
        "html_url": "https://github.com/jesseposner",
        "followers_url": "https://api.github.com/users/jesseposner/followers",
        "following_url": "https://api.github.com/users/jesseposner/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jesseposner/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jesseposner/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jesseposner/subscriptions",
        "organizations_url": "https://api.github.com/users/jesseposner/orgs",
        "repos_url": "https://api.github.com/users/jesseposner/repos",
        "events_url": "https://api.github.com/users/jesseposner/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jesseposner/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-15T03:29:59Z"
    },
    {
      "event": "labeled",
      "id": 20301412896,
      "node_id": "LE_lADOAN28mc7RlPKJzwAAAAS6Dvog",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/20301412896",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-15T17:11:47Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "unsubscribed",
      "id": 20814966793,
      "node_id": "UE_lADOAN28mc7RlPKJzwAAAATYqzAJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/20814966793",
      "actor": {
        "login": "alex-fang",
        "id": 4167973,
        "node_id": "MDQ6VXNlcjQxNjc5NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4167973?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alex-fang",
        "html_url": "https://github.com/alex-fang",
        "followers_url": "https://api.github.com/users/alex-fang/followers",
        "following_url": "https://api.github.com/users/alex-fang/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/alex-fang/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/alex-fang/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/alex-fang/subscriptions",
        "organizations_url": "https://api.github.com/users/alex-fang/orgs",
        "repos_url": "https://api.github.com/users/alex-fang/repos",
        "events_url": "https://api.github.com/users/alex-fang/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/alex-fang/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-09T01:14:37Z"
    },
    {
      "event": "reviewed",
      "id": 3453253410,
      "node_id": "PRR_kwDOAN28mc7N1Hci",
      "url": null,
      "actor": null,
      "commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-12T12:44:25Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "arminsabouri",
        "id": 24356537,
        "node_id": "MDQ6VXNlcjI0MzU2NTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/24356537?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/arminsabouri",
        "html_url": "https://github.com/arminsabouri",
        "followers_url": "https://api.github.com/users/arminsabouri/followers",
        "following_url": "https://api.github.com/users/arminsabouri/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/arminsabouri/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/arminsabouri/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/arminsabouri/subscriptions",
        "organizations_url": "https://api.github.com/users/arminsabouri/orgs",
        "repos_url": "https://api.github.com/users/arminsabouri/repos",
        "events_url": "https://api.github.com/users/arminsabouri/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/arminsabouri/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2004#pullrequestreview-3453253410",
      "submitted_at": "2025-11-12T12:44:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2004"
    },
    {
      "event": "reviewed",
      "id": 3506500865,
      "node_id": "PRR_kwDOAN28mc7RAPUB",
      "url": null,
      "actor": null,
      "commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-25T19:51:32Z",
      "author_association": "MEMBER",
      "body": "Looks complete, labelling as needing number assignment.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2004#pullrequestreview-3506500865",
      "submitted_at": "2025-11-25T19:51:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/2004"
    },
    {
      "event": "labeled",
      "id": 21172893559,
      "node_id": "LE_lADOAN28mc7RlPKJzwAAAATuALd3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21172893559",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-25T19:51:41Z",
      "label": {
        "name": "Needs number assignment",
        "color": "eb6420"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDlhNDdjMjlkZDllMTExZDBkODA2NDE4NTdhY2NiYTBjYzI1NmFhYjE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9a47c29dd9e111d0d80641857accba0cc256aab1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/9a47c29dd9e111d0d80641857accba0cc256aab1",
      "tree": {
        "sha": "560b90844d03b9d792f33bbe3e391d77bcf5b628",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/560b90844d03b9d792f33bbe3e391d77bcf5b628"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 560b90844d03b9d792f33bbe3e391d77bcf5b628\nparent edb4360fa70f220ca221e7654317e435ce3f79d4\nauthor Jurvis Tan <hello@jurvis.co> 1764545854 -0700\ncommitter Jurvis Tan <hello@jurvis.co> 1764545854 -0700\n\nAddress initial PR comments\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEELI1qOhNXr7rL/wTrVrJJalxCpeAFAmks1T4ACgkQVrJJalxC\npeB/pxAAiHMVzH/8W1SssrHg0Vk32agxnjF+lzMK4H1IKMlbeqE5Jljs7nZKlK3j\nMzWBteXaba3jV8k8jXkYwUZh/mLkETyZogNG31XZiN+fxo8xNUW9/G1UWcntd3nq\ncRv53gljfBA83TO+HacCZ/L/8JQOS/qbi9/h/6SiWR2YKB0loBjKEIsnrctqtiWM\nyW5enntXWO0SrFhBsQMkn60+uJ2NkOfYga4DZyiS8wwsSyZ3vK0ihx4sWLkjW055\nkqlfY9uEcF203Hvt58dV1mxBA2RzeM3n10nKKR8yZ9LhxaomlcjvgFpoR3sHU/Tg\n62GHctVPk9cMguIu3MfXmhE0C7F0EyUalpZvZdvtSYpSFJSPqEfjrbNtOgfSN52b\nHogE68sl9fVQd1u40BCUBp2LrQgXlw+CPF60Hel8zpHSBFqvjgS5FoYCMKRZiwlm\nPUmZ7B6eeUu+IHeJZ0yZEaREbYVnoy4gmID+zb4Jmtr68j5srMo8swivjetSuCYW\n3hGA1JSoCs2O0pETFmMgn1k2kU9gIcg4RCNFMPnZUVZzegh6ehEflOeoYkEo2RuH\nO0Kl+OGWFmeeCYF5Uy9Jlna+i/WEN1KlyfDX/GD26ZFZ/5LpBra8wgq+oPPiTkHJ\nbcD/D82/zVqbZaptjs6H9RY2i6bsYViyK74tvrqFgog3BUjDGOA=\n=V4hQ\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/edb4360fa70f220ca221e7654317e435ce3f79d4",
          "sha": "edb4360fa70f220ca221e7654317e435ce3f79d4",
          "html_url": "https://github.com/bitcoin/bips/commit/edb4360fa70f220ca221e7654317e435ce3f79d4"
        }
      ],
      "message": "Address initial PR comments",
      "committer": {
        "name": "Jurvis Tan",
        "email": "hello@jurvis.co",
        "date": "2025-11-30T23:37:34Z"
      },
      "author": {
        "name": "Jurvis Tan",
        "email": "hello@jurvis.co",
        "date": "2025-11-30T23:37:34Z"
      },
      "sha": "9a47c29dd9e111d0d80641857accba0cc256aab1"
    },
    {
      "event": "commented",
      "id": 3593875011,
      "node_id": "IC_kwDOAN28mc7WNi5D",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/3593875011",
      "actor": {
        "login": "jurvis",
        "id": 5944973,
        "node_id": "MDQ6VXNlcjU5NDQ5NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5944973?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jurvis",
        "html_url": "https://github.com/jurvis",
        "followers_url": "https://api.github.com/users/jurvis/followers",
        "following_url": "https://api.github.com/users/jurvis/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jurvis/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jurvis/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jurvis/subscriptions",
        "organizations_url": "https://api.github.com/users/jurvis/orgs",
        "repos_url": "https://api.github.com/users/jurvis/repos",
        "events_url": "https://api.github.com/users/jurvis/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jurvis/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T23:39:17Z",
      "updated_at": "2025-11-30T23:39:17Z",
      "author_association": "NONE",
      "body": "@arminsabouri @jonatack thank you for taking the time to review! I've gone ahead and addressed your comments in \r\n9a47c29",
      "user": {
        "login": "jurvis",
        "id": 5944973,
        "node_id": "MDQ6VXNlcjU5NDQ5NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5944973?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jurvis",
        "html_url": "https://github.com/jurvis",
        "followers_url": "https://api.github.com/users/jurvis/followers",
        "following_url": "https://api.github.com/users/jurvis/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jurvis/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jurvis/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jurvis/subscriptions",
        "organizations_url": "https://api.github.com/users/jurvis/orgs",
        "repos_url": "https://api.github.com/users/jurvis/repos",
        "events_url": "https://api.github.com/users/jurvis/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jurvis/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bips/pull/2004#issuecomment-3593875011",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/2004"
    },
    {
      "event": "mentioned",
      "id": 21261720243,
      "node_id": "MEE_lADOAN28mc7RlPKJzwAAAATzTBqz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21261720243",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T23:39:19Z"
    },
    {
      "event": "subscribed",
      "id": 21261720296,
      "node_id": "SE_lADOAN28mc7RlPKJzwAAAATzTBro",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21261720296",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T23:39:19Z"
    },
    {
      "event": "mentioned",
      "id": 21261720348,
      "node_id": "MEE_lADOAN28mc7RlPKJzwAAAATzTBsc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21261720348",
      "actor": {
        "login": "arminsabouri",
        "id": 24356537,
        "node_id": "MDQ6VXNlcjI0MzU2NTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/24356537?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/arminsabouri",
        "html_url": "https://github.com/arminsabouri",
        "followers_url": "https://api.github.com/users/arminsabouri/followers",
        "following_url": "https://api.github.com/users/arminsabouri/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/arminsabouri/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/arminsabouri/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/arminsabouri/subscriptions",
        "organizations_url": "https://api.github.com/users/arminsabouri/orgs",
        "repos_url": "https://api.github.com/users/arminsabouri/repos",
        "events_url": "https://api.github.com/users/arminsabouri/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/arminsabouri/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T23:39:19Z"
    },
    {
      "event": "subscribed",
      "id": 21261720385,
      "node_id": "SE_lADOAN28mc7RlPKJzwAAAATzTBtB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/21261720385",
      "actor": {
        "login": "arminsabouri",
        "id": 24356537,
        "node_id": "MDQ6VXNlcjI0MzU2NTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/24356537?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/arminsabouri",
        "html_url": "https://github.com/arminsabouri",
        "followers_url": "https://api.github.com/users/arminsabouri/followers",
        "following_url": "https://api.github.com/users/arminsabouri/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/arminsabouri/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/arminsabouri/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/arminsabouri/subscriptions",
        "organizations_url": "https://api.github.com/users/arminsabouri/orgs",
        "repos_url": "https://api.github.com/users/arminsabouri/repos",
        "events_url": "https://api.github.com/users/arminsabouri/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/arminsabouri/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-30T23:39:19Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2518168763",
      "pull_request_review_id": 3453253410,
      "id": 2518168763,
      "node_id": "PRRC_kwDOAN28mc6WGDS7",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+BIP: ???? \n+Layer: Applications\n+Title: Chain Code Delegation\n+Author: Jesse Posner <jesse@vora.io>, Jurvis Tan <jurvis@block.xyz>\n+Status: Draft\n+Type: Standards Track\n+Created: 2025-10-14\n+License: BSD-3-Clause\n+</pre>\n+\n+== Abstract ==\n+Chain Code Delegation (CCD) is a method for multi-signature wallets in which a privileged participant withholds BIP32 chain codes from one or more non-privileged participants, and supplies per-input scalar tweaks at signing time. This allows non-privileged participants to co-sign transactions without learning wallet-wide derivations, balances, or signing activity from other spending combinations. CCD defines the tweak exchange needed for verification and signing behavior when the signer does not possess a chain code.\n+\n+== Motivation ==\n+In multisig deployments, sharing extended public keys (xpubs) or descriptors enables all participants to scan the chain and infer counterparties' activity. CCD limits that visibility by ensuring non-privileged participants only ever hold a non-extended keypair and only receive the minimum per-spend data needed to sign. The procedure keeps policy enforcement feasible for the non-privileged signer while preserving balance privacy, which is particularly useful in collaborative custody arrangements where the wallet owner wants balance privacy from their custodian.\n+\n+== Terminology ==\n+* A \"Delegatee\" is a participant who retains a BIP32 chain code for another participant's base public key and computes derivation tweaks for that participant.\n+* A \"Delegator\" is a participant who holds only a non-extended keypair and receives scalar tweaks from a delegatee when asked to sign.\n+* A \"Participant\" is any key holder in the wallet quorum (including delegators and delegatees).\n+* A \"Non-hardened derivation\" is a BIP32 child derivation where index &lt; 2^31.\n+\n+== Overview ==\n+CCD operates by having Delegatees deprive Delegators of BIP32 chain codes during setup and later conveying the aggregated scalar tweak computed as the sum of non-hardened derivation tweaks along the remaining path to the child key used by a given input or change output. A Delegator uses the tweak to compute the child keys for verification and signing without being able to derive or recognize keys for other paths.\n+\n+== Specification ==\n+\n+=== Key material and setup ===\n+* '''Delegator key:''' Each delegator generates a standard (non-extended) secp256k1 keypair and provides the public key to the counterparties. A delegator MUST NOT retain or be provided a chain code for this key.\n+* '''Delegated chain code:''' A designated delegatee computes and retains a BIP32 chain code bound to the delegator's public key, forming an xpub that MUST NOT be disclosed to the delegator. The delegatee MAY share this xpub with other delegatees.\n+* '''Other participants:''' Non-delegator participants use conventional extended keys and share the public half as appropriate for the wallet descriptor.\n+* '''Derivation constraints:''' All key paths used with CCD MUST be non-hardened beyond the depth visible to the delegator. Hardened steps prevent computation of the needed tweak and are therefore NOT supported.\n+\n+=== Notation ===\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''hash256<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+** The function ''hash512<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 64-byte hash ''SHA512(SHA512(tag) || SHA512(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Tweak Calculation ===\n+To produce CCD tweak data, a delegatee computes a per-participant scalar that aggregates the non-hardened derivation tweaks along the remaining path. Let the extended key retained by the delegatee be P at depth d, and let the target index vector be I = (i<sub>d+1</sub>, …, i<sub>n</sub>) with each i<sub>k</sub> < 2<sup>31</sup>.\n+\n+<div>\n+Algorithm ''ComputeBIP32Tweak(P, I)'':\n+* Inputs:\n+** ''P'': base public key at depth ''d''\n+** ''I = (i<sub>d+1</sub>, …, i<sub>n</sub>)'': ordered sequence of non-hardened child indices\n+* Let ''t = 0'' and ''E = P''.\n+* For each index ''i'' in ''I'' (from left to right):\n+** Run the BIP32 non-hardened derivation ''CKDpub'' on ''E'' with child index ''i'', yielding the child extended key ''P<sub>child</sub>'' and its scalar tweak ''δ'' (the parse<sub>256</sub>(''I<sub>L</sub>'') term from BIP32).\n+** Let ''t = (t + δ) mod n''.\n+** Let ''E = P<sub>child</sub>''.\n+* If ''I'' is empty, let ''P′ = P''; otherwise let ''P′ = P<sub>child</sub>'' from the final iteration.\n+* Return ''(t, P′)''.\n+</div>\n+\n+Any attempt to apply a hardened derivation (index ≥ 2<sup>31</sup>) MUST fail. Delegatees MAY discard P′ after extracting t if it is not otherwise required.\n+\n+=== Delegation Bundle ===\n+CCD requires the delegatee to provide per-participant tweaks for inputs and (optionally) change outputs. Change outputs are only required if a delegator wants to be able to compute the amount of bitcoin they are spending. \n+\n+A delegatee MUST provide each delegator with, for every signing context, a collection of tuples (P<sub>i</sub>, t<sub>i</sub>) where P<sub>i</sub> is the participant's base public key disclosed to the delegator and t<sub>i</sub> is the aggregated tweak returned by ''ComputeBIP32Tweak''. The scalar t<sub>i</sub> MUST be encoded as a 32-byte big-endian integer. \n+\n+The transport that carries this bundle is out of scope for this proposal; implementers MAY use PSBT proprietary keys, RPC payloads, or bespoke messages as long as the delegator can authenticate the origin of the data. Delegatees SHOULD attach the witness script (or sufficient script template information) built with the tweaked keys when the delegator is expected to verify the input or enforce spending policy on change outputs.\n+\n+Delegators use the supplied CCD tweak bundle during verification (see ''Delegator input and change verification'') and signature generation (see ''DelegatorSign'').\n+\n+=== Delegatee Signing ===\n+This BIP supports two modes:\n+* '''Non‑blinded.''' The delegator receives the tweak for the child public key and the message. The delegator learns only about the specific child keys and transactions it signs for; it does not learn the wider address space.\n+* '''Blinded.''' The delegator receives only a blinded challenge and parity bits. The delegator learns nothing about the message or child key for which it produces a signature.\n+\n+Both modes produce valid BIP340 signatures.\n+\n+====Non-Blinded Signing====\n+For non-blinded signing, the delegatee can apply the signatures as usual.\n+\n+=====Delegator input and change verification (Optional)=====\n+A delegator MAY validate the data it receives before producing signatures. \n+\n+For example, input verification reassures the delegator that every tweaked key they are asked to sign for corresponds to a wallet input they recognise. Change verification lets them establish the net outflow and enforce spending policy.\n+\n+Both checks rely on the same delegated tweak bundle described above.\n+\n+=====Input verification=====\n+For each input, the delegatee SHOULD disclose the descriptor template, the untweaked participant keys, the input witness script, and the per-participant tweaks. The delegator then applies the following procedure.\n+\n+<div>\n+Algorithm ''InputVerification(D, W, T)'':\n+* Inputs:\n+** ''D'': wallet policy or descriptor template expressed in terms of the untweaked participant keys ''P<sub>i</sub>''\n+** ''W'': witness script disclosed for the input under review\n+** ''T'': mapping from each ''P<sub>i</sub>'' to a 32-byte big-endian tweak scalar ''t<sub>i</sub>''\n+* For each participant key ''P<sub>i</sub>'' referenced in ''D'':\n+** Retrieve ''t<sub>i</sub>'' from ''T''; fail if the entry is missing or malformed.\n+** If the verifier controls the corresponding private key ''d<sub>i</sub>'', let ''d′<sub>i</sub> = (d<sub>i</sub> + t<sub>i</sub>) mod n'' and ''P′<sub>i</sub> = d′<sub>i</sub> · G''; otherwise let ''P′<sub>i</sub> = P<sub>i</sub> + t<sub>i</sub> · G''.\n+* Let ''D′'' be the descriptor formed by substituting every occurrence of ''P<sub>i</sub>'' in ''D'' with ''P′<sub>i</sub>''.\n+* Derive the witness script ''W′'' from ''D′''.\n+* Return <code>true</code> if ''W′ = W'', otherwise <code>false</code>.\n+</div>\n+\n+Successful verification of an input confirms that the delegator is signing for a script that belongs to the wallet and that the aggregate tweak values align with the expected policy.\n+\n+=====Change-output verification=====\n+When change outputs are disclosed, the delegator can perform an analogous check to ensure the destination script matches their policy template and to calculate outflows. Let D be the descriptor expressed in untweaked keys, W the provided witness script, and T the tweak mapping:\n+\n+<div>\n+Algorithm ''ChangeOutputVerification(D, W, T)'':\n+* Inputs:\n+** ''D'': wallet policy or descriptor template expressed in terms of the untweaked participant keys ''P<sub>i</sub>''\n+** ''W'': witness script disclosed for the change output\n+** ''T'': mapping from each ''P<sub>i</sub>'' to a 32-byte big-endian tweak scalar ''t<sub>i</sub>''\n+* For each participant key ''P<sub>i</sub>'' referenced in ''T'':\n+** Retrieve ''t<sub>i</sub>'' from ''T''; fail if the entry is missing or malformed.\n+** If the verifier controls the corresponding private key ''d<sub>i</sub>'', let ''d′<sub>i</sub> = (d<sub>i</sub> + t<sub>i</sub>) mod n'' and ''P′<sub>i</sub> = d′<sub>i</sub> · G''; otherwise let ''P′<sub>i</sub> = P<sub>i</sub> + t<sub>i</sub> · G''.\n+* Let ''D′'' be the descriptor formed by substituting every occurrence of ''P<sub>i</sub>'' in ''D'' with ''P′<sub>i</sub>''.\n+* Derive the witness script ''W′'' from ''D′''.\n+* Return <code>true</code> if ''W′ = W'', otherwise <code>false</code>.\n+</div>\n+\n+Successful verification ensures the change output commits to the tweaked participant keys implied by the CCD tweaks, preserving the intended policy.\n+\n+=====Delegator Signing=====\n+A delegator that holds only its base secret key <code>x</code> and public key <code>P</code> uses the delegated tweak bundle to derive per-input signing keys. The delegator MAY first call ''InputVerification'' and ''ChangeOutputVerification'' on any input and change output that provides a tweak in order to confirm outflow or policy requirements before signing.\n+\n+<div>\n+Algorithm ''DelegatorSign(t, x, m)'':\n+* Inputs:\n+** ''t'': aggregated tweak for the signing context (scalar mod ''n'')\n+** ''x'': delegator base secret key\n+** ''m'': message to be signed (for example, a transaction digest under the desired SIGHASH policy)\n+* Let ''x′ = (x + t) mod n''.\n+* Use secret key ''x′'' to produce the required signature ''σ'' under the indicated policy.\n+* Return ''σ''.\n+</div>\n+\n+The caller is responsible for inserting ''σ'' into the surrounding protocol (e.g., a PSBT, transaction witness, or adaptor signature exchange).\n+\n+====Blinded Signing====\n+The delegator learns neither the message, the challenge, or the public key used in the BIP340 signature, only a blinded challenge e'.\n+\n+This blind‑signing protocol specifies how a delegator can produce a blind partial Schnorr signature that a delegatee can unblind into a standard [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] signature under a possibly tweaked X‑only public key. The notation, algorithmic patterns, and test‑vector style are adapted from [BIP‑327 (MuSig2)] and from the [https://github.com/siv2r/bip-frost-signing FROST Signing BIP]. The design follows the “plain” blind Schnorr flow described in Concurrently Secure Blind Schnorr Signatures ([https://eprint.iacr.org/2022/1676 ePrint 2022/1676]), but without the concurrency hardening from that work.\n+\n+The output signature is a BIP340 Schnorr signature valid under an X‑only key obtained by applying a sequence of plain (e.g. BIP32) and X‑only (e.g. Tapscript) tweaks to the signer’s plain public key. Consequently the protocol is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]. The delegator learns neither the message, the challenge, or the public key used in the BIP340 signature, only a blinded challenge e'.\n+\n+The plain protocol here is '''not''' concurrently secure. A signer '''MUST NOT''' run multiple blind signing sessions in parallel or interleave state across sessions. A signer '''MUST''' refuse any new blind‑nonce requests while a previous blind‑signature request is outstanding, or '''MUST''' irrevocably discard (and never reuse) any in‑flight blind nonce commitments that have not resulted in a signature, before accepting new ones.\n+\n+To obtain concurrency security as in ([https://eprint.iacr.org/2022/1676 ePrint 2022/1676]), the delegatee first sends an encryption of (m, a, b) before the signer commits to the blind nonce; later, the delegatee includes a zero‑knowledge proof binding the produced challenge to that encrypted tuple. That proof can additionally encode policy predicates about m (spend limits, velocity controls, etc.). A complete specification of this variant is outside the scope of this BIP.\n+\n+===== Overview =====\n+\n+* '''Round 1 (blind nonce).''' The delegator runs ''BlindNonceGen'' to produce ''blindsecnonce'' and ''blindpubnonce'' and sends ''blindpubnonce'' to the delegatee.\n+* '''Round 2 (challenge).''' The delegatee runs ''BlindChallengeGen'' using the message ''m'', ''blindpubnonce'', the base public key ''pk'', and a list of ordinary and X-only tweaks, to produce a ''session context'' (kept locally for unblinding), a ''blindchallenge'', and two booleans ''pk_parity'' and ''nonce_parity''. The delegatee sends ''blindchallenge'', ''pk_parity'', and ''nonce_parity'' to the signer.\n+* '''Round 3 (blind signature).''' The delegator runs ''BlindSign'' with ''sk'', ''blindchallenge'', ''blindsecnonce'', ''pk_parity'', and ''nonce_parity'' and returns ''blindsignature''. The delegatee completes by calling ''UnblindSignature'' with the stored session context and ''blindsignature'' to obtain the final BIP340 signature ''sig''.\n+\n+''BlindSign'' '''MUST NOT''' be executed twice with the same ''blindsecnonce''. As a defense, implementations '''SHOULD''' overwrite the first 64 bytes of ''blindsecnonce'' with zeros after they have been read by ''BlindSign''.\n+\n+=====Key Tweaking=====\n+======Tweak Context======\n+The Tweak Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = tweak_ctx''\" to assign names to the elements of a Tweak Context.\n+\n+<div>\n+Algorithm ''TweakCtxInit(pk)'':\n+* Input:\n+** The base public key pk: a 33-byte array\n+* Let ''Q = cpoint(pk)''\n+* Fail if ''is_infinite(Q)''\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''tweak_ctx = (Q, gacc, tacc)''\n+</div>\n+\n+<div>\n+Algorithm ''ApplyTweak(tweak_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''tweak_ctx'': a [[#tweak-context|Tweak Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = tweak_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''tweak_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=====Blind Nonce Generation=====\n+\n+<div>\n+Algorithm ''BlindNonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The base secret signing key ''sk'': a 32-byte array (optional argument)\n+** The base public key ''pk'': a 33-byte array (optional argument)\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash256<sub>CCD/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k' = int(hash256<sub>CCD/blindnonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(4, len(extra_in)) || extra_in )) mod n''\n+* Fail if ''k' = 0''\n+* Let ''R' = k'⋅G''\n+* Let ''blindpubnonce = cbytes(R')''\n+* Let ''blindsecnonce = bytes(32, k' || pk)''<ref name=\"blindsecnonce\">The algorithms as specified here assume that the ''blindsecnonce'' is stored as a 65-byte array using the serialization ''blindsecnonce = bytes(32, k') || pk''. The same format is used in the reference implementation and in the test vectors. However, since the ''blindsecnonce'' is not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the ''blindsecnonce'' is merely a suggestion.<br />\n+The ''blindsecnonce'' is effectively a local data structure of the signer which comprises the value double ''(k', pk)'', and implementations may choose any suitable method to carry it from ''BlindNonceGen'' (first communication round) to ''BlindSign'' (third communication round). In particular, implementations may choose to hide the ''blindsecnonce'' in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a ''blindsecnonce'' accidentally.</ref>\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=====Session Context=====\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The base public key ''pk'': a 33-byte array\n+* The blind factor ''blindfactor'': a 32-byte array\n+* The challenge hash ''challenge'': a 32-byte array\n+* The public nonce ''pubnonce'': a 33-byte array\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+\n+We write \"Let ''(pk, blindfactor, challenge, pubnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(pk, blindfactor, challenge, pubnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>) = session_ctx''\n+* Let ''tweak_ctx<sub>0</sub> = TweakCtxInit(pk)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''tweak_ctx<sub>i</sub> = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = tweak_ctx<sub>v</sub>''\n+* Let ''a = int(blindfactor)''; fail if ''a ≥ n''\n+* Let ''b = int(blindfactor)''; fail if ''b ≥ n''\n+* Let ''e = int(challenge)''; fail if ''e ≥ n''\n+* Let ''R = cpoint(pubnonce)''; fail if that fails\n+* Return ''(Q, gacc, tacc, a, e, R)''\n+</div>\n+\n+=====Blind Challenge Generation=====\n+\n+<div>\n+Algorithm ''BlindChallengeGen(m, blindpubnonce, pk, tweak<sub>1..v</sub>, is_xonly<sub>1..v</sub>, extra_in)'':\n+* Inputs:\n+** The message ''m'': a byte array\n+** The blind public nonce ''blindpubnonce'': a 33-byte array\n+** The base public key ''pk'': a 33-byte array\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly<sub>1..v</sub>'': ''v'' booleans \n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* If ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''(Q, gacc, tacc) = TweakCtxInit(pk)''\n+* For ''i = 1 .. v'':\n+** Let ''(Q, gacc, tacc) = ApplyTweak((Q, gacc, tacc), tweak<sub>i</sub>, is_xonly<sub>i</sub>)''; fail if that fails \n+* Let ''cpk = cbytes(Q)''\n+* Draw 32 random bytes ''rand''\n+* Let ''z = hash512<sub>CCD/blindfactor</sub>(rand || bytes(1, len(cpk)) || cpk || bytes(1, len(blindpubnonce)) || blindpubnonce || bytes(8, len(m)) || m || bytes(4, len(extra_in)) || extra_in)''\n+* Let ''a' = int(z[0:32]) mod n''; fail if ''a' = 0''\n+* Let ''b' = int(z[32:64]) mod n''; fail if ''b' = 0''\n+* Let ''g = 1'' if ''has_even_y(Q)'', else ''g = −1 mod n''\n+* Let ''pk_parity = (g⋅gacc mod n == 1)''\n+* Let ''X' = cpoint(pk)''; let ''X = X' '' if ''pk_parity'' else ''−X' ''\n+* Let ''R' = cpoint(blindpubnonce)''\n+* Let ''R = R' + a'⋅G + b'⋅X''; fail if ''is_infinite(R)''\n+* Let ''nonce_parity = has_even_y(R)''\n+* If ''nonce_parity'':\n+** Let ''a = a' '', ''b = b' ''\n+* Else:\n+** Let ''a = n − a' '', ''b = n − b' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Let ''e' = (e + b) mod n''\n+* Let ''session_ctx = (pk, bytes(32, a), bytes(32, e), cbytes(R), tweak<sub>1..v</sub>, is_xonly<sub>1..v</sub>)''\n+* Return ''(session_ctx, bytes(32, e'), pk_parity, nonce_parity)''\n+</div>\n+\n+=====Blind Signing=====\n+\n+<div>\n+Algorithm ''BlindSign(sk, blindchallenge, blindsecnonce, pk_parity, nonce_parity)'':\n+* Inputs:\n+** The secret key ''sk'': a 32-byte array\n+** The blind challenge ''blindchallenge'': a 32-byte array ''e' ''\n+** The secret nonce ''blindsecnonce'': a byte array whose first 32 bytes are ''k'' (remaining bytes are implementation-defined)\n+** ''pk_parity'': boolean (from ''BlindChallengeGen'')\n+** ''nonce_parity'': boolean (from ''BlindChallengeGen'')\n+* Let ''d' = int(sk)''; fail if ''d' = 0'' or ''d' ≥ n''\n+* Let ''P = d'⋅G''; fail if ''is_infinite(P)''\n+* Let ''d = d' '' if ''pk_parity'' else ''n − d' ''\n+* Let ''e' = int(blindchallenge)''; fail if ''e' ≥ n''\n+* Let ''k' = int(blindsecnonce[0:32])''; fail if ''k' = 0'' or ''k' ≥ n''\n+* Let ''k = k' '' if ''nonce_parity'' else ''n − k' ''\n+* Overwrite ''blindsecnonce[0:64]'' with 64 zero bytes<ref> This helps prevent accidental nonce reuse. A zeroed ''blindsecnonce'' MUST cause subsequent ''BlindSign'' calls to fail.</ref>\n+* Let ''R' = k'⋅G''; fail if ''is_infinite(R')''<ref> This check holds except with negligible probability.</ref>\n+* Let ''s' = (k + e'⋅d) mod n''\n+* If ''VerifyBlindSignature(cbytes(P), cbytes(R'), blindchallenge, bytes(32, s'), pk_parity, nonce_parity)'' returns failure, abort\n+* Return ''blindsignature = bytes(32, s')''\n+</div>\n+\n+<div>\n+Algorithm ''VerifyBlindSignature(pk, blindpubnonce, blindchallenge, blindsignature, pk_parity, nonce_parity)'':\n+* Inputs:\n+** ''pk'': a 33-byte compressed public key\n+** ''blindpubnonce'': the signer’s 33-byte ''R' = k'⋅G''\n+** ''blindchallenge'': 32-byte ''e' ''\n+** ''blindsignature'': 32-byte ''s' ''\n+** ''pk_parity, nonce_parity'': booleans\n+* Let ''P' ' = cpoint(pk)''; let ''P = P' '' if ''pk_parity'' else ''−P' '' ; fail if ''is_infinite(P)''\n+* Let ''R' ' = cpoint(blindpubnonce)''; let ''R = R' '' if ''nonce_parity'' else ''−R' ''\n+* Let ''e' = int(blindchallenge)'', ''s' = int(blindsignature)''\n+* Return success iff ''s'⋅G == R + e'⋅P''\n+</div>\n+\n+=====Unblinding=====\n+\n+<div>\n+Algorithm ''UnblindSignature(session_ctx, blindsignature)'':\n+* Inputs:\n+** ''session_ctx'': as defined above\n+** ''blindsignature'': the 32-byte ''s' '' returned by the signer\n+* Let ''(Q, gacc, tacc, a, e, R) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', else ''g = −1 mod n''\n+* Let ''s' = int(blindsignature)''; fail if ''s' ≥ n''\n+* Let ''s = (s' + a + e⋅g⋅tacc) mod n''\n+* Return the BIP340 signature ''sig = xbytes(R) || bytes(32, s)''\n+</div>\n+\n+== Security Considerations ==\n+* Exposure of any delegated tweak scalar <code>t</code> enables signing only for the specific child key(s) that scalar was derived for, and is typically short-lived if disclosed immediately before spending.\n+* Delegatees MUST ensure every delegated path remains non-hardened and that ''ComputeBIP32Tweak'' yields the correct tweak <code>t</code>; incorrect scalars can render funds unspendable by the delegator.\n+* Delegators MUST verify change outputs when tweak data is provided (for example via ''ChangeOutputVerification'') to avoid authorizing unexpected scripts.\n+* Reusing the same k' (first 32 bytes in blindsecnonce) across two BlindSign calls allows recovery of the base secret key.\n+* When using blinded signing, opening multiple sessions concurrently against the same signer can allow an attacker to learn the base secret key. If concurrency is required, use the concurrently secure variant (encryption + ZK) instead (not specified in this BIP).\n+\n+== Test Vectors ==\n+A [[bip-chaincode-delegation/vectors|collection of JSON test vectors]] are provided, along with a [[bip-chaincode-delegation/reference.py|python reference implementation]].\n+\n+You may also find example code of CCD in action [https://github.com/jurvis/chaincode-delegation here].\n+\n+== Change Log ==\n+\n+To help implementers understand updates to this document, we attach a version number that resembles ''semantic versioning'' (<code>MAJOR.MINOR.PATCH</code>).\n+The <code>MAJOR</code> version is incremented if changes to the BIP are introduced that are incompatible with prior versions.\n+An exception to this rule is <code>MAJOR</code> version zero (0.y.z) which is for development and does not need to be incremented if backwards incompatible changes are introduced.\n+The <code>MINOR</code> version is incremented whenever the inputs or the output of an algorithm changes in a backward-compatible way or new backward-compatible functionality is added.\n+The <code>PATCH</code> version is incremented for other changes that are noteworthy (bug fixes, test vectors, important clarifications, etc.).\n+\n+* '''0.1.0''' (2025-10-14): Publication of draft BIP\n+\n+== Acknowledgements ==\n+* Arik Sosman and Wilmer Paulino for the initial discussions and validation of this idea.  \n+* Sanket Kajalkar, Jordan Mecom, Gregory Sanders, ZmnSCPxj, Yuval Krogman, and John Cantrell for code and design review.",
      "path": "bip-chaincode-delegation.mediawiki",
      "position": 1,
      "original_position": 391,
      "commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "original_commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "in_reply_to_id": null,
      "user": {
        "login": "arminsabouri",
        "id": 24356537,
        "node_id": "MDQ6VXNlcjI0MzU2NTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/24356537?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/arminsabouri",
        "html_url": "https://github.com/arminsabouri",
        "followers_url": "https://api.github.com/users/arminsabouri/followers",
        "following_url": "https://api.github.com/users/arminsabouri/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/arminsabouri/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/arminsabouri/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/arminsabouri/subscriptions",
        "organizations_url": "https://api.github.com/users/arminsabouri/orgs",
        "repos_url": "https://api.github.com/users/arminsabouri/repos",
        "events_url": "https://api.github.com/users/arminsabouri/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/arminsabouri/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\n* Sanket Kajalkar, Jordan Mecom, Gregory Sanders, ZmnSCPxj, Yuval Kogman, and John Cantrell for code and design review.\n```",
      "created_at": "2025-11-12T12:44:25Z",
      "updated_at": "2025-11-12T12:44:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2004#discussion_r2518168763",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2518168763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2004"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 391,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2561144230",
      "pull_request_review_id": 3506500865,
      "id": 2561144230,
      "node_id": "PRRC_kwDOAN28mc6Yp_Wm",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+BIP: ???? \n+Layer: Applications\n+Title: Chain Code Delegation\n+Author: Jesse Posner <jesse@vora.io>, Jurvis Tan <jurvis@block.xyz>\n+Status: Draft\n+Type: Standards Track\n+Created: 2025-10-14\n+License: BSD-3-Clause",
      "path": "bip-chaincode-delegation.mediawiki",
      "position": 9,
      "original_position": 9,
      "commit_id": "9a47c29dd9e111d0d80641857accba0cc256aab1",
      "original_commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Suggested header additions (Version is BIP3 only, so only add it if BIP3 is activated:\n\n```\nPost-History: delvingbitcoin.org/t/chain-code-delegation-private-access-control-for-bitcoin-keys/1837.\nVersion: 0.1.0\nRequires: 32, 340, 341\n```",
      "created_at": "2025-11-25T19:23:06Z",
      "updated_at": "2025-11-25T19:51:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2004#discussion_r2561144230",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2561144230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2004"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 9,
      "original_line": 9,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2561189020",
      "pull_request_review_id": 3506500865,
      "id": 2561189020,
      "node_id": "PRRC_kwDOAN28mc6YqKSc",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+BIP: ???? \n+Layer: Applications\n+Title: Chain Code Delegation\n+Author: Jesse Posner <jesse@vora.io>, Jurvis Tan <jurvis@block.xyz>\n+Status: Draft\n+Type: Standards Track\n+Created: 2025-10-14\n+License: BSD-3-Clause\n+</pre>\n+\n+== Abstract ==\n+Chain Code Delegation (CCD) is a method for multi-signature wallets in which a privileged participant withholds BIP32 chain codes from one or more non-privileged participants, and supplies per-input scalar tweaks at signing time. This allows non-privileged participants to co-sign transactions without learning wallet-wide derivations, balances, or signing activity from other spending combinations. CCD defines the tweak exchange needed for verification and signing behavior when the signer does not possess a chain code.\n+\n+== Motivation ==\n+In multisig deployments, sharing extended public keys (xpubs) or descriptors enables all participants to scan the chain and infer counterparties' activity. CCD limits that visibility by ensuring non-privileged participants only ever hold a non-extended keypair and only receive the minimum per-spend data needed to sign. The procedure keeps policy enforcement feasible for the non-privileged signer while preserving balance privacy, which is particularly useful in collaborative custody arrangements where the wallet owner wants balance privacy from their custodian.\n+\n+== Terminology ==\n+* A \"Delegatee\" is a participant who retains a BIP32 chain code for another participant's base public key and computes derivation tweaks for that participant.\n+* A \"Delegator\" is a participant who holds only a non-extended keypair and receives scalar tweaks from a delegatee when asked to sign.\n+* A \"Participant\" is any key holder in the wallet quorum (including delegators and delegatees).\n+* A \"Non-hardened derivation\" is a BIP32 child derivation where index &lt; 2^31.\n+\n+== Overview ==\n+CCD operates by having Delegatees deprive Delegators of BIP32 chain codes during setup and later conveying the aggregated scalar tweak computed as the sum of non-hardened derivation tweaks along the remaining path to the child key used by a given input or change output. A Delegator uses the tweak to compute the child keys for verification and signing without being able to derive or recognize keys for other paths.\n+\n+== Specification ==\n+\n+=== Key material and setup ===\n+* '''Delegator key:''' Each delegator generates a standard (non-extended) secp256k1 keypair and provides the public key to the counterparties. A delegator MUST NOT retain or be provided a chain code for this key.\n+* '''Delegated chain code:''' A designated delegatee computes and retains a BIP32 chain code bound to the delegator's public key, forming an xpub that MUST NOT be disclosed to the delegator. The delegatee MAY share this xpub with other delegatees.\n+* '''Other participants:''' Non-delegator participants use conventional extended keys and share the public half as appropriate for the wallet descriptor.\n+* '''Derivation constraints:''' All key paths used with CCD MUST be non-hardened beyond the depth visible to the delegator. Hardened steps prevent computation of the needed tweak and are therefore NOT supported.\n+\n+=== Notation ===\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''hash256<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+** The function ''hash512<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 64-byte hash ''SHA512(SHA512(tag) || SHA512(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Tweak Calculation ===\n+To produce CCD tweak data, a delegatee computes a per-participant scalar that aggregates the non-hardened derivation tweaks along the remaining path. Let the extended key retained by the delegatee be P at depth d, and let the target index vector be I = (i<sub>d+1</sub>, …, i<sub>n</sub>) with each i<sub>k</sub> < 2<sup>31</sup>.\n+\n+<div>\n+Algorithm ''ComputeBIP32Tweak(P, I)'':\n+* Inputs:\n+** ''P'': base public key at depth ''d''\n+** ''I = (i<sub>d+1</sub>, …, i<sub>n</sub>)'': ordered sequence of non-hardened child indices\n+* Let ''t = 0'' and ''E = P''.\n+* For each index ''i'' in ''I'' (from left to right):\n+** Run the BIP32 non-hardened derivation ''CKDpub'' on ''E'' with child index ''i'', yielding the child extended key ''P<sub>child</sub>'' and its scalar tweak ''δ'' (the parse<sub>256</sub>(''I<sub>L</sub>'') term from BIP32).\n+** Let ''t = (t + δ) mod n''.\n+** Let ''E = P<sub>child</sub>''.\n+* If ''I'' is empty, let ''P′ = P''; otherwise let ''P′ = P<sub>child</sub>'' from the final iteration.\n+* Return ''(t, P′)''.\n+</div>\n+\n+Any attempt to apply a hardened derivation (index ≥ 2<sup>31</sup>) MUST fail. Delegatees MAY discard P′ after extracting t if it is not otherwise required.\n+\n+=== Delegation Bundle ===\n+CCD requires the delegatee to provide per-participant tweaks for inputs and (optionally) change outputs. Change outputs are only required if a delegator wants to be able to compute the amount of bitcoin they are spending. \n+\n+A delegatee MUST provide each delegator with, for every signing context, a collection of tuples (P<sub>i</sub>, t<sub>i</sub>) where P<sub>i</sub> is the participant's base public key disclosed to the delegator and t<sub>i</sub> is the aggregated tweak returned by ''ComputeBIP32Tweak''. The scalar t<sub>i</sub> MUST be encoded as a 32-byte big-endian integer. \n+\n+The transport that carries this bundle is out of scope for this proposal; implementers MAY use PSBT proprietary keys, RPC payloads, or bespoke messages as long as the delegator can authenticate the origin of the data. Delegatees SHOULD attach the witness script (or sufficient script template information) built with the tweaked keys when the delegator is expected to verify the input or enforce spending policy on change outputs.\n+\n+Delegators use the supplied CCD tweak bundle during verification (see ''Delegator input and change verification'') and signature generation (see ''DelegatorSign'').\n+\n+=== Delegatee Signing ===\n+This BIP supports two modes:\n+* '''Non‑blinded.''' The delegator receives the tweak for the child public key and the message. The delegator learns only about the specific child keys and transactions it signs for; it does not learn the wider address space.\n+* '''Blinded.''' The delegator receives only a blinded challenge and parity bits. The delegator learns nothing about the message or child key for which it produces a signature.\n+\n+Both modes produce valid BIP340 signatures.\n+\n+====Non-Blinded Signing====\n+For non-blinded signing, the delegatee can apply the signatures as usual.\n+\n+=====Delegator input and change verification (Optional)=====\n+A delegator MAY validate the data it receives before producing signatures. \n+\n+For example, input verification reassures the delegator that every tweaked key they are asked to sign for corresponds to a wallet input they recognise. Change verification lets them establish the net outflow and enforce spending policy.\n+\n+Both checks rely on the same delegated tweak bundle described above.\n+\n+=====Input verification=====\n+For each input, the delegatee SHOULD disclose the descriptor template, the untweaked participant keys, the input witness script, and the per-participant tweaks. The delegator then applies the following procedure.\n+\n+<div>\n+Algorithm ''InputVerification(D, W, T)'':\n+* Inputs:\n+** ''D'': wallet policy or descriptor template expressed in terms of the untweaked participant keys ''P<sub>i</sub>''\n+** ''W'': witness script disclosed for the input under review\n+** ''T'': mapping from each ''P<sub>i</sub>'' to a 32-byte big-endian tweak scalar ''t<sub>i</sub>''\n+* For each participant key ''P<sub>i</sub>'' referenced in ''D'':\n+** Retrieve ''t<sub>i</sub>'' from ''T''; fail if the entry is missing or malformed.\n+** If the verifier controls the corresponding private key ''d<sub>i</sub>'', let ''d′<sub>i</sub> = (d<sub>i</sub> + t<sub>i</sub>) mod n'' and ''P′<sub>i</sub> = d′<sub>i</sub> · G''; otherwise let ''P′<sub>i</sub> = P<sub>i</sub> + t<sub>i</sub> · G''.\n+* Let ''D′'' be the descriptor formed by substituting every occurrence of ''P<sub>i</sub>'' in ''D'' with ''P′<sub>i</sub>''.\n+* Derive the witness script ''W′'' from ''D′''.\n+* Return <code>true</code> if ''W′ = W'', otherwise <code>false</code>.\n+</div>\n+\n+Successful verification of an input confirms that the delegator is signing for a script that belongs to the wallet and that the aggregate tweak values align with the expected policy.\n+\n+=====Change-output verification=====\n+When change outputs are disclosed, the delegator can perform an analogous check to ensure the destination script matches their policy template and to calculate outflows. Let D be the descriptor expressed in untweaked keys, W the provided witness script, and T the tweak mapping:\n+\n+<div>\n+Algorithm ''ChangeOutputVerification(D, W, T)'':\n+* Inputs:\n+** ''D'': wallet policy or descriptor template expressed in terms of the untweaked participant keys ''P<sub>i</sub>''\n+** ''W'': witness script disclosed for the change output\n+** ''T'': mapping from each ''P<sub>i</sub>'' to a 32-byte big-endian tweak scalar ''t<sub>i</sub>''\n+* For each participant key ''P<sub>i</sub>'' referenced in ''T'':\n+** Retrieve ''t<sub>i</sub>'' from ''T''; fail if the entry is missing or malformed.\n+** If the verifier controls the corresponding private key ''d<sub>i</sub>'', let ''d′<sub>i</sub> = (d<sub>i</sub> + t<sub>i</sub>) mod n'' and ''P′<sub>i</sub> = d′<sub>i</sub> · G''; otherwise let ''P′<sub>i</sub> = P<sub>i</sub> + t<sub>i</sub> · G''.\n+* Let ''D′'' be the descriptor formed by substituting every occurrence of ''P<sub>i</sub>'' in ''D'' with ''P′<sub>i</sub>''.\n+* Derive the witness script ''W′'' from ''D′''.\n+* Return <code>true</code> if ''W′ = W'', otherwise <code>false</code>.\n+</div>\n+\n+Successful verification ensures the change output commits to the tweaked participant keys implied by the CCD tweaks, preserving the intended policy.\n+\n+=====Delegator Signing=====\n+A delegator that holds only its base secret key <code>x</code> and public key <code>P</code> uses the delegated tweak bundle to derive per-input signing keys. The delegator MAY first call ''InputVerification'' and ''ChangeOutputVerification'' on any input and change output that provides a tweak in order to confirm outflow or policy requirements before signing.\n+\n+<div>\n+Algorithm ''DelegatorSign(t, x, m)'':\n+* Inputs:\n+** ''t'': aggregated tweak for the signing context (scalar mod ''n'')\n+** ''x'': delegator base secret key\n+** ''m'': message to be signed (for example, a transaction digest under the desired SIGHASH policy)\n+* Let ''x′ = (x + t) mod n''.\n+* Use secret key ''x′'' to produce the required signature ''σ'' under the indicated policy.\n+* Return ''σ''.\n+</div>\n+\n+The caller is responsible for inserting ''σ'' into the surrounding protocol (e.g., a PSBT, transaction witness, or adaptor signature exchange).\n+\n+====Blinded Signing====\n+The delegator learns neither the message, the challenge, or the public key used in the BIP340 signature, only a blinded challenge e'.\n+\n+This blind‑signing protocol specifies how a delegator can produce a blind partial Schnorr signature that a delegatee can unblind into a standard [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] signature under a possibly tweaked X‑only public key. The notation, algorithmic patterns, and test‑vector style are adapted from [BIP‑327 (MuSig2)] and from the [https://github.com/siv2r/bip-frost-signing FROST Signing BIP]. The design follows the “plain” blind Schnorr flow described in Concurrently Secure Blind Schnorr Signatures ([https://eprint.iacr.org/2022/1676 ePrint 2022/1676]), but without the concurrency hardening from that work.\n+\n+The output signature is a BIP340 Schnorr signature valid under an X‑only key obtained by applying a sequence of plain (e.g. BIP32) and X‑only (e.g. Tapscript) tweaks to the signer’s plain public key. Consequently the protocol is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]. The delegator learns neither the message, the challenge, or the public key used in the BIP340 signature, only a blinded challenge e'.\n+\n+The plain protocol here is '''not''' concurrently secure. A signer '''MUST NOT''' run multiple blind signing sessions in parallel or interleave state across sessions. A signer '''MUST''' refuse any new blind‑nonce requests while a previous blind‑signature request is outstanding, or '''MUST''' irrevocably discard (and never reuse) any in‑flight blind nonce commitments that have not resulted in a signature, before accepting new ones.\n+\n+To obtain concurrency security as in ([https://eprint.iacr.org/2022/1676 ePrint 2022/1676]), the delegatee first sends an encryption of (m, a, b) before the signer commits to the blind nonce; later, the delegatee includes a zero‑knowledge proof binding the produced challenge to that encrypted tuple. That proof can additionally encode policy predicates about m (spend limits, velocity controls, etc.). A complete specification of this variant is outside the scope of this BIP.\n+\n+===== Overview =====\n+\n+* '''Round 1 (blind nonce).''' The delegator runs ''BlindNonceGen'' to produce ''blindsecnonce'' and ''blindpubnonce'' and sends ''blindpubnonce'' to the delegatee.\n+* '''Round 2 (challenge).''' The delegatee runs ''BlindChallengeGen'' using the message ''m'', ''blindpubnonce'', the base public key ''pk'', and a list of ordinary and X-only tweaks, to produce a ''session context'' (kept locally for unblinding), a ''blindchallenge'', and two booleans ''pk_parity'' and ''nonce_parity''. The delegatee sends ''blindchallenge'', ''pk_parity'', and ''nonce_parity'' to the signer.\n+* '''Round 3 (blind signature).''' The delegator runs ''BlindSign'' with ''sk'', ''blindchallenge'', ''blindsecnonce'', ''pk_parity'', and ''nonce_parity'' and returns ''blindsignature''. The delegatee completes by calling ''UnblindSignature'' with the stored session context and ''blindsignature'' to obtain the final BIP340 signature ''sig''.\n+\n+''BlindSign'' '''MUST NOT''' be executed twice with the same ''blindsecnonce''. As a defense, implementations '''SHOULD''' overwrite the first 64 bytes of ''blindsecnonce'' with zeros after they have been read by ''BlindSign''.\n+\n+=====Key Tweaking=====\n+======Tweak Context======\n+The Tweak Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = tweak_ctx''\" to assign names to the elements of a Tweak Context.\n+\n+<div>\n+Algorithm ''TweakCtxInit(pk)'':\n+* Input:\n+** The base public key pk: a 33-byte array\n+* Let ''Q = cpoint(pk)''\n+* Fail if ''is_infinite(Q)''\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''tweak_ctx = (Q, gacc, tacc)''\n+</div>\n+\n+<div>\n+Algorithm ''ApplyTweak(tweak_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''tweak_ctx'': a [[#tweak-context|Tweak Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = tweak_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''tweak_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=====Blind Nonce Generation=====\n+\n+<div>\n+Algorithm ''BlindNonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The base secret signing key ''sk'': a 32-byte array (optional argument)\n+** The base public key ''pk'': a 33-byte array (optional argument)\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash256<sub>CCD/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k' = int(hash256<sub>CCD/blindnonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(4, len(extra_in)) || extra_in )) mod n''\n+* Fail if ''k' = 0''\n+* Let ''R' = k'⋅G''\n+* Let ''blindpubnonce = cbytes(R')''\n+* Let ''blindsecnonce = bytes(32, k' || pk)''<ref name=\"blindsecnonce\">The algorithms as specified here assume that the ''blindsecnonce'' is stored as a 65-byte array using the serialization ''blindsecnonce = bytes(32, k') || pk''. The same format is used in the reference implementation and in the test vectors. However, since the ''blindsecnonce'' is not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the ''blindsecnonce'' is merely a suggestion.<br />\n+The ''blindsecnonce'' is effectively a local data structure of the signer which comprises the value double ''(k', pk)'', and implementations may choose any suitable method to carry it from ''BlindNonceGen'' (first communication round) to ''BlindSign'' (third communication round). In particular, implementations may choose to hide the ''blindsecnonce'' in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a ''blindsecnonce'' accidentally.</ref>\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=====Session Context=====\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The base public key ''pk'': a 33-byte array\n+* The blind factor ''blindfactor'': a 32-byte array\n+* The challenge hash ''challenge'': a 32-byte array\n+* The public nonce ''pubnonce'': a 33-byte array\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+\n+We write \"Let ''(pk, blindfactor, challenge, pubnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(pk, blindfactor, challenge, pubnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>) = session_ctx''\n+* Let ''tweak_ctx<sub>0</sub> = TweakCtxInit(pk)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''tweak_ctx<sub>i</sub> = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = tweak_ctx<sub>v</sub>''\n+* Let ''a = int(blindfactor)''; fail if ''a ≥ n''\n+* Let ''b = int(blindfactor)''; fail if ''b ≥ n''\n+* Let ''e = int(challenge)''; fail if ''e ≥ n''\n+* Let ''R = cpoint(pubnonce)''; fail if that fails\n+* Return ''(Q, gacc, tacc, a, e, R)''\n+</div>\n+\n+=====Blind Challenge Generation=====\n+\n+<div>\n+Algorithm ''BlindChallengeGen(m, blindpubnonce, pk, tweak<sub>1..v</sub>, is_xonly<sub>1..v</sub>, extra_in)'':\n+* Inputs:\n+** The message ''m'': a byte array\n+** The blind public nonce ''blindpubnonce'': a 33-byte array\n+** The base public key ''pk'': a 33-byte array\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly<sub>1..v</sub>'': ''v'' booleans \n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* If ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''(Q, gacc, tacc) = TweakCtxInit(pk)''\n+* For ''i = 1 .. v'':\n+** Let ''(Q, gacc, tacc) = ApplyTweak((Q, gacc, tacc), tweak<sub>i</sub>, is_xonly<sub>i</sub>)''; fail if that fails \n+* Let ''cpk = cbytes(Q)''\n+* Draw 32 random bytes ''rand''\n+* Let ''z = hash512<sub>CCD/blindfactor</sub>(rand || bytes(1, len(cpk)) || cpk || bytes(1, len(blindpubnonce)) || blindpubnonce || bytes(8, len(m)) || m || bytes(4, len(extra_in)) || extra_in)''\n+* Let ''a' = int(z[0:32]) mod n''; fail if ''a' = 0''\n+* Let ''b' = int(z[32:64]) mod n''; fail if ''b' = 0''\n+* Let ''g = 1'' if ''has_even_y(Q)'', else ''g = −1 mod n''\n+* Let ''pk_parity = (g⋅gacc mod n == 1)''\n+* Let ''X' = cpoint(pk)''; let ''X = X' '' if ''pk_parity'' else ''−X' ''\n+* Let ''R' = cpoint(blindpubnonce)''\n+* Let ''R = R' + a'⋅G + b'⋅X''; fail if ''is_infinite(R)''\n+* Let ''nonce_parity = has_even_y(R)''\n+* If ''nonce_parity'':\n+** Let ''a = a' '', ''b = b' ''\n+* Else:\n+** Let ''a = n − a' '', ''b = n − b' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Let ''e' = (e + b) mod n''\n+* Let ''session_ctx = (pk, bytes(32, a), bytes(32, e), cbytes(R), tweak<sub>1..v</sub>, is_xonly<sub>1..v</sub>)''\n+* Return ''(session_ctx, bytes(32, e'), pk_parity, nonce_parity)''\n+</div>\n+\n+=====Blind Signing=====\n+\n+<div>\n+Algorithm ''BlindSign(sk, blindchallenge, blindsecnonce, pk_parity, nonce_parity)'':\n+* Inputs:\n+** The secret key ''sk'': a 32-byte array\n+** The blind challenge ''blindchallenge'': a 32-byte array ''e' ''\n+** The secret nonce ''blindsecnonce'': a byte array whose first 32 bytes are ''k'' (remaining bytes are implementation-defined)\n+** ''pk_parity'': boolean (from ''BlindChallengeGen'')\n+** ''nonce_parity'': boolean (from ''BlindChallengeGen'')\n+* Let ''d' = int(sk)''; fail if ''d' = 0'' or ''d' ≥ n''\n+* Let ''P = d'⋅G''; fail if ''is_infinite(P)''\n+* Let ''d = d' '' if ''pk_parity'' else ''n − d' ''\n+* Let ''e' = int(blindchallenge)''; fail if ''e' ≥ n''\n+* Let ''k' = int(blindsecnonce[0:32])''; fail if ''k' = 0'' or ''k' ≥ n''\n+* Let ''k = k' '' if ''nonce_parity'' else ''n − k' ''\n+* Overwrite ''blindsecnonce[0:64]'' with 64 zero bytes<ref> This helps prevent accidental nonce reuse. A zeroed ''blindsecnonce'' MUST cause subsequent ''BlindSign'' calls to fail.</ref>\n+* Let ''R' = k'⋅G''; fail if ''is_infinite(R')''<ref> This check holds except with negligible probability.</ref>\n+* Let ''s' = (k + e'⋅d) mod n''\n+* If ''VerifyBlindSignature(cbytes(P), cbytes(R'), blindchallenge, bytes(32, s'), pk_parity, nonce_parity)'' returns failure, abort\n+* Return ''blindsignature = bytes(32, s')''\n+</div>\n+\n+<div>\n+Algorithm ''VerifyBlindSignature(pk, blindpubnonce, blindchallenge, blindsignature, pk_parity, nonce_parity)'':\n+* Inputs:\n+** ''pk'': a 33-byte compressed public key\n+** ''blindpubnonce'': the signer’s 33-byte ''R' = k'⋅G''\n+** ''blindchallenge'': 32-byte ''e' ''\n+** ''blindsignature'': 32-byte ''s' ''\n+** ''pk_parity, nonce_parity'': booleans\n+* Let ''P' ' = cpoint(pk)''; let ''P = P' '' if ''pk_parity'' else ''−P' '' ; fail if ''is_infinite(P)''\n+* Let ''R' ' = cpoint(blindpubnonce)''; let ''R = R' '' if ''nonce_parity'' else ''−R' ''\n+* Let ''e' = int(blindchallenge)'', ''s' = int(blindsignature)''\n+* Return success iff ''s'⋅G == R + e'⋅P''\n+</div>\n+\n+=====Unblinding=====\n+\n+<div>\n+Algorithm ''UnblindSignature(session_ctx, blindsignature)'':\n+* Inputs:\n+** ''session_ctx'': as defined above\n+** ''blindsignature'': the 32-byte ''s' '' returned by the signer\n+* Let ''(Q, gacc, tacc, a, e, R) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', else ''g = −1 mod n''\n+* Let ''s' = int(blindsignature)''; fail if ''s' ≥ n''\n+* Let ''s = (s' + a + e⋅g⋅tacc) mod n''\n+* Return the BIP340 signature ''sig = xbytes(R) || bytes(32, s)''\n+</div>\n+\n+== Security Considerations ==\n+* Exposure of any delegated tweak scalar <code>t</code> enables signing only for the specific child key(s) that scalar was derived for, and is typically short-lived if disclosed immediately before spending.\n+* Delegatees MUST ensure every delegated path remains non-hardened and that ''ComputeBIP32Tweak'' yields the correct tweak <code>t</code>; incorrect scalars can render funds unspendable by the delegator.\n+* Delegators MUST verify change outputs when tweak data is provided (for example via ''ChangeOutputVerification'') to avoid authorizing unexpected scripts.\n+* Reusing the same k' (first 32 bytes in blindsecnonce) across two BlindSign calls allows recovery of the base secret key.\n+* When using blinded signing, opening multiple sessions concurrently against the same signer can allow an attacker to learn the base secret key. If concurrency is required, use the concurrently secure variant (encryption + ZK) instead (not specified in this BIP).\n+\n+== Test Vectors ==\n+A [[bip-chaincode-delegation/vectors|collection of JSON test vectors]] are provided, along with a [[bip-chaincode-delegation/reference.py|python reference implementation]].\n+\n+You may also find example code of CCD in action [https://github.com/jurvis/chaincode-delegation here].\n+\n+== Change Log ==\n+\n+To help implementers understand updates to this document, we attach a version number that resembles ''semantic versioning'' (<code>MAJOR.MINOR.PATCH</code>).\n+The <code>MAJOR</code> version is incremented if changes to the BIP are introduced that are incompatible with prior versions.\n+An exception to this rule is <code>MAJOR</code> version zero (0.y.z) which is for development and does not need to be incremented if backwards incompatible changes are introduced.\n+The <code>MINOR</code> version is incremented whenever the inputs or the output of an algorithm changes in a backward-compatible way or new backward-compatible functionality is added.\n+The <code>PATCH</code> version is incremented for other changes that are noteworthy (bug fixes, test vectors, important clarifications, etc.).",
      "path": "bip-chaincode-delegation.mediawiki",
      "position": 1,
      "original_position": 385,
      "commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "original_commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit, can probably drop this explanatory text. BIP3 includes a similar explanation for all BIPs, and until then, semver is assumed.",
      "created_at": "2025-11-25T19:41:05Z",
      "updated_at": "2025-11-25T19:51:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2004#discussion_r2561189020",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2561189020"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2004"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 385,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2561191313",
      "pull_request_review_id": 3506500865,
      "id": 2561191313,
      "node_id": "PRRC_kwDOAN28mc6YqK2R",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+BIP: ???? \n+Layer: Applications\n+Title: Chain Code Delegation\n+Author: Jesse Posner <jesse@vora.io>, Jurvis Tan <jurvis@block.xyz>\n+Status: Draft\n+Type: Standards Track\n+Created: 2025-10-14\n+License: BSD-3-Clause\n+</pre>\n+\n+== Abstract ==\n+Chain Code Delegation (CCD) is a method for multi-signature wallets in which a privileged participant withholds BIP32 chain codes from one or more non-privileged participants, and supplies per-input scalar tweaks at signing time. This allows non-privileged participants to co-sign transactions without learning wallet-wide derivations, balances, or signing activity from other spending combinations. CCD defines the tweak exchange needed for verification and signing behavior when the signer does not possess a chain code.\n+\n+== Motivation ==\n+In multisig deployments, sharing extended public keys (xpubs) or descriptors enables all participants to scan the chain and infer counterparties' activity. CCD limits that visibility by ensuring non-privileged participants only ever hold a non-extended keypair and only receive the minimum per-spend data needed to sign. The procedure keeps policy enforcement feasible for the non-privileged signer while preserving balance privacy, which is particularly useful in collaborative custody arrangements where the wallet owner wants balance privacy from their custodian.\n+\n+== Terminology ==\n+* A \"Delegatee\" is a participant who retains a BIP32 chain code for another participant's base public key and computes derivation tweaks for that participant.\n+* A \"Delegator\" is a participant who holds only a non-extended keypair and receives scalar tweaks from a delegatee when asked to sign.\n+* A \"Participant\" is any key holder in the wallet quorum (including delegators and delegatees).\n+* A \"Non-hardened derivation\" is a BIP32 child derivation where index &lt; 2^31.\n+\n+== Overview ==\n+CCD operates by having Delegatees deprive Delegators of BIP32 chain codes during setup and later conveying the aggregated scalar tweak computed as the sum of non-hardened derivation tweaks along the remaining path to the child key used by a given input or change output. A Delegator uses the tweak to compute the child keys for verification and signing without being able to derive or recognize keys for other paths.\n+\n+== Specification ==\n+\n+=== Key material and setup ===\n+* '''Delegator key:''' Each delegator generates a standard (non-extended) secp256k1 keypair and provides the public key to the counterparties. A delegator MUST NOT retain or be provided a chain code for this key.\n+* '''Delegated chain code:''' A designated delegatee computes and retains a BIP32 chain code bound to the delegator's public key, forming an xpub that MUST NOT be disclosed to the delegator. The delegatee MAY share this xpub with other delegatees.\n+* '''Other participants:''' Non-delegator participants use conventional extended keys and share the public half as appropriate for the wallet descriptor.\n+* '''Derivation constraints:''' All key paths used with CCD MUST be non-hardened beyond the depth visible to the delegator. Hardened steps prevent computation of the needed tweak and are therefore NOT supported.\n+\n+=== Notation ===\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''hash256<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+** The function ''hash512<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 64-byte hash ''SHA512(SHA512(tag) || SHA512(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Tweak Calculation ===\n+To produce CCD tweak data, a delegatee computes a per-participant scalar that aggregates the non-hardened derivation tweaks along the remaining path. Let the extended key retained by the delegatee be P at depth d, and let the target index vector be I = (i<sub>d+1</sub>, …, i<sub>n</sub>) with each i<sub>k</sub> < 2<sup>31</sup>.\n+\n+<div>\n+Algorithm ''ComputeBIP32Tweak(P, I)'':\n+* Inputs:\n+** ''P'': base public key at depth ''d''\n+** ''I = (i<sub>d+1</sub>, …, i<sub>n</sub>)'': ordered sequence of non-hardened child indices\n+* Let ''t = 0'' and ''E = P''.\n+* For each index ''i'' in ''I'' (from left to right):\n+** Run the BIP32 non-hardened derivation ''CKDpub'' on ''E'' with child index ''i'', yielding the child extended key ''P<sub>child</sub>'' and its scalar tweak ''δ'' (the parse<sub>256</sub>(''I<sub>L</sub>'') term from BIP32).\n+** Let ''t = (t + δ) mod n''.\n+** Let ''E = P<sub>child</sub>''.\n+* If ''I'' is empty, let ''P′ = P''; otherwise let ''P′ = P<sub>child</sub>'' from the final iteration.\n+* Return ''(t, P′)''.\n+</div>\n+\n+Any attempt to apply a hardened derivation (index ≥ 2<sup>31</sup>) MUST fail. Delegatees MAY discard P′ after extracting t if it is not otherwise required.\n+\n+=== Delegation Bundle ===\n+CCD requires the delegatee to provide per-participant tweaks for inputs and (optionally) change outputs. Change outputs are only required if a delegator wants to be able to compute the amount of bitcoin they are spending. \n+\n+A delegatee MUST provide each delegator with, for every signing context, a collection of tuples (P<sub>i</sub>, t<sub>i</sub>) where P<sub>i</sub> is the participant's base public key disclosed to the delegator and t<sub>i</sub> is the aggregated tweak returned by ''ComputeBIP32Tweak''. The scalar t<sub>i</sub> MUST be encoded as a 32-byte big-endian integer. \n+\n+The transport that carries this bundle is out of scope for this proposal; implementers MAY use PSBT proprietary keys, RPC payloads, or bespoke messages as long as the delegator can authenticate the origin of the data. Delegatees SHOULD attach the witness script (or sufficient script template information) built with the tweaked keys when the delegator is expected to verify the input or enforce spending policy on change outputs.\n+\n+Delegators use the supplied CCD tweak bundle during verification (see ''Delegator input and change verification'') and signature generation (see ''DelegatorSign'').\n+\n+=== Delegatee Signing ===\n+This BIP supports two modes:\n+* '''Non‑blinded.''' The delegator receives the tweak for the child public key and the message. The delegator learns only about the specific child keys and transactions it signs for; it does not learn the wider address space.\n+* '''Blinded.''' The delegator receives only a blinded challenge and parity bits. The delegator learns nothing about the message or child key for which it produces a signature.\n+\n+Both modes produce valid BIP340 signatures.\n+\n+====Non-Blinded Signing====\n+For non-blinded signing, the delegatee can apply the signatures as usual.\n+\n+=====Delegator input and change verification (Optional)=====\n+A delegator MAY validate the data it receives before producing signatures. \n+\n+For example, input verification reassures the delegator that every tweaked key they are asked to sign for corresponds to a wallet input they recognise. Change verification lets them establish the net outflow and enforce spending policy.\n+\n+Both checks rely on the same delegated tweak bundle described above.\n+\n+=====Input verification=====\n+For each input, the delegatee SHOULD disclose the descriptor template, the untweaked participant keys, the input witness script, and the per-participant tweaks. The delegator then applies the following procedure.\n+\n+<div>\n+Algorithm ''InputVerification(D, W, T)'':\n+* Inputs:\n+** ''D'': wallet policy or descriptor template expressed in terms of the untweaked participant keys ''P<sub>i</sub>''\n+** ''W'': witness script disclosed for the input under review\n+** ''T'': mapping from each ''P<sub>i</sub>'' to a 32-byte big-endian tweak scalar ''t<sub>i</sub>''\n+* For each participant key ''P<sub>i</sub>'' referenced in ''D'':\n+** Retrieve ''t<sub>i</sub>'' from ''T''; fail if the entry is missing or malformed.\n+** If the verifier controls the corresponding private key ''d<sub>i</sub>'', let ''d′<sub>i</sub> = (d<sub>i</sub> + t<sub>i</sub>) mod n'' and ''P′<sub>i</sub> = d′<sub>i</sub> · G''; otherwise let ''P′<sub>i</sub> = P<sub>i</sub> + t<sub>i</sub> · G''.\n+* Let ''D′'' be the descriptor formed by substituting every occurrence of ''P<sub>i</sub>'' in ''D'' with ''P′<sub>i</sub>''.\n+* Derive the witness script ''W′'' from ''D′''.\n+* Return <code>true</code> if ''W′ = W'', otherwise <code>false</code>.\n+</div>\n+\n+Successful verification of an input confirms that the delegator is signing for a script that belongs to the wallet and that the aggregate tweak values align with the expected policy.\n+\n+=====Change-output verification=====\n+When change outputs are disclosed, the delegator can perform an analogous check to ensure the destination script matches their policy template and to calculate outflows. Let D be the descriptor expressed in untweaked keys, W the provided witness script, and T the tweak mapping:\n+\n+<div>\n+Algorithm ''ChangeOutputVerification(D, W, T)'':\n+* Inputs:\n+** ''D'': wallet policy or descriptor template expressed in terms of the untweaked participant keys ''P<sub>i</sub>''\n+** ''W'': witness script disclosed for the change output\n+** ''T'': mapping from each ''P<sub>i</sub>'' to a 32-byte big-endian tweak scalar ''t<sub>i</sub>''\n+* For each participant key ''P<sub>i</sub>'' referenced in ''T'':\n+** Retrieve ''t<sub>i</sub>'' from ''T''; fail if the entry is missing or malformed.\n+** If the verifier controls the corresponding private key ''d<sub>i</sub>'', let ''d′<sub>i</sub> = (d<sub>i</sub> + t<sub>i</sub>) mod n'' and ''P′<sub>i</sub> = d′<sub>i</sub> · G''; otherwise let ''P′<sub>i</sub> = P<sub>i</sub> + t<sub>i</sub> · G''.\n+* Let ''D′'' be the descriptor formed by substituting every occurrence of ''P<sub>i</sub>'' in ''D'' with ''P′<sub>i</sub>''.\n+* Derive the witness script ''W′'' from ''D′''.\n+* Return <code>true</code> if ''W′ = W'', otherwise <code>false</code>.\n+</div>\n+\n+Successful verification ensures the change output commits to the tweaked participant keys implied by the CCD tweaks, preserving the intended policy.\n+\n+=====Delegator Signing=====\n+A delegator that holds only its base secret key <code>x</code> and public key <code>P</code> uses the delegated tweak bundle to derive per-input signing keys. The delegator MAY first call ''InputVerification'' and ''ChangeOutputVerification'' on any input and change output that provides a tweak in order to confirm outflow or policy requirements before signing.\n+\n+<div>\n+Algorithm ''DelegatorSign(t, x, m)'':\n+* Inputs:\n+** ''t'': aggregated tweak for the signing context (scalar mod ''n'')\n+** ''x'': delegator base secret key\n+** ''m'': message to be signed (for example, a transaction digest under the desired SIGHASH policy)\n+* Let ''x′ = (x + t) mod n''.\n+* Use secret key ''x′'' to produce the required signature ''σ'' under the indicated policy.\n+* Return ''σ''.\n+</div>\n+\n+The caller is responsible for inserting ''σ'' into the surrounding protocol (e.g., a PSBT, transaction witness, or adaptor signature exchange).\n+\n+====Blinded Signing====\n+The delegator learns neither the message, the challenge, or the public key used in the BIP340 signature, only a blinded challenge e'.\n+\n+This blind‑signing protocol specifies how a delegator can produce a blind partial Schnorr signature that a delegatee can unblind into a standard [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] signature under a possibly tweaked X‑only public key. The notation, algorithmic patterns, and test‑vector style are adapted from [BIP‑327 (MuSig2)] and from the [https://github.com/siv2r/bip-frost-signing FROST Signing BIP]. The design follows the “plain” blind Schnorr flow described in Concurrently Secure Blind Schnorr Signatures ([https://eprint.iacr.org/2022/1676 ePrint 2022/1676]), but without the concurrency hardening from that work.\n+\n+The output signature is a BIP340 Schnorr signature valid under an X‑only key obtained by applying a sequence of plain (e.g. BIP32) and X‑only (e.g. Tapscript) tweaks to the signer’s plain public key. Consequently the protocol is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]. The delegator learns neither the message, the challenge, or the public key used in the BIP340 signature, only a blinded challenge e'.\n+\n+The plain protocol here is '''not''' concurrently secure. A signer '''MUST NOT''' run multiple blind signing sessions in parallel or interleave state across sessions. A signer '''MUST''' refuse any new blind‑nonce requests while a previous blind‑signature request is outstanding, or '''MUST''' irrevocably discard (and never reuse) any in‑flight blind nonce commitments that have not resulted in a signature, before accepting new ones.\n+\n+To obtain concurrency security as in ([https://eprint.iacr.org/2022/1676 ePrint 2022/1676]), the delegatee first sends an encryption of (m, a, b) before the signer commits to the blind nonce; later, the delegatee includes a zero‑knowledge proof binding the produced challenge to that encrypted tuple. That proof can additionally encode policy predicates about m (spend limits, velocity controls, etc.). A complete specification of this variant is outside the scope of this BIP.\n+\n+===== Overview =====\n+\n+* '''Round 1 (blind nonce).''' The delegator runs ''BlindNonceGen'' to produce ''blindsecnonce'' and ''blindpubnonce'' and sends ''blindpubnonce'' to the delegatee.\n+* '''Round 2 (challenge).''' The delegatee runs ''BlindChallengeGen'' using the message ''m'', ''blindpubnonce'', the base public key ''pk'', and a list of ordinary and X-only tweaks, to produce a ''session context'' (kept locally for unblinding), a ''blindchallenge'', and two booleans ''pk_parity'' and ''nonce_parity''. The delegatee sends ''blindchallenge'', ''pk_parity'', and ''nonce_parity'' to the signer.\n+* '''Round 3 (blind signature).''' The delegator runs ''BlindSign'' with ''sk'', ''blindchallenge'', ''blindsecnonce'', ''pk_parity'', and ''nonce_parity'' and returns ''blindsignature''. The delegatee completes by calling ''UnblindSignature'' with the stored session context and ''blindsignature'' to obtain the final BIP340 signature ''sig''.\n+\n+''BlindSign'' '''MUST NOT''' be executed twice with the same ''blindsecnonce''. As a defense, implementations '''SHOULD''' overwrite the first 64 bytes of ''blindsecnonce'' with zeros after they have been read by ''BlindSign''.\n+\n+=====Key Tweaking=====\n+======Tweak Context======\n+The Tweak Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = tweak_ctx''\" to assign names to the elements of a Tweak Context.\n+\n+<div>\n+Algorithm ''TweakCtxInit(pk)'':\n+* Input:\n+** The base public key pk: a 33-byte array\n+* Let ''Q = cpoint(pk)''\n+* Fail if ''is_infinite(Q)''\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''tweak_ctx = (Q, gacc, tacc)''\n+</div>\n+\n+<div>\n+Algorithm ''ApplyTweak(tweak_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''tweak_ctx'': a [[#tweak-context|Tweak Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = tweak_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''tweak_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=====Blind Nonce Generation=====\n+\n+<div>\n+Algorithm ''BlindNonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The base secret signing key ''sk'': a 32-byte array (optional argument)\n+** The base public key ''pk'': a 33-byte array (optional argument)\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash256<sub>CCD/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k' = int(hash256<sub>CCD/blindnonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(4, len(extra_in)) || extra_in )) mod n''\n+* Fail if ''k' = 0''\n+* Let ''R' = k'⋅G''\n+* Let ''blindpubnonce = cbytes(R')''\n+* Let ''blindsecnonce = bytes(32, k' || pk)''<ref name=\"blindsecnonce\">The algorithms as specified here assume that the ''blindsecnonce'' is stored as a 65-byte array using the serialization ''blindsecnonce = bytes(32, k') || pk''. The same format is used in the reference implementation and in the test vectors. However, since the ''blindsecnonce'' is not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the ''blindsecnonce'' is merely a suggestion.<br />\n+The ''blindsecnonce'' is effectively a local data structure of the signer which comprises the value double ''(k', pk)'', and implementations may choose any suitable method to carry it from ''BlindNonceGen'' (first communication round) to ''BlindSign'' (third communication round). In particular, implementations may choose to hide the ''blindsecnonce'' in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a ''blindsecnonce'' accidentally.</ref>\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=====Session Context=====\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The base public key ''pk'': a 33-byte array\n+* The blind factor ''blindfactor'': a 32-byte array\n+* The challenge hash ''challenge'': a 32-byte array\n+* The public nonce ''pubnonce'': a 33-byte array\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+\n+We write \"Let ''(pk, blindfactor, challenge, pubnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(pk, blindfactor, challenge, pubnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>) = session_ctx''\n+* Let ''tweak_ctx<sub>0</sub> = TweakCtxInit(pk)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''tweak_ctx<sub>i</sub> = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = tweak_ctx<sub>v</sub>''\n+* Let ''a = int(blindfactor)''; fail if ''a ≥ n''\n+* Let ''b = int(blindfactor)''; fail if ''b ≥ n''\n+* Let ''e = int(challenge)''; fail if ''e ≥ n''\n+* Let ''R = cpoint(pubnonce)''; fail if that fails\n+* Return ''(Q, gacc, tacc, a, e, R)''\n+</div>\n+\n+=====Blind Challenge Generation=====\n+\n+<div>\n+Algorithm ''BlindChallengeGen(m, blindpubnonce, pk, tweak<sub>1..v</sub>, is_xonly<sub>1..v</sub>, extra_in)'':\n+* Inputs:\n+** The message ''m'': a byte array\n+** The blind public nonce ''blindpubnonce'': a 33-byte array\n+** The base public key ''pk'': a 33-byte array\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly<sub>1..v</sub>'': ''v'' booleans \n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* If ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''(Q, gacc, tacc) = TweakCtxInit(pk)''\n+* For ''i = 1 .. v'':\n+** Let ''(Q, gacc, tacc) = ApplyTweak((Q, gacc, tacc), tweak<sub>i</sub>, is_xonly<sub>i</sub>)''; fail if that fails \n+* Let ''cpk = cbytes(Q)''\n+* Draw 32 random bytes ''rand''\n+* Let ''z = hash512<sub>CCD/blindfactor</sub>(rand || bytes(1, len(cpk)) || cpk || bytes(1, len(blindpubnonce)) || blindpubnonce || bytes(8, len(m)) || m || bytes(4, len(extra_in)) || extra_in)''\n+* Let ''a' = int(z[0:32]) mod n''; fail if ''a' = 0''\n+* Let ''b' = int(z[32:64]) mod n''; fail if ''b' = 0''\n+* Let ''g = 1'' if ''has_even_y(Q)'', else ''g = −1 mod n''\n+* Let ''pk_parity = (g⋅gacc mod n == 1)''\n+* Let ''X' = cpoint(pk)''; let ''X = X' '' if ''pk_parity'' else ''−X' ''\n+* Let ''R' = cpoint(blindpubnonce)''\n+* Let ''R = R' + a'⋅G + b'⋅X''; fail if ''is_infinite(R)''\n+* Let ''nonce_parity = has_even_y(R)''\n+* If ''nonce_parity'':\n+** Let ''a = a' '', ''b = b' ''\n+* Else:\n+** Let ''a = n − a' '', ''b = n − b' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Let ''e' = (e + b) mod n''\n+* Let ''session_ctx = (pk, bytes(32, a), bytes(32, e), cbytes(R), tweak<sub>1..v</sub>, is_xonly<sub>1..v</sub>)''\n+* Return ''(session_ctx, bytes(32, e'), pk_parity, nonce_parity)''\n+</div>\n+\n+=====Blind Signing=====\n+\n+<div>\n+Algorithm ''BlindSign(sk, blindchallenge, blindsecnonce, pk_parity, nonce_parity)'':\n+* Inputs:\n+** The secret key ''sk'': a 32-byte array\n+** The blind challenge ''blindchallenge'': a 32-byte array ''e' ''\n+** The secret nonce ''blindsecnonce'': a byte array whose first 32 bytes are ''k'' (remaining bytes are implementation-defined)\n+** ''pk_parity'': boolean (from ''BlindChallengeGen'')\n+** ''nonce_parity'': boolean (from ''BlindChallengeGen'')\n+* Let ''d' = int(sk)''; fail if ''d' = 0'' or ''d' ≥ n''\n+* Let ''P = d'⋅G''; fail if ''is_infinite(P)''\n+* Let ''d = d' '' if ''pk_parity'' else ''n − d' ''\n+* Let ''e' = int(blindchallenge)''; fail if ''e' ≥ n''\n+* Let ''k' = int(blindsecnonce[0:32])''; fail if ''k' = 0'' or ''k' ≥ n''\n+* Let ''k = k' '' if ''nonce_parity'' else ''n − k' ''\n+* Overwrite ''blindsecnonce[0:64]'' with 64 zero bytes<ref> This helps prevent accidental nonce reuse. A zeroed ''blindsecnonce'' MUST cause subsequent ''BlindSign'' calls to fail.</ref>\n+* Let ''R' = k'⋅G''; fail if ''is_infinite(R')''<ref> This check holds except with negligible probability.</ref>\n+* Let ''s' = (k + e'⋅d) mod n''\n+* If ''VerifyBlindSignature(cbytes(P), cbytes(R'), blindchallenge, bytes(32, s'), pk_parity, nonce_parity)'' returns failure, abort\n+* Return ''blindsignature = bytes(32, s')''\n+</div>\n+\n+<div>\n+Algorithm ''VerifyBlindSignature(pk, blindpubnonce, blindchallenge, blindsignature, pk_parity, nonce_parity)'':\n+* Inputs:\n+** ''pk'': a 33-byte compressed public key\n+** ''blindpubnonce'': the signer’s 33-byte ''R' = k'⋅G''\n+** ''blindchallenge'': 32-byte ''e' ''\n+** ''blindsignature'': 32-byte ''s' ''\n+** ''pk_parity, nonce_parity'': booleans\n+* Let ''P' ' = cpoint(pk)''; let ''P = P' '' if ''pk_parity'' else ''−P' '' ; fail if ''is_infinite(P)''\n+* Let ''R' ' = cpoint(blindpubnonce)''; let ''R = R' '' if ''nonce_parity'' else ''−R' ''\n+* Let ''e' = int(blindchallenge)'', ''s' = int(blindsignature)''\n+* Return success iff ''s'⋅G == R + e'⋅P''\n+</div>\n+\n+=====Unblinding=====\n+\n+<div>\n+Algorithm ''UnblindSignature(session_ctx, blindsignature)'':\n+* Inputs:\n+** ''session_ctx'': as defined above\n+** ''blindsignature'': the 32-byte ''s' '' returned by the signer\n+* Let ''(Q, gacc, tacc, a, e, R) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', else ''g = −1 mod n''\n+* Let ''s' = int(blindsignature)''; fail if ''s' ≥ n''\n+* Let ''s = (s' + a + e⋅g⋅tacc) mod n''\n+* Return the BIP340 signature ''sig = xbytes(R) || bytes(32, s)''\n+</div>\n+\n+== Security Considerations ==\n+* Exposure of any delegated tweak scalar <code>t</code> enables signing only for the specific child key(s) that scalar was derived for, and is typically short-lived if disclosed immediately before spending.\n+* Delegatees MUST ensure every delegated path remains non-hardened and that ''ComputeBIP32Tweak'' yields the correct tweak <code>t</code>; incorrect scalars can render funds unspendable by the delegator.\n+* Delegators MUST verify change outputs when tweak data is provided (for example via ''ChangeOutputVerification'') to avoid authorizing unexpected scripts.\n+* Reusing the same k' (first 32 bytes in blindsecnonce) across two BlindSign calls allows recovery of the base secret key.\n+* When using blinded signing, opening multiple sessions concurrently against the same signer can allow an attacker to learn the base secret key. If concurrency is required, use the concurrently secure variant (encryption + ZK) instead (not specified in this BIP).\n+\n+== Test Vectors ==\n+A [[bip-chaincode-delegation/vectors|collection of JSON test vectors]] are provided, along with a [[bip-chaincode-delegation/reference.py|python reference implementation]].\n+\n+You may also find example code of CCD in action [https://github.com/jurvis/chaincode-delegation here].\n+\n+== Change Log ==",
      "path": "bip-chaincode-delegation.mediawiki",
      "position": 1,
      "original_position": 379,
      "commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "original_commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit, BIP3 standardizes this title\n\n```suggestion\n== Changelog ==\n```",
      "created_at": "2025-11-25T19:42:04Z",
      "updated_at": "2025-11-25T19:51:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2004#discussion_r2561191313",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2561191313"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2004"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 379,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2561193535",
      "pull_request_review_id": 3506500865,
      "id": 2561193535,
      "node_id": "PRRC_kwDOAN28mc6YqLY_",
      "diff_hunk": "@@ -0,0 +1,394 @@\n+<pre>\n+BIP: ???? \n+Layer: Applications\n+Title: Chain Code Delegation\n+Author: Jesse Posner <jesse@vora.io>, Jurvis Tan <jurvis@block.xyz>\n+Status: Draft\n+Type: Standards Track\n+Created: 2025-10-14\n+License: BSD-3-Clause\n+</pre>\n+\n+== Abstract ==\n+Chain Code Delegation (CCD) is a method for multi-signature wallets in which a privileged participant withholds BIP32 chain codes from one or more non-privileged participants, and supplies per-input scalar tweaks at signing time. This allows non-privileged participants to co-sign transactions without learning wallet-wide derivations, balances, or signing activity from other spending combinations. CCD defines the tweak exchange needed for verification and signing behavior when the signer does not possess a chain code.\n+\n+== Motivation ==\n+In multisig deployments, sharing extended public keys (xpubs) or descriptors enables all participants to scan the chain and infer counterparties' activity. CCD limits that visibility by ensuring non-privileged participants only ever hold a non-extended keypair and only receive the minimum per-spend data needed to sign. The procedure keeps policy enforcement feasible for the non-privileged signer while preserving balance privacy, which is particularly useful in collaborative custody arrangements where the wallet owner wants balance privacy from their custodian.\n+\n+== Terminology ==\n+* A \"Delegatee\" is a participant who retains a BIP32 chain code for another participant's base public key and computes derivation tweaks for that participant.\n+* A \"Delegator\" is a participant who holds only a non-extended keypair and receives scalar tweaks from a delegatee when asked to sign.\n+* A \"Participant\" is any key holder in the wallet quorum (including delegators and delegatees).\n+* A \"Non-hardened derivation\" is a BIP32 child derivation where index &lt; 2^31.\n+\n+== Overview ==\n+CCD operates by having Delegatees deprive Delegators of BIP32 chain codes during setup and later conveying the aggregated scalar tweak computed as the sum of non-hardened derivation tweaks along the remaining path to the child key used by a given input or change output. A Delegator uses the tweak to compute the child keys for verification and signing without being able to derive or recognize keys for other paths.\n+\n+== Specification ==\n+\n+=== Key material and setup ===\n+* '''Delegator key:''' Each delegator generates a standard (non-extended) secp256k1 keypair and provides the public key to the counterparties. A delegator MUST NOT retain or be provided a chain code for this key.\n+* '''Delegated chain code:''' A designated delegatee computes and retains a BIP32 chain code bound to the delegator's public key, forming an xpub that MUST NOT be disclosed to the delegator. The delegatee MAY share this xpub with other delegatees.\n+* '''Other participants:''' Non-delegator participants use conventional extended keys and share the public half as appropriate for the wallet descriptor.\n+* '''Derivation constraints:''' All key paths used with CCD MUST be non-hardened beyond the depth visible to the delegator. Hardened steps prevent computation of the needed tweak and are therefore NOT supported.\n+\n+=== Notation ===\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this proposal to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''hash256<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+** The function ''hash512<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 64-byte hash ''SHA512(SHA512(tag) || SHA512(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Tweak Calculation ===\n+To produce CCD tweak data, a delegatee computes a per-participant scalar that aggregates the non-hardened derivation tweaks along the remaining path. Let the extended key retained by the delegatee be P at depth d, and let the target index vector be I = (i<sub>d+1</sub>, …, i<sub>n</sub>) with each i<sub>k</sub> < 2<sup>31</sup>.\n+\n+<div>\n+Algorithm ''ComputeBIP32Tweak(P, I)'':\n+* Inputs:\n+** ''P'': base public key at depth ''d''\n+** ''I = (i<sub>d+1</sub>, …, i<sub>n</sub>)'': ordered sequence of non-hardened child indices\n+* Let ''t = 0'' and ''E = P''.\n+* For each index ''i'' in ''I'' (from left to right):\n+** Run the BIP32 non-hardened derivation ''CKDpub'' on ''E'' with child index ''i'', yielding the child extended key ''P<sub>child</sub>'' and its scalar tweak ''δ'' (the parse<sub>256</sub>(''I<sub>L</sub>'') term from BIP32).\n+** Let ''t = (t + δ) mod n''.\n+** Let ''E = P<sub>child</sub>''.\n+* If ''I'' is empty, let ''P′ = P''; otherwise let ''P′ = P<sub>child</sub>'' from the final iteration.\n+* Return ''(t, P′)''.\n+</div>\n+\n+Any attempt to apply a hardened derivation (index ≥ 2<sup>31</sup>) MUST fail. Delegatees MAY discard P′ after extracting t if it is not otherwise required.\n+\n+=== Delegation Bundle ===\n+CCD requires the delegatee to provide per-participant tweaks for inputs and (optionally) change outputs. Change outputs are only required if a delegator wants to be able to compute the amount of bitcoin they are spending. \n+\n+A delegatee MUST provide each delegator with, for every signing context, a collection of tuples (P<sub>i</sub>, t<sub>i</sub>) where P<sub>i</sub> is the participant's base public key disclosed to the delegator and t<sub>i</sub> is the aggregated tweak returned by ''ComputeBIP32Tweak''. The scalar t<sub>i</sub> MUST be encoded as a 32-byte big-endian integer. \n+\n+The transport that carries this bundle is out of scope for this proposal; implementers MAY use PSBT proprietary keys, RPC payloads, or bespoke messages as long as the delegator can authenticate the origin of the data. Delegatees SHOULD attach the witness script (or sufficient script template information) built with the tweaked keys when the delegator is expected to verify the input or enforce spending policy on change outputs.\n+\n+Delegators use the supplied CCD tweak bundle during verification (see ''Delegator input and change verification'') and signature generation (see ''DelegatorSign'').\n+\n+=== Delegatee Signing ===\n+This BIP supports two modes:\n+* '''Non‑blinded.''' The delegator receives the tweak for the child public key and the message. The delegator learns only about the specific child keys and transactions it signs for; it does not learn the wider address space.\n+* '''Blinded.''' The delegator receives only a blinded challenge and parity bits. The delegator learns nothing about the message or child key for which it produces a signature.\n+\n+Both modes produce valid BIP340 signatures.\n+\n+====Non-Blinded Signing====\n+For non-blinded signing, the delegatee can apply the signatures as usual.\n+\n+=====Delegator input and change verification (Optional)=====\n+A delegator MAY validate the data it receives before producing signatures. \n+\n+For example, input verification reassures the delegator that every tweaked key they are asked to sign for corresponds to a wallet input they recognise. Change verification lets them establish the net outflow and enforce spending policy.\n+\n+Both checks rely on the same delegated tweak bundle described above.\n+\n+=====Input verification=====\n+For each input, the delegatee SHOULD disclose the descriptor template, the untweaked participant keys, the input witness script, and the per-participant tweaks. The delegator then applies the following procedure.\n+\n+<div>\n+Algorithm ''InputVerification(D, W, T)'':\n+* Inputs:\n+** ''D'': wallet policy or descriptor template expressed in terms of the untweaked participant keys ''P<sub>i</sub>''\n+** ''W'': witness script disclosed for the input under review\n+** ''T'': mapping from each ''P<sub>i</sub>'' to a 32-byte big-endian tweak scalar ''t<sub>i</sub>''\n+* For each participant key ''P<sub>i</sub>'' referenced in ''D'':\n+** Retrieve ''t<sub>i</sub>'' from ''T''; fail if the entry is missing or malformed.\n+** If the verifier controls the corresponding private key ''d<sub>i</sub>'', let ''d′<sub>i</sub> = (d<sub>i</sub> + t<sub>i</sub>) mod n'' and ''P′<sub>i</sub> = d′<sub>i</sub> · G''; otherwise let ''P′<sub>i</sub> = P<sub>i</sub> + t<sub>i</sub> · G''.\n+* Let ''D′'' be the descriptor formed by substituting every occurrence of ''P<sub>i</sub>'' in ''D'' with ''P′<sub>i</sub>''.\n+* Derive the witness script ''W′'' from ''D′''.\n+* Return <code>true</code> if ''W′ = W'', otherwise <code>false</code>.\n+</div>\n+\n+Successful verification of an input confirms that the delegator is signing for a script that belongs to the wallet and that the aggregate tweak values align with the expected policy.\n+\n+=====Change-output verification=====\n+When change outputs are disclosed, the delegator can perform an analogous check to ensure the destination script matches their policy template and to calculate outflows. Let D be the descriptor expressed in untweaked keys, W the provided witness script, and T the tweak mapping:\n+\n+<div>\n+Algorithm ''ChangeOutputVerification(D, W, T)'':\n+* Inputs:\n+** ''D'': wallet policy or descriptor template expressed in terms of the untweaked participant keys ''P<sub>i</sub>''\n+** ''W'': witness script disclosed for the change output\n+** ''T'': mapping from each ''P<sub>i</sub>'' to a 32-byte big-endian tweak scalar ''t<sub>i</sub>''\n+* For each participant key ''P<sub>i</sub>'' referenced in ''T'':\n+** Retrieve ''t<sub>i</sub>'' from ''T''; fail if the entry is missing or malformed.\n+** If the verifier controls the corresponding private key ''d<sub>i</sub>'', let ''d′<sub>i</sub> = (d<sub>i</sub> + t<sub>i</sub>) mod n'' and ''P′<sub>i</sub> = d′<sub>i</sub> · G''; otherwise let ''P′<sub>i</sub> = P<sub>i</sub> + t<sub>i</sub> · G''.\n+* Let ''D′'' be the descriptor formed by substituting every occurrence of ''P<sub>i</sub>'' in ''D'' with ''P′<sub>i</sub>''.\n+* Derive the witness script ''W′'' from ''D′''.\n+* Return <code>true</code> if ''W′ = W'', otherwise <code>false</code>.\n+</div>\n+\n+Successful verification ensures the change output commits to the tweaked participant keys implied by the CCD tweaks, preserving the intended policy.\n+\n+=====Delegator Signing=====\n+A delegator that holds only its base secret key <code>x</code> and public key <code>P</code> uses the delegated tweak bundle to derive per-input signing keys. The delegator MAY first call ''InputVerification'' and ''ChangeOutputVerification'' on any input and change output that provides a tweak in order to confirm outflow or policy requirements before signing.\n+\n+<div>\n+Algorithm ''DelegatorSign(t, x, m)'':\n+* Inputs:\n+** ''t'': aggregated tweak for the signing context (scalar mod ''n'')\n+** ''x'': delegator base secret key\n+** ''m'': message to be signed (for example, a transaction digest under the desired SIGHASH policy)\n+* Let ''x′ = (x + t) mod n''.\n+* Use secret key ''x′'' to produce the required signature ''σ'' under the indicated policy.\n+* Return ''σ''.\n+</div>\n+\n+The caller is responsible for inserting ''σ'' into the surrounding protocol (e.g., a PSBT, transaction witness, or adaptor signature exchange).\n+\n+====Blinded Signing====\n+The delegator learns neither the message, the challenge, or the public key used in the BIP340 signature, only a blinded challenge e'.\n+\n+This blind‑signing protocol specifies how a delegator can produce a blind partial Schnorr signature that a delegatee can unblind into a standard [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] signature under a possibly tweaked X‑only public key. The notation, algorithmic patterns, and test‑vector style are adapted from [BIP‑327 (MuSig2)] and from the [https://github.com/siv2r/bip-frost-signing FROST Signing BIP]. The design follows the “plain” blind Schnorr flow described in Concurrently Secure Blind Schnorr Signatures ([https://eprint.iacr.org/2022/1676 ePrint 2022/1676]), but without the concurrency hardening from that work.\n+\n+The output signature is a BIP340 Schnorr signature valid under an X‑only key obtained by applying a sequence of plain (e.g. BIP32) and X‑only (e.g. Tapscript) tweaks to the signer’s plain public key. Consequently the protocol is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]. The delegator learns neither the message, the challenge, or the public key used in the BIP340 signature, only a blinded challenge e'.\n+\n+The plain protocol here is '''not''' concurrently secure. A signer '''MUST NOT''' run multiple blind signing sessions in parallel or interleave state across sessions. A signer '''MUST''' refuse any new blind‑nonce requests while a previous blind‑signature request is outstanding, or '''MUST''' irrevocably discard (and never reuse) any in‑flight blind nonce commitments that have not resulted in a signature, before accepting new ones.\n+\n+To obtain concurrency security as in ([https://eprint.iacr.org/2022/1676 ePrint 2022/1676]), the delegatee first sends an encryption of (m, a, b) before the signer commits to the blind nonce; later, the delegatee includes a zero‑knowledge proof binding the produced challenge to that encrypted tuple. That proof can additionally encode policy predicates about m (spend limits, velocity controls, etc.). A complete specification of this variant is outside the scope of this BIP.\n+\n+===== Overview =====\n+\n+* '''Round 1 (blind nonce).''' The delegator runs ''BlindNonceGen'' to produce ''blindsecnonce'' and ''blindpubnonce'' and sends ''blindpubnonce'' to the delegatee.\n+* '''Round 2 (challenge).''' The delegatee runs ''BlindChallengeGen'' using the message ''m'', ''blindpubnonce'', the base public key ''pk'', and a list of ordinary and X-only tweaks, to produce a ''session context'' (kept locally for unblinding), a ''blindchallenge'', and two booleans ''pk_parity'' and ''nonce_parity''. The delegatee sends ''blindchallenge'', ''pk_parity'', and ''nonce_parity'' to the signer.\n+* '''Round 3 (blind signature).''' The delegator runs ''BlindSign'' with ''sk'', ''blindchallenge'', ''blindsecnonce'', ''pk_parity'', and ''nonce_parity'' and returns ''blindsignature''. The delegatee completes by calling ''UnblindSignature'' with the stored session context and ''blindsignature'' to obtain the final BIP340 signature ''sig''.\n+\n+''BlindSign'' '''MUST NOT''' be executed twice with the same ''blindsecnonce''. As a defense, implementations '''SHOULD''' overwrite the first 64 bytes of ''blindsecnonce'' with zeros after they have been read by ''BlindSign''.\n+\n+=====Key Tweaking=====\n+======Tweak Context======\n+The Tweak Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = tweak_ctx''\" to assign names to the elements of a Tweak Context.\n+\n+<div>\n+Algorithm ''TweakCtxInit(pk)'':\n+* Input:\n+** The base public key pk: a 33-byte array\n+* Let ''Q = cpoint(pk)''\n+* Fail if ''is_infinite(Q)''\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''tweak_ctx = (Q, gacc, tacc)''\n+</div>\n+\n+<div>\n+Algorithm ''ApplyTweak(tweak_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''tweak_ctx'': a [[#tweak-context|Tweak Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = tweak_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''tweak_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=====Blind Nonce Generation=====\n+\n+<div>\n+Algorithm ''BlindNonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The base secret signing key ''sk'': a 32-byte array (optional argument)\n+** The base public key ''pk'': a 33-byte array (optional argument)\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash256<sub>CCD/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k' = int(hash256<sub>CCD/blindnonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(4, len(extra_in)) || extra_in )) mod n''\n+* Fail if ''k' = 0''\n+* Let ''R' = k'⋅G''\n+* Let ''blindpubnonce = cbytes(R')''\n+* Let ''blindsecnonce = bytes(32, k' || pk)''<ref name=\"blindsecnonce\">The algorithms as specified here assume that the ''blindsecnonce'' is stored as a 65-byte array using the serialization ''blindsecnonce = bytes(32, k') || pk''. The same format is used in the reference implementation and in the test vectors. However, since the ''blindsecnonce'' is not meant to be sent over the wire, compatibility between implementations is not a concern, and this method of storing the ''blindsecnonce'' is merely a suggestion.<br />\n+The ''blindsecnonce'' is effectively a local data structure of the signer which comprises the value double ''(k', pk)'', and implementations may choose any suitable method to carry it from ''BlindNonceGen'' (first communication round) to ''BlindSign'' (third communication round). In particular, implementations may choose to hide the ''blindsecnonce'' in internal state without exposing it in an API explicitly, e.g., in an effort to prevent callers from reusing a ''blindsecnonce'' accidentally.</ref>\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=====Session Context=====\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The base public key ''pk'': a 33-byte array\n+* The blind factor ''blindfactor'': a 32-byte array\n+* The challenge hash ''challenge'': a 32-byte array\n+* The public nonce ''pubnonce'': a 33-byte array\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+\n+We write \"Let ''(pk, blindfactor, challenge, pubnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(pk, blindfactor, challenge, pubnonce, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>) = session_ctx''\n+* Let ''tweak_ctx<sub>0</sub> = TweakCtxInit(pk)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''tweak_ctx<sub>i</sub> = ApplyTweak(tweak_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = tweak_ctx<sub>v</sub>''\n+* Let ''a = int(blindfactor)''; fail if ''a ≥ n''\n+* Let ''b = int(blindfactor)''; fail if ''b ≥ n''\n+* Let ''e = int(challenge)''; fail if ''e ≥ n''\n+* Let ''R = cpoint(pubnonce)''; fail if that fails\n+* Return ''(Q, gacc, tacc, a, e, R)''\n+</div>\n+\n+=====Blind Challenge Generation=====\n+\n+<div>\n+Algorithm ''BlindChallengeGen(m, blindpubnonce, pk, tweak<sub>1..v</sub>, is_xonly<sub>1..v</sub>, extra_in)'':\n+* Inputs:\n+** The message ''m'': a byte array\n+** The blind public nonce ''blindpubnonce'': a 33-byte array\n+** The base public key ''pk'': a 33-byte array\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly<sub>1..v</sub>'': ''v'' booleans \n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* If ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''(Q, gacc, tacc) = TweakCtxInit(pk)''\n+* For ''i = 1 .. v'':\n+** Let ''(Q, gacc, tacc) = ApplyTweak((Q, gacc, tacc), tweak<sub>i</sub>, is_xonly<sub>i</sub>)''; fail if that fails \n+* Let ''cpk = cbytes(Q)''\n+* Draw 32 random bytes ''rand''\n+* Let ''z = hash512<sub>CCD/blindfactor</sub>(rand || bytes(1, len(cpk)) || cpk || bytes(1, len(blindpubnonce)) || blindpubnonce || bytes(8, len(m)) || m || bytes(4, len(extra_in)) || extra_in)''\n+* Let ''a' = int(z[0:32]) mod n''; fail if ''a' = 0''\n+* Let ''b' = int(z[32:64]) mod n''; fail if ''b' = 0''\n+* Let ''g = 1'' if ''has_even_y(Q)'', else ''g = −1 mod n''\n+* Let ''pk_parity = (g⋅gacc mod n == 1)''\n+* Let ''X' = cpoint(pk)''; let ''X = X' '' if ''pk_parity'' else ''−X' ''\n+* Let ''R' = cpoint(blindpubnonce)''\n+* Let ''R = R' + a'⋅G + b'⋅X''; fail if ''is_infinite(R)''\n+* Let ''nonce_parity = has_even_y(R)''\n+* If ''nonce_parity'':\n+** Let ''a = a' '', ''b = b' ''\n+* Else:\n+** Let ''a = n − a' '', ''b = n − b' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Let ''e' = (e + b) mod n''\n+* Let ''session_ctx = (pk, bytes(32, a), bytes(32, e), cbytes(R), tweak<sub>1..v</sub>, is_xonly<sub>1..v</sub>)''\n+* Return ''(session_ctx, bytes(32, e'), pk_parity, nonce_parity)''\n+</div>\n+\n+=====Blind Signing=====\n+\n+<div>\n+Algorithm ''BlindSign(sk, blindchallenge, blindsecnonce, pk_parity, nonce_parity)'':\n+* Inputs:\n+** The secret key ''sk'': a 32-byte array\n+** The blind challenge ''blindchallenge'': a 32-byte array ''e' ''\n+** The secret nonce ''blindsecnonce'': a byte array whose first 32 bytes are ''k'' (remaining bytes are implementation-defined)\n+** ''pk_parity'': boolean (from ''BlindChallengeGen'')\n+** ''nonce_parity'': boolean (from ''BlindChallengeGen'')\n+* Let ''d' = int(sk)''; fail if ''d' = 0'' or ''d' ≥ n''\n+* Let ''P = d'⋅G''; fail if ''is_infinite(P)''\n+* Let ''d = d' '' if ''pk_parity'' else ''n − d' ''\n+* Let ''e' = int(blindchallenge)''; fail if ''e' ≥ n''\n+* Let ''k' = int(blindsecnonce[0:32])''; fail if ''k' = 0'' or ''k' ≥ n''\n+* Let ''k = k' '' if ''nonce_parity'' else ''n − k' ''\n+* Overwrite ''blindsecnonce[0:64]'' with 64 zero bytes<ref> This helps prevent accidental nonce reuse. A zeroed ''blindsecnonce'' MUST cause subsequent ''BlindSign'' calls to fail.</ref>\n+* Let ''R' = k'⋅G''; fail if ''is_infinite(R')''<ref> This check holds except with negligible probability.</ref>\n+* Let ''s' = (k + e'⋅d) mod n''\n+* If ''VerifyBlindSignature(cbytes(P), cbytes(R'), blindchallenge, bytes(32, s'), pk_parity, nonce_parity)'' returns failure, abort\n+* Return ''blindsignature = bytes(32, s')''\n+</div>\n+\n+<div>\n+Algorithm ''VerifyBlindSignature(pk, blindpubnonce, blindchallenge, blindsignature, pk_parity, nonce_parity)'':\n+* Inputs:\n+** ''pk'': a 33-byte compressed public key\n+** ''blindpubnonce'': the signer’s 33-byte ''R' = k'⋅G''\n+** ''blindchallenge'': 32-byte ''e' ''\n+** ''blindsignature'': 32-byte ''s' ''\n+** ''pk_parity, nonce_parity'': booleans\n+* Let ''P' ' = cpoint(pk)''; let ''P = P' '' if ''pk_parity'' else ''−P' '' ; fail if ''is_infinite(P)''\n+* Let ''R' ' = cpoint(blindpubnonce)''; let ''R = R' '' if ''nonce_parity'' else ''−R' ''\n+* Let ''e' = int(blindchallenge)'', ''s' = int(blindsignature)''\n+* Return success iff ''s'⋅G == R + e'⋅P''\n+</div>\n+\n+=====Unblinding=====\n+\n+<div>\n+Algorithm ''UnblindSignature(session_ctx, blindsignature)'':\n+* Inputs:\n+** ''session_ctx'': as defined above\n+** ''blindsignature'': the 32-byte ''s' '' returned by the signer\n+* Let ''(Q, gacc, tacc, a, e, R) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', else ''g = −1 mod n''\n+* Let ''s' = int(blindsignature)''; fail if ''s' ≥ n''\n+* Let ''s = (s' + a + e⋅g⋅tacc) mod n''\n+* Return the BIP340 signature ''sig = xbytes(R) || bytes(32, s)''\n+</div>\n+\n+== Security Considerations ==\n+* Exposure of any delegated tweak scalar <code>t</code> enables signing only for the specific child key(s) that scalar was derived for, and is typically short-lived if disclosed immediately before spending.\n+* Delegatees MUST ensure every delegated path remains non-hardened and that ''ComputeBIP32Tweak'' yields the correct tweak <code>t</code>; incorrect scalars can render funds unspendable by the delegator.\n+* Delegators MUST verify change outputs when tweak data is provided (for example via ''ChangeOutputVerification'') to avoid authorizing unexpected scripts.\n+* Reusing the same k' (first 32 bytes in blindsecnonce) across two BlindSign calls allows recovery of the base secret key.\n+* When using blinded signing, opening multiple sessions concurrently against the same signer can allow an attacker to learn the base secret key. If concurrency is required, use the concurrently secure variant (encryption + ZK) instead (not specified in this BIP).\n+\n+== Test Vectors ==\n+A [[bip-chaincode-delegation/vectors|collection of JSON test vectors]] are provided, along with a [[bip-chaincode-delegation/reference.py|python reference implementation]].",
      "path": "bip-chaincode-delegation.mediawiki",
      "position": 1,
      "original_position": 375,
      "commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "original_commit_id": "edb4360fa70f220ca221e7654317e435ce3f79d4",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit, file naming throughout would be clearer as \"chain code\" (instead of \"chaincode\"), per BIP32 usage\n\n```suggestion\nA [[bip-chain-code-delegation/vectors|collection of JSON test vectors]] are provided, along with a [[bip-chaincode-delegation/reference.py|python reference implementation]].\n```",
      "created_at": "2025-11-25T19:43:01Z",
      "updated_at": "2025-11-25T19:51:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/2004#discussion_r2561193535",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/2561193535"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/2004"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    }
  ]
}