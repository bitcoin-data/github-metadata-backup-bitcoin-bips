{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1372",
    "id": 1075174761,
    "node_id": "PR_kwDOAN28mc5AFd1p",
    "html_url": "https://github.com/bitcoin/bips/pull/1372",
    "diff_url": "https://github.com/bitcoin/bips/pull/1372.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1372.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1372/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1372/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1372/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/87394eaeb436d02e0a68b38a1e94bc526d50056e",
    "number": 1372,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Add BIP MuSig2",
    "user": {
      "login": "jonasnick",
      "id": 2582071,
      "node_id": "MDQ6VXNlcjI1ODIwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasnick",
      "html_url": "https://github.com/jonasnick",
      "followers_url": "https://api.github.com/users/jonasnick/followers",
      "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasnick/orgs",
      "repos_url": "https://api.github.com/users/jonasnick/repos",
      "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jonasnick/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR adds a BIP for the MuSig2 protocol. We, the BIP authors, posted an initial draft version to the [bitcoin-dev mailing list in April](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020198.html). Since then, we have addressed feedback from the mailing list and the development git repository (to the best of our knowledge, we didn't leave feedback unaddressed). We kept the resulting change log in the BIP draft. In the past weeks, we received no requests for major changes or features, which indicates that it is a good time to stabilize the BIP draft. The development git repo is archived at https://github.com/jonasnick/bips.\r\n\r\nThere are already multiple (experimental) implementations of the draft, such as:\r\n- the reference python implementation included in this PR (supports BIP version 1.0.0)\r\n- a [libsecp256k1-zkp module](https://github.com/ElementsProject/secp256k1-zkp/blob/master/include/secp256k1_musig.h) (currently supports BIP version 0.1.0)\r\n- [btcec](https://github.com/btcsuite/btcd/tree/master/btcec/schnorr/musig2) (currently supports BIP version 0.4.0)\r\n- [secp256kfun](https://github.com/LLFourn/secp256kfun/blob/master/schnorr_fun/src/musig.rs) (supports BIP version 1.0.0)\r\n- [nbitcoin](https://github.com/MetacoSA/NBitcoin/pull/1128) (supports BIP version 1.0.0)\r\n\r\n**TODO:**\r\n\r\n- [x] resolve https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html\r\n- [x] after BIP number is assigned, replace alias `bip-musig2` with `bip-<number>`\r\n\r\nCC @real-or-random @robot-dreams\r\n\r\n",
    "labels": [],
    "created_at": "2022-10-03T20:35:31Z",
    "updated_at": "2023-03-27T09:43:03Z",
    "closed_at": "2023-03-27T09:40:32Z",
    "mergeable_state": "unknown",
    "merged_at": "2023-03-27T09:40:32Z",
    "merge_commit_sha": "67a42fe828fc43077c76985c6133adaf11b20cc6",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "jonasnick:musig2-squashed",
      "ref": "musig2-squashed",
      "sha": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 478321338,
        "node_id": "R_kgDOHIKaug",
        "name": "bips",
        "full_name": "jonasnick/bips",
        "owner": {
          "login": "jonasnick",
          "id": 2582071,
          "node_id": "MDQ6VXNlcjI1ODIwNzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/jonasnick",
          "html_url": "https://github.com/jonasnick",
          "followers_url": "https://api.github.com/users/jonasnick/followers",
          "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
          "organizations_url": "https://api.github.com/users/jonasnick/orgs",
          "repos_url": "https://api.github.com/users/jonasnick/repos",
          "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/jonasnick/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/jonasnick/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/jonasnick/bips",
        "archive_url": "https://api.github.com/repos/jonasnick/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/jonasnick/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/jonasnick/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/jonasnick/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/jonasnick/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/jonasnick/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/jonasnick/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/jonasnick/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/jonasnick/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/jonasnick/bips/contributors",
        "deployments_url": "https://api.github.com/repos/jonasnick/bips/deployments",
        "downloads_url": "https://api.github.com/repos/jonasnick/bips/downloads",
        "events_url": "https://api.github.com/repos/jonasnick/bips/events",
        "forks_url": "https://api.github.com/repos/jonasnick/bips/forks",
        "git_commits_url": "https://api.github.com/repos/jonasnick/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/jonasnick/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/jonasnick/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/jonasnick/bips.git",
        "issue_comment_url": "https://api.github.com/repos/jonasnick/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/jonasnick/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/jonasnick/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/jonasnick/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/jonasnick/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/jonasnick/bips/languages",
        "merges_url": "https://api.github.com/repos/jonasnick/bips/merges",
        "milestones_url": "https://api.github.com/repos/jonasnick/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/jonasnick/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/jonasnick/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/jonasnick/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:jonasnick/bips.git",
        "stargazers_url": "https://api.github.com/repos/jonasnick/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/jonasnick/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/jonasnick/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/jonasnick/bips/subscription",
        "tags_url": "https://api.github.com/repos/jonasnick/bips/tags",
        "teams_url": "https://api.github.com/repos/jonasnick/bips/teams",
        "trees_url": "https://api.github.com/repos/jonasnick/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/jonasnick/bips.git",
        "hooks_url": "https://api.github.com/repos/jonasnick/bips/hooks",
        "svn_url": "https://github.com/jonasnick/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5,
        "stargazers_count": 4,
        "watchers_count": 4,
        "size": 14153,
        "default_branch": "musig2",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-03-27T02:48:44Z",
        "created_at": "2022-04-05T22:34:04Z",
        "updated_at": "2022-10-03T23:18:28Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "a8a0191978b451aa3a8acd8a94f3197ff2fe16e5",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5535,
        "stargazers_count": 8220,
        "watchers_count": 8220,
        "size": 13787,
        "default_branch": "master",
        "open_issues_count": 112,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-01T12:09:15Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-08-01T09:08:43Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 2699,
    "deletions": 0,
    "changed_files": 13,
    "commits": 1,
    "review_comments": 15,
    "comments": 21
  },
  "events": [
    {
      "event": "mentioned",
      "id": 7510698556,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAG_rCo8",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7510698556",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-03T20:35:32Z"
    },
    {
      "event": "subscribed",
      "id": 7510698581,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAG_rCpV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7510698581",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-03T20:35:32Z"
    },
    {
      "event": "mentioned",
      "id": 7510698612,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAG_rCp0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7510698612",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-03T20:35:32Z"
    },
    {
      "event": "subscribed",
      "id": 7510698630,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAG_rCqG",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7510698630",
      "actor": {
        "login": "robot-dreams",
        "id": 4276679,
        "node_id": "MDQ6VXNlcjQyNzY2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4276679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/robot-dreams",
        "html_url": "https://github.com/robot-dreams",
        "followers_url": "https://api.github.com/users/robot-dreams/followers",
        "following_url": "https://api.github.com/users/robot-dreams/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/robot-dreams/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/robot-dreams/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/robot-dreams/subscriptions",
        "organizations_url": "https://api.github.com/users/robot-dreams/orgs",
        "repos_url": "https://api.github.com/users/robot-dreams/repos",
        "events_url": "https://api.github.com/users/robot-dreams/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/robot-dreams/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-03T20:35:32Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "kanzure",
        "id": 101238,
        "node_id": "MDQ6VXNlcjEwMTIzOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/101238?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kanzure",
        "html_url": "https://github.com/kanzure",
        "followers_url": "https://api.github.com/users/kanzure/followers",
        "following_url": "https://api.github.com/users/kanzure/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kanzure/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kanzure/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kanzure/subscriptions",
        "organizations_url": "https://api.github.com/users/kanzure/orgs",
        "repos_url": "https://api.github.com/users/kanzure/repos",
        "events_url": "https://api.github.com/users/kanzure/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kanzure/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-03T21:14:00Z",
      "updated_at": "2022-10-03T21:14:00Z",
      "source": {
        "issue": {
          "id": 1376786037,
          "node_id": "I_kwDOExOzMs5SEBZ1",
          "url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com/issues/11",
          "repository_url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com",
          "labels_url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com/issues/11/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com/issues/11/comments",
          "events_url": "https://api.github.com/repos/austinbitdevs/austinbitdevs.com/issues/11/events",
          "html_url": "https://github.com/austinbitdevs/austinbitdevs.com/issues/11",
          "number": 11,
          "state": "closed",
          "state_reason": "completed",
          "title": "October topics",
          "body": "https://blog.lopp.net/was-satoshi-a-greedy-miner/",
          "user": {
            "login": "justinmoon",
            "id": 4335621,
            "node_id": "MDQ6VXNlcjQzMzU2MjE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4335621?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/justinmoon",
            "html_url": "https://github.com/justinmoon",
            "followers_url": "https://api.github.com/users/justinmoon/followers",
            "following_url": "https://api.github.com/users/justinmoon/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/justinmoon/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/justinmoon/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/justinmoon/subscriptions",
            "organizations_url": "https://api.github.com/users/justinmoon/orgs",
            "repos_url": "https://api.github.com/users/justinmoon/repos",
            "events_url": "https://api.github.com/users/justinmoon/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/justinmoon/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "COLLABORATOR",
          "locked": false,
          "comments": 25,
          "closed_at": "2022-10-31T09:57:21Z",
          "created_at": "2022-09-17T14:21:29Z",
          "updated_at": "2022-10-31T09:57:21Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1266688254,
      "node_id": "IC_kwDOAN28mc5LgCD-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1266688254",
      "actor": {
        "login": "NicolasDorier",
        "id": 3020646,
        "node_id": "MDQ6VXNlcjMwMjA2NDY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/NicolasDorier",
        "html_url": "https://github.com/NicolasDorier",
        "followers_url": "https://api.github.com/users/NicolasDorier/followers",
        "following_url": "https://api.github.com/users/NicolasDorier/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/NicolasDorier/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/NicolasDorier/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
        "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
        "repos_url": "https://api.github.com/users/NicolasDorier/repos",
        "events_url": "https://api.github.com/users/NicolasDorier/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-04T09:48:52Z",
      "updated_at": "2022-10-04T09:48:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK, I spent lot's of time to implement MuSig2 through the several iterations of the specs.\r\nEven if I'm not well versed into cryptography, for the 1.0, I used this BIP + the python reference implementation as a guide, as well as passed through all the tests vectors, and could implement Musig2 without facing any issue.\r\nCongratulation for the quality of this BIP.",
      "user": {
        "login": "NicolasDorier",
        "id": 3020646,
        "node_id": "MDQ6VXNlcjMwMjA2NDY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/NicolasDorier",
        "html_url": "https://github.com/NicolasDorier",
        "followers_url": "https://api.github.com/users/NicolasDorier/followers",
        "following_url": "https://api.github.com/users/NicolasDorier/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/NicolasDorier/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/NicolasDorier/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
        "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
        "repos_url": "https://api.github.com/users/NicolasDorier/repos",
        "events_url": "https://api.github.com/users/NicolasDorier/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1266688254",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "convert_to_draft",
      "id": 7538487353,
      "node_id": "CTDE_lADOAN28mc5TKo-HzwAAAAHBVDA5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7538487353",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-06T20:32:27Z"
    },
    {
      "event": "commented",
      "id": 1270645765,
      "node_id": "IC_kwDOAN28mc5LvIQF",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1270645765",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-06T20:33:50Z",
      "updated_at": "2022-10-06T20:33:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "Marked as draft since there's still work to be done (BIP number) but it's ready to review.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1270645765",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T15:40:19Z",
      "updated_at": "2022-10-08T15:40:19Z",
      "source": {
        "issue": {
          "id": 1176976549,
          "node_id": "I_kwDOCKTKg85GJzyl",
          "url": "https://api.github.com/repos/rust-bitcoin/rust-miniscript/issues/319",
          "repository_url": "https://api.github.com/repos/rust-bitcoin/rust-miniscript",
          "labels_url": "https://api.github.com/repos/rust-bitcoin/rust-miniscript/issues/319/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/rust-bitcoin/rust-miniscript/issues/319/comments",
          "events_url": "https://api.github.com/repos/rust-bitcoin/rust-miniscript/issues/319/events",
          "html_url": "https://github.com/rust-bitcoin/rust-miniscript/issues/319",
          "number": 319,
          "state": "open",
          "state_reason": null,
          "title": "Is there a way of having aggregate signature in first Tr descriptor parameter?",
          "body": "Today `Tr` descriptor\r\n\r\n1. Fails to parse the whole descriptor if the first parameter contains a method (for instance, `tr(musig(a,b))` will treat `b` as a second parameter to the descriptor itself, i.e. script).\r\n2. this providing no way for key aggregation as a part of the first parameter.",
          "user": {
            "login": "dr-orlovsky",
            "id": 372034,
            "node_id": "MDQ6VXNlcjM3MjAzNA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/372034?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dr-orlovsky",
            "html_url": "https://github.com/dr-orlovsky",
            "followers_url": "https://api.github.com/users/dr-orlovsky/followers",
            "following_url": "https://api.github.com/users/dr-orlovsky/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dr-orlovsky/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dr-orlovsky/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dr-orlovsky/subscriptions",
            "organizations_url": "https://api.github.com/users/dr-orlovsky/orgs",
            "repos_url": "https://api.github.com/users/dr-orlovsky/repos",
            "events_url": "https://api.github.com/users/dr-orlovsky/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dr-orlovsky/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 14,
          "created_at": "2022-03-22T15:41:22Z",
          "updated_at": "2022-10-19T18:45:33Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1276202657,
      "node_id": "IC_kwDOAN28mc5MEU6h",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1276202657",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-12T13:48:17Z",
      "updated_at": "2022-10-12T13:48:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "Also, this PR is staying a draft until https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html is addressed.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1276202657",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "comment_deleted",
      "id": 7572354131,
      "node_id": "CDE_lADOAN28mc5TKo-HzwAAAAHDWPRT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7572354131",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-12T14:16:48Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7732927276,
      "node_id": "HRFPE_lADOAN28mc5TKo-HzwAAAAHM6xss",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7732927276",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-03T14:44:22Z"
    },
    {
      "event": "commented",
      "id": 1302233145,
      "node_id": "IC_kwDOAN28mc5NnoA5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1302233145",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-03T14:52:47Z",
      "updated_at": "2022-11-03T14:52:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Also, this PR is staying a draft until https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html is addressed.\r\n\r\nI pushed a version of the BIP draft that addresses this and therefore this PR is ready for review again. Note that we retroactively renamed the version `1.0.0` in our change log to `1.0.0-rc.1` (not great, but with this little cheat we have a coherent change log again).\r\n\r\nAs for the specific changes let me copy the post that I just send to bitcoin-dev:\r\n\r\n```\r\nWe updated the MuSig2 BIP draft to fix the vulnerability published in an earlier\r\npost [0].\r\n\r\nWe also wrote an article [1] that contains a description of\r\n1. the vulnerable scheme (remember that the original MuSig2 scheme is not\r\n   vulnerable because it doesn't allow tweaking)\r\n2. an attack against the vulnerable scheme using Wagner's algorithm\r\n3. a fixed scheme that permits tweaking\r\n\r\nMoreover, we implemented the \"BLLOR\" attack mentioned in the article which\r\nworks against the reference python implementation of the previous version of the\r\nMuSig2 BIP draft (takes about 7 minutes on my machine) [2].\r\n\r\nThe fix of the MuSig2 BIP is equivalent to the fix of the scheme in the article\r\n[1]: before calling ''NonceGen'', the signer must determine the (potentially\r\ntweaked) secret key it will use for this signature. BIP MuSig2 now ensures that\r\nusers can not accidentally violate this requirement by adding a mandatory public\r\nkey argument to ''NonceGen'', appending the public key to the ''secnonce'' array\r\nand checking the public key against the secret key in ''Sign'' (see the pull\r\nrequest for the detailed changes [3]).\r\n\r\n[0] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html\r\n[1] https://github.com/jonasnick/musig2-tweaking\r\n[2] https://gist.github.com/robot-dreams/89ce8c3ff16f70cb2c55ba4fe9fd1b31 (must\r\n    be copied into the bip-musig2 directory)\r\n[3] https://github.com/jonasnick/bips/pull/74 \r\n```",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1302233145",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "ready_for_review",
      "id": 7733013655,
      "node_id": "RFRE_lADOAN28mc5TKo-HzwAAAAHM7GyX",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/7733013655",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-03T14:52:54Z"
    },
    {
      "event": "reviewed",
      "id": 1189017631,
      "node_id": "PRR_kwDOAN28mc5G3vgf",
      "url": null,
      "actor": null,
      "commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Thanks for all of your work on this!\r\n\r\nI'm about half-way through updating my TypeScript implementation to match the latest spec, and have a few comments. Possibly more to come as I finish.\r\n\r\nThe new vectors are very helpful for me as an implementer. One comment on those is that it can take a careful reading of the reference implementation to find the right things to assert.",
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#pullrequestreview-1189017631",
      "submitted_at": "2022-11-23T00:31:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
    },
    {
      "event": "reviewed",
      "id": 1212693131,
      "node_id": "PRR_kwDOAN28mc5ISDqL",
      "url": null,
      "actor": null,
      "commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "manda2020panda",
        "id": 47097619,
        "node_id": "MDQ6VXNlcjQ3MDk3NjE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/47097619?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/manda2020panda",
        "html_url": "https://github.com/manda2020panda",
        "followers_url": "https://api.github.com/users/manda2020panda/followers",
        "following_url": "https://api.github.com/users/manda2020panda/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/manda2020panda/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/manda2020panda/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/manda2020panda/subscriptions",
        "organizations_url": "https://api.github.com/users/manda2020panda/orgs",
        "repos_url": "https://api.github.com/users/manda2020panda/repos",
        "events_url": "https://api.github.com/users/manda2020panda/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/manda2020panda/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#pullrequestreview-1212693131",
      "submitted_at": "2022-12-11T12:58:18Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-02T14:32:44Z",
      "updated_at": "2023-02-02T14:32:44Z",
      "source": {
        "issue": {
          "id": 1568167720,
          "node_id": "I_kwDOHIKaus5deFco",
          "url": "https://api.github.com/repos/jonasnick/bips/issues/76",
          "repository_url": "https://api.github.com/repos/jonasnick/bips",
          "labels_url": "https://api.github.com/repos/jonasnick/bips/issues/76/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/jonasnick/bips/issues/76/comments",
          "events_url": "https://api.github.com/repos/jonasnick/bips/issues/76/events",
          "html_url": "https://github.com/jonasnick/bips/issues/76",
          "number": 76,
          "state": "closed",
          "state_reason": "completed",
          "title": "Address Brandon Blacks comments",
          "body": "https://github.com/bitcoin/bips/pull/1372#pullrequestreview-1189017631",
          "user": {
            "login": "jonasnick",
            "id": 2582071,
            "node_id": "MDQ6VXNlcjI1ODIwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonasnick",
            "html_url": "https://github.com/jonasnick",
            "followers_url": "https://api.github.com/users/jonasnick/followers",
            "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
            "organizations_url": "https://api.github.com/users/jonasnick/orgs",
            "repos_url": "https://api.github.com/users/jonasnick/repos",
            "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonasnick/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "OWNER",
          "locked": false,
          "comments": 0,
          "closed_at": "2023-02-03T19:30:22Z",
          "created_at": "2023-02-02T14:32:44Z",
          "updated_at": "2023-02-03T19:30:22Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1307878089,
      "node_id": "PRR_kwDOAN28mc5N9KLJ",
      "url": null,
      "actor": null,
      "commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Needs a backwards compatibility section",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#pullrequestreview-1307878089",
      "submitted_at": "2023-02-21T17:25:08Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
    },
    {
      "event": "commented",
      "id": 1439132867,
      "node_id": "IC_kwDOAN28mc5Vx2zD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1439132867",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T21:46:39Z",
      "updated_at": "2023-02-21T21:46:39Z",
      "author_association": "CONTRIBUTOR",
      "body": "From BIP 2:\r\n\r\n> All BIPs that introduce backwards incompatibilities must include a section describing these incompatibilities\r\n\r\n@luke-jr BIP MuSig2 describes a new standard. I have no idea which proposal it could be considered incompatible with.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1439132867",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8575231006,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAH_H6Qe",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8575231006",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T21:46:39Z"
    },
    {
      "event": "subscribed",
      "id": 8575231019,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAH_H6Qr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8575231019",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T21:46:39Z"
    },
    {
      "event": "commented",
      "id": 1440207315,
      "node_id": "IC_kwDOAN28mc5V19HT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1440207315",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-22T15:00:57Z",
      "updated_at": "2023-02-22T15:02:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "@jonasnick I think it's common to have a \"Backward Compatibility\" section that just says exactly what you said. \"BIP MuSig2 describes a new standard. There is nothing for it to be backward compatible with.\"\r\n\r\nYou could also maybe say that people are able to use other multisig schemes (e.g. CHECKMULTISIG) alongside it, or even in the same script, but you have to choose one or the other for each key that you're signing with.",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1440207315",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8581962433,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAH_hlrB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8581962433",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-22T15:00:57Z"
    },
    {
      "event": "subscribed",
      "id": 8581962458,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAH_hlra",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8581962458",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-22T15:00:58Z"
    },
    {
      "event": "commented",
      "id": 1441515618,
      "node_id": "IC_kwDOAN28mc5V68hi",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1441515618",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-23T10:24:47Z",
      "updated_at": "2023-02-23T10:24:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "> @jonasnick I think it's common to have a \"Backward Compatibility\" section that just says exactly what you said. \"BIP MuSig2 describes a new standard. There is nothing for it to be backward compatible with.\"\r\n\r\nIt's also common not to have it, see BIP340 and BIP342.\r\n\r\nBut anyway, I agree with @jonasnick here. BIP2 mandates this section only for BIPs that introduce backwards incompatibilities.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1441515618",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8590008573,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIAASD9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8590008573",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-23T10:24:47Z"
    },
    {
      "event": "subscribed",
      "id": 8590008587,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIAASEL",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8590008587",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-23T10:24:48Z"
    },
    {
      "event": "commented",
      "id": 1442838589,
      "node_id": "IC_kwDOAN28mc5V__g9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1442838589",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T05:41:50Z",
      "updated_at": "2023-02-24T05:41:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "> But anyway, I agree with @jonasnick here. BIP2 mandates this section only for BIPs that introduce backwards incompatibilities.\r\n\r\nSounds like that reading of bip2 doesn't match current policy, https://github.com/bitcoin/bips/pull/1421#issuecomment-1442718400",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1442838589",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8598384288,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIAgO6g",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8598384288",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T05:41:51Z"
    },
    {
      "event": "subscribed",
      "id": 8598384298,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIAgO6q",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8598384298",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T05:41:51Z"
    },
    {
      "event": "commented",
      "id": 1443541363,
      "node_id": "IC_kwDOAN28mc5WCrFz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1443541363",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T11:16:53Z",
      "updated_at": "2023-02-24T11:42:09Z",
      "author_association": "CONTRIBUTOR",
      "body": "> In my book, it is perfectly fine (if it applies) to say that there are no backwards compatibility issues, especially if it is stated why that is the case (e.g. \"because the op-codes in question are OP_SUCCESSes\"). Not having a backwards compatibility section means the reader has to determine whether there are any, by themselves.\r\n\r\nThis seems reasonable to me. Both BIP editors seem pretty keen on having a backwards compatibility section regardless with a one liner if it doesn't apply. I'll open a PR for a revised BIP 2 (BIP 3) relatively soon but for now the one liner seems good to me and this certainly shouldn't hold up this BIP getting a BIP number.\r\n\r\n> @jonasnick I think it's common to have a \"Backward Compatibility\" section that just says exactly what you said. \"BIP MuSig2 describes a new standard. There is nothing for it to be backward compatible with.\"\r\n>\r\n> You could also maybe say that people are able to use other multisig schemes (e.g. CHECKMULTISIG) alongside it, or even in the same script, but you have to choose one or the other for each key that you're signing with.\r\n\r\nIn this case perhaps more than a one liner might be useful as @apoelstra says. MuSig2 isn't compatible with SegWit version 0 (v0) outputs as it requires Schnorr signatures that are only available in SegWit version 1 (v1). It also can't be used in the same script as OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY as these have been deprecated in SegWit v1. It can be used in the same script as OP_CHECKSIGADD that was introduced in SegWit v1.",
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1443541363",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8600779700,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIApXu0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8600779700",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T11:16:53Z"
    },
    {
      "event": "subscribed",
      "id": 8600779771,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIApXv7",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8600779771",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T11:16:54Z"
    },
    {
      "event": "mentioned",
      "id": 8600779812,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIApXwk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8600779812",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T11:16:54Z"
    },
    {
      "event": "subscribed",
      "id": 8600779838,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIApXw-",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8600779838",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T11:16:54Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8639797850,
      "node_id": "HRFPE_lADOAN28mc5TKo-HzwAAAAIC-Npa",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8639797850",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T15:50:23Z"
    },
    {
      "event": "commented",
      "id": 1450378930,
      "node_id": "IC_kwDOAN28mc5Wcway",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1450378930",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T15:51:17Z",
      "updated_at": "2023-03-01T15:51:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "I just pushed version 1.0.0-rc.3 of the BIP. This version contains minor improvements to the test vectors and addresses feedback (including @brandonblack's above). Change Log:\r\n```mediawiki\r\n** Improve ''NonceGen'' test vectors by not using an all-zero hex string as ''rand_'' values. This change addresses potential issues in some implementations that interpret this as a special value indicating uninitialized memory or a broken random number generator and therefore return an error.\r\n** Fix invalid length of a ''pubnonce'' in the ''PartialSigVerify'' test vectors.\r\n** Improve ''KeySort'' test vector.\r\n** Add explicit ''IndividualPubkey'' algorithm.\r\n** Rename KeyGen Context to KeyAgg Context.\r\n```\r\n\r\nThe commit history can be followed [in this branch](https://github.com/jonasnick/bips/commits/musig2).\r\n\r\n@luke-jr @kallewoof At this time we're not planning to make further changes to the BIP. We would like to request a BIP number.\r\n\r\nWould be interesting to hear from the maintainers if this BIP needs a backwards-compatibility section and why.\r\n",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1450378930",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8639807340,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIC-P9s",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8639807340",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T15:51:18Z"
    },
    {
      "event": "subscribed",
      "id": 8639807360,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIC-P-A",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8639807360",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T15:51:18Z"
    },
    {
      "event": "mentioned",
      "id": 8639807377,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIC-P-R",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8639807377",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T15:51:18Z"
    },
    {
      "event": "subscribed",
      "id": 8639807395,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIC-P-j",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8639807395",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T15:51:18Z"
    },
    {
      "event": "mentioned",
      "id": 8639807437,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIC-P_N",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8639807437",
      "actor": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T15:51:19Z"
    },
    {
      "event": "subscribed",
      "id": 8639807458,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIC-P_i",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8639807458",
      "actor": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T15:51:19Z"
    },
    {
      "event": "commented",
      "id": 1464512751,
      "node_id": "IC_kwDOAN28mc5XSrDv",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1464512751",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T21:46:59Z",
      "updated_at": "2023-03-10T21:46:59Z",
      "author_association": "CONTRIBUTOR",
      "body": "I think we're going to be in a transitional period for a while in this repo until we can get an update to BIP 2 (BIP 3) finalized that both BIP editors are happy with and ideally the broader community is happy with too. There are a number of [things](https://github.com/bitcoin/bips/wiki/BIP-Process-wishlist) that may need to be updated and clarified since BIP 2 was finalized a number of years ago.\r\n\r\n> In my book, it is perfectly fine (if it applies) to say that there are no backwards compatibility issues, especially if it is stated why that is the case (e.g. \"because the op-codes in question are OP_SUCCESSes\"). Not having a backwards compatibility section means the reader has to determine whether there are any, by themselves. (@kallewoof)\r\n\r\n@luke-jr: Do you agree with Kalle on the above? The authors of this draft BIP just want some clarity on whether this is needed or not. If you do agree that a one liner is needed we should also include this requirement in the update to BIP 2 (BIP 3).\r\n\r\nA draft of this BIP has been discussed and scrutinized for a while now on the mailing list and seems to me to be in a sufficient state to get a BIP number.\r\n\r\n",
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1464512751",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8722369454,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIH5Muu",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8722369454",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T21:47:00Z"
    },
    {
      "event": "subscribed",
      "id": 8722369469,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIH5Mu9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8722369469",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T21:47:00Z"
    },
    {
      "event": "mentioned",
      "id": 8722369479,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIH5MvH",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8722369479",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T21:47:00Z"
    },
    {
      "event": "subscribed",
      "id": 8722369487,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIH5MvP",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8722369487",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T21:47:00Z"
    },
    {
      "event": "commented",
      "id": 1464526471,
      "node_id": "IC_kwDOAN28mc5XSuaH",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1464526471",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T22:00:34Z",
      "updated_at": "2023-03-10T22:02:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I think we're going to be in a transitional period for a while in this repo until we can get an update to BIP 2 (BIP 3) finalized that both BIP editors are happy with and ideally the broader community is happy with too. There are a number of [things](https://github.com/bitcoin/bips/wiki/BIP-Process-wishlist) that may need to be updated and clarified since BIP 2 was finalized a number of years ago.\r\n\r\nI'm not entirely sure what you mean by \"transitional period\", but if you suggest that there's something that hinders this PR from being moved forward, then I strongly disagree. We have established and agreed upon procedures, which are written down in BIP 2. I don't see how the fact that changes to BIP2 have been proposed, or will be proposed, would suspend the validity or applicability of the current procedures in BIP2.\r\n\r\nPersonally, I'm also not entirely happy with every aspect of BIP2, and perhaps I'll propose changes, but again, that doesn't render the current rules obsolete. The current rules will be obsolete only once other rules have been agreed upon and merged here.\r\n\r\n---\r\n\r\n> A draft of this BIP has been discussed and scrutinized for a while now on the mailing list and seems to me to be in a sufficient state to get a BIP number.\r\n\r\nAgreed, though I'm obviously biased here.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1464526471",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "commented",
      "id": 1464545722,
      "node_id": "IC_kwDOAN28mc5XSzG6",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1464545722",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T22:16:08Z",
      "updated_at": "2023-03-10T22:16:08Z",
      "author_association": "CONTRIBUTOR",
      "body": "@real-or-random: Sorry if I wasn't clear. The \"transitional period\" is referring to this repo generally and whether we are following the BIP 2 process to the word. Things like the 3 year rejection rule we already aren't following despite it being in BIP 2. \r\n\r\n\"BIPs should be changed from Draft or Proposed status, to Rejected status, upon request by any person, if they have not made progress in three years.\"\r\n\r\n> if you suggest that there's something that hinders this PR from being moved forward, then I strongly disagree.\r\n\r\nThis isn't what I'm suggesting. Just that the BIP process has a few open questions currently hence there's some confusion on a number of things. As I say at the end I don't think this should hold up a BIP number being allocated for this particular draft BIP.",
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1464545722",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8722532375,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIH50gX",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8722532375",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T22:16:08Z"
    },
    {
      "event": "subscribed",
      "id": 8722532389,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIH50gl",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8722532389",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T22:16:08Z"
    },
    {
      "event": "commented",
      "id": 1464606368,
      "node_id": "IC_kwDOAN28mc5XTB6g",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1464606368",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T22:58:51Z",
      "updated_at": "2023-03-10T22:58:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "@michaelfolkson Okay, makes sense, I agree!",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1464606368",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8722706199,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIH6e8X",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8722706199",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T22:58:51Z"
    },
    {
      "event": "subscribed",
      "id": 8722706204,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIH6e8c",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8722706204",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T22:58:51Z"
    },
    {
      "event": "commented",
      "id": 1465018557,
      "node_id": "IC_kwDOAN28mc5XUmi9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1465018557",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T21:05:48Z",
      "updated_at": "2023-03-11T21:05:48Z",
      "author_association": "MEMBER",
      "body": "I see how BIP 2 could be read to imply backwards compatibility is optional, but IMO it is almost always applicable, if only to say there are no compatibility issues.\r\n\r\nIn particular for this BIP, I agree with @michaelfolkson on the need for more than a \"no issues\" section:\r\n\r\n>In this case perhaps more than a one liner might be useful as @apoelstra says. MuSig2 isn't compatible with SegWit version 0 (v0) outputs as it requires Schnorr signatures that are only available in SegWit version 1 (v1). It also can't be used in the same script as OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY as these have been deprecated in SegWit v1. It can be used in the same script as OP_CHECKSIGADD that was introduced in SegWit v1.",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1465018557",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8724662254,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIIB8fu",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8724662254",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T21:05:49Z"
    },
    {
      "event": "subscribed",
      "id": 8724662257,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIIB8fx",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8724662257",
      "actor": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T21:05:49Z"
    },
    {
      "event": "mentioned",
      "id": 8724662258,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIIB8fy",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8724662258",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T21:05:49Z"
    },
    {
      "event": "subscribed",
      "id": 8724662260,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIIB8f0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8724662260",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T21:05:49Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8731386800,
      "node_id": "HRFPE_lADOAN28mc5TKo-HzwAAAAIIbmOw",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8731386800",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-13T12:53:24Z"
    },
    {
      "event": "commented",
      "id": 1466090297,
      "node_id": "IC_kwDOAN28mc5XYsM5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1466090297",
      "actor": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-13T12:53:50Z",
      "updated_at": "2023-03-13T12:53:50Z",
      "author_association": "CONTRIBUTOR",
      "body": "I pushed version 1.0.0-rc.4 which contains a small update to the test vectors:\r\n\r\n```\r\n* '''1.0.0-rc.4''' (2023-03-02):\r\n** Add expected value of ''pubnonce'' to ''NonceGen'' test vectors.\r\n```\r\n  and added a backwards compatibility section that restates compatibility with BIP 340 and mentions incompatibility with ECDSA.",
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1466090297",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "commented",
      "id": 1477744031,
      "node_id": "IC_kwDOAN28mc5YFJWf",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1477744031",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T12:20:56Z",
      "updated_at": "2023-03-21T12:21:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "@kallewoof @luke-jr Could we get a BIP number here?",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1477744031",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "mentioned",
      "id": 8804863255,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIMz40X",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8804863255",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T12:20:57Z"
    },
    {
      "event": "subscribed",
      "id": 8804863268,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIMz40k",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8804863268",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T12:20:57Z"
    },
    {
      "event": "mentioned",
      "id": 8804863291,
      "node_id": "MEE_lADOAN28mc5TKo-HzwAAAAIMz407",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8804863291",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T12:20:57Z"
    },
    {
      "event": "subscribed",
      "id": 8804863308,
      "node_id": "SE_lADOAN28mc5TKo-HzwAAAAIMz41M",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8804863308",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T12:20:57Z"
    },
    {
      "event": "commented",
      "id": 1483961333,
      "node_id": "IC_kwDOAN28mc5Yc3P1",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1483961333",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-26T00:58:43Z",
      "updated_at": "2023-03-26T00:58:43Z",
      "author_association": "MEMBER",
      "body": "BIP 327 seems good",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1483961333",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "reviewed",
      "id": 1357922649,
      "node_id": "PRR_kwDOAN28mc5Q8EFZ",
      "url": null,
      "actor": null,
      "commit_id": "4d996ec7c15315157f3c206c0c11c228c93272fb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#pullrequestreview-1357922649",
      "submitted_at": "2023-03-26T00:59:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
    },
    {
      "event": "commented",
      "id": 1483978655,
      "node_id": "IC_kwDOAN28mc5Yc7ef",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1483978655",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-26T02:49:27Z",
      "updated_at": "2023-03-26T02:49:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "> BIP 327 seems good\r\n\r\nThanks!",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1483978655",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8849044687,
      "node_id": "HRFPE_lADOAN28mc5TKo-HzwAAAAIPcbTP",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8849044687",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-27T02:41:28Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDg3Mzk0ZWFlYjQzNmQwMmUwYTY4YjM4YTFlOTRiYzUyNmQ1MDA1NmU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "tree": {
        "sha": "98c2275d2098a619e4ec524ed35bc217c7c0b1b8",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/98c2275d2098a619e4ec524ed35bc217c7c0b1b8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a8a0191978b451aa3a8acd8a94f3197ff2fe16e5",
          "sha": "a8a0191978b451aa3a8acd8a94f3197ff2fe16e5",
          "html_url": "https://github.com/bitcoin/bips/commit/a8a0191978b451aa3a8acd8a94f3197ff2fe16e5"
        }
      ],
      "message": "Add BIP327: MuSig2 for BIP340-compatible Multi-Signatures",
      "committer": {
        "name": "Tim Ruffing",
        "email": "crypto@timruffing.de",
        "date": "2023-03-27T02:48:22Z"
      },
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2022-04-05T22:29:59Z"
      },
      "sha": "87394eaeb436d02e0a68b38a1e94bc526d50056e"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8849070310,
      "node_id": "HRFPE_lADOAN28mc5TKo-HzwAAAAIPchjm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8849070310",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-27T02:48:46Z"
    },
    {
      "event": "commented",
      "id": 1484407542,
      "node_id": "IC_kwDOAN28mc5YekL2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1484407542",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-27T02:57:52Z",
      "updated_at": "2023-03-27T02:57:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "Forced-pushed to update the title, and make changes necessary after the number was assigned.  \r\n\r\nPlease let us know if further changes are necessary.",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1484407542",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "commented",
      "id": 1484826625,
      "node_id": "IC_kwDOAN28mc5YgKgB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1484826625",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-27T09:40:05Z",
      "updated_at": "2023-03-27T09:40:05Z",
      "author_association": "MEMBER",
      "body": "> bip-0327.mediawiki has too-long TItle (4[5](https://github.com/bitcoin/bips/actions/runs/4528162459/jobs/7974693169?pr=1372#step:3:6) > 44 char max) at scripts/buildtable.pl line 128, <$F> line 3.\r\n\r\nIt's one letter over the limit, so I'll just merge this.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1372#issuecomment-1484826625",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1372"
    },
    {
      "event": "merged",
      "id": 8852007033,
      "node_id": "ME_lADOAN28mc5TKo-HzwAAAAIPnuh5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8852007033",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "67a42fe828fc43077c76985c6133adaf11b20cc6",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/67a42fe828fc43077c76985c6133adaf11b20cc6",
      "created_at": "2023-03-27T09:40:32Z"
    },
    {
      "event": "closed",
      "id": 8852007092,
      "node_id": "CE_lADOAN28mc5TKo-HzwAAAAIPnui0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8852007092",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-27T09:40:32Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1028573847",
      "pull_request_review_id": 1189017631,
      "id": 1028573847,
      "node_id": "PRRC_kwDOAN28mc49TsqX",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''xbytes(Q)''\n+</div>\n+\n+<div>\n+Algorithm ''GetPlainPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''cbytes(Q)''\n+</div>\n+\n+==== Key Sorting ====\n+\n+<div>\n+Algorithm ''KeySort(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Return ''pk<sub>1..u</sub>'' sorted in lexicographical order.\n+</div>\n+\n+==== Key Aggregation ====\n+\n+<div>\n+Algorithm ''KeyAgg(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)''\n+* For ''i = 1 .. u'':\n+** Let ''P<sub>i</sub> = cpoint(pk<sub>i</sub>)''; fail if that fails and blame signer ''i'' for invalid public key.\n+** Let ''a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>, pk<sub>i</sub>, pk2)''.\n+* Let ''Q = a<sub>1</sub>⋅P<sub>1</sub> + a<sub>2</sub>⋅P<sub>2</sub> + ... + a<sub>u</sub>⋅P<sub>u</sub>''\n+* Fail if ''is_infinite(Q)''.\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''keygen_ctx = (Q, gacc, tacc)''.\n+</div>\n+\n+<div>\n+Internal Algorithm ''HashKeys(pk<sub>1..u</sub>)'':\n+* Return ''hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub> || ... || pk<sub>u</sub>)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''GetSecondKey(pk<sub>1..u</sub>)'':\n+* For ''j = 1 .. u'':\n+** If ''pk<sub>j</sub> &ne; pk<sub>1</sub>'':\n+*** Return ''pk<sub>j</sub>''\n+* Return ''bytes(33, 0)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeff(pk<sub>1..u</sub>, pk')'':\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)'':\n+* Return ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)'':\n+* Let ''L = HashKeys(pk<sub>1..u</sub>)''\n+* If ''pk' = pk2'':\n+** Return 1\n+* Return ''int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n''<ref>The key aggregation coefficient is computed by hashing the public key instead of its index, which requires one more invocation of the SHA-256 compression function. However, it results in significantly simpler implementations because signers do not need to translate between public key indices before and after sorting.</ref>\n+</div>\n+\n+==== Applying Tweaks ====\n+\n+<div>\n+Algorithm ''ApplyTweak(keygen_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''keygen_ctx'': a [[#keygen-context|KeyGen Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = keygen_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''keygen_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=== Nonce Generation ===\n+\n+<div>\n+Algorithm ''NonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array (optional argument)\n+** The plain public key ''pk'': a 33-byte array (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]] for the reason that this argument is mandatory)\n+** The aggregate x-only public key ''aggpk'': a 32-byte array (optional argument)\n+** The message ''m'': a byte array (optional argument)<ref name=\"mlen\">In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).</ref>\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>.\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''aggpk'' is not present:\n+** Let ''aggpk = empty_bytestring''\n+* If the optional argument ''m'' is not present:\n+** Let ''m_prefixed = bytes(1, 0)''\n+* Else:\n+** Let ''m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k<sub>i</sub> = int(hash<sub>MuSig/nonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(1, len(aggpk)) || aggpk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n+* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n+* Let ''R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> = k<sub>2</sub>⋅G''\n+* Let ''pubnonce = cbytes(R<sub>⁎,1</sub>) || cbytes(R<sub>⁎,2</sub>)''\n+* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=== Nonce Aggregation ===\n+\n+<div>\n+Algorithm ''NonceAgg(pubnonce<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of ''pubnonces'' with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+* For ''j = 1 .. 2'':\n+** For ''i = 1 .. u'':\n+*** Let ''R<sub>i,j</sub> = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])''; fail if that fails and blame signer ''i'' for invalid ''pubnonce''.\n+** Let ''R<sub>j</sub> = R<sub>1,j</sub> + R<sub>2,j</sub> + ... + R<sub>u,j</sub>''\n+* Return ''aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)''\n+</div>\n+\n+=== Session Context ===\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The aggregate public nonce ''aggnonce'': a 66-byte array\n+* The number ''u'' of public keys with ''0 < u < 2^32''\n+* The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+* The message ''m'': a byte array<ref name=\"mlen\" />\n+\n+We write \"Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\n+* Let ''keygen_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''keygen_ctx<sub>i</sub> = ApplyTweak(keygen_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = keygen_ctx<sub>v</sub>''\n+* Let ''b = int(hash<sub>MuSig/noncecoef</sub>(aggnonce || xbytes(Q) || m)) mod n''\n+* Let ''R<sub>1</sub> = cpoint_ext(aggnonce[0:33]), R<sub>2</sub> = cpoint_ext(aggnonce[33:66])''; fail if that fails and blame nonce aggregator for invalid ''aggnonce''.\n+* Let ''R' = R<sub>1</sub> + b⋅R<sub>2</sub>''\n+* If ''is_infinite(R'):\n+** Let final nonce ''R = G'' (see [[#dealing-with-infinity-in-nonce-aggregation|Dealing with Infinity in Nonce Aggregation]])\n+* Else:\n+** Let final nonce ''R = R' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Return ''(Q, gacc, tacc, b, R, e)''\n+</div>\n+\n+<div>\n+Algorithm ''GetSessionKeyAggCoeff(session_ctx, P)'':\n+* Let ''(_, u, pk<sub>1..u</sub>, _, _, _, _) = session_ctx''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk'' not in ''pk<sub>1..u</sub>''\n+* Return ''KeyAggCoeff(pk<sub>1..u</sub>, pk)''\n+</div>\n+\n+=== Signing ===\n+\n+<div>\n+Algorithm ''Sign(secnonce, sk, session_ctx)'':\n+* Inputs:\n+** The secret nonce ''secnonce'' that has never been used as input to ''Sign'' before: a 97-byte array\n+** The secret key ''sk'': a 32-byte array\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''k<sub>1</sub>' = int(secnonce[0:32]), k<sub>2</sub>' = int(secnonce[32:64])''\n+* Fail if ''k<sub>i</sub>' = 0'' or ''k<sub>i</sub>' &ge; n'' for ''i = 1..2''\n+* Let ''k<sub>1</sub> = k<sub>1</sub>', k<sub>2</sub> = k<sub>2</sub>' '' if ''has_even_y(R)'', otherwise let ''k<sub>1</sub> = n - k<sub>1</sub>', k<sub>2</sub> = n - k<sub>2</sub>' ''\n+* Let ''d' = int(sk)''\n+* Fail if ''d' = 0'' or ''d' &ge; n''\n+* Let ''P = d'⋅G''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk &ne; secnonce[64:97]''\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"Sign negation\"></div>Let ''d = g⋅gacc⋅d' mod n'' (See [[negation-of-the-secret-key-when-signing|Negation Of The Secret Key When Signing]])\n+* Let ''s = (k<sub>1</sub> + b⋅k<sub>2</sub> + e⋅a⋅d) mod n''\n+* Let ''psig = bytes(32, s)''\n+* Let ''pubnonce = cbytes(k<sub>1</sub>'⋅G) || cbytes(k<sub>2</sub>'⋅G)''\n+* If ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'' (see below) returns failure, abort<ref>Verifying the signature before leaving the signer prevents random or attacker provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret key. It is recommended, but can be omitted if the computation cost is prohibitive.</ref>.\n+* Return partial signature ''psig''\n+</div>\n+\n+=== Partial Signature Verification ===\n+\n+<div>\n+Algorithm ''PartialSigVerify(psig, pubnonce<sub>1..u</sub>, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)'':\n+* Inputs:\n+** The partial signature ''psig'': a 32-byte array\n+** The number ''u'' of public nonces and public keys with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+** The message ''m'': a byte array<ref name=\"mlen\" />\n+** The index of the signer ''i'' in the public nonces and public keys with ''0 < i &le; u''\n+* Let ''aggnonce = NonceAgg(pubnonce<sub>1..u</sub>)''; fail if that fails\n+* Let ''session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)''\n+* Run ''PartialSigVerifyInternal(psig, pubnonce<sub>i</sub>, pk<sub>i</sub>, session_ctx)''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+<div>\n+Internal Algorithm ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'':\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''s = int(psig)''; fail if ''s &ge; n''\n+* Let ''R<sub>⁎,1</sub> = cpoint(pubnonce[0:33]), R<sub>⁎,2</sub> = cpoint(pubnonce[33:66])''\n+* Let ''Re<sub>⁎</sub>' = R<sub>⁎,1</sub> + b⋅R<sub>⁎,2</sub>''\n+* Let effective nonce ''Re<sub>⁎</sub> = Re<sub>⁎</sub>' '' if ''has_even_y(R)'', otherwise let ''Re<sub>⁎</sub> = -Re<sub>⁎</sub>' ''\n+* Let ''P = cpoint(pk)''; fail if that fails\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"SigVerify negation\"></div>Let ''g' = g⋅gacc mod n'' (See [[#negation-of-the-public-key-when-partially-verifying|Negation Of The Public Key When Partially Verifying]])\n+* Fail if ''s⋅G &ne; Re<sub>⁎</sub> + e⋅a⋅g'⋅P''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+=== Partial Signature Aggregation ===\n+\n+<div>\n+Algorithm ''PartialSigAgg(psig<sub>1..u</sub>, session_ctx)'':\n+* Inputs:\n+** The number ''u'' of signatures with ''0 < u < 2^32''\n+** The partial signatures ''psig<sub>1..u</sub>'': ''u'' 32-byte arrays\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, _, tacc, _, _, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* For ''i = 1 .. u'':\n+** Let ''s<sub>i</sub> = int(psig<sub>i</sub>)''; fail if ''s<sub>i</sub> &ge; n'' and blame signer ''i'' for invalid partial signature.\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* Let ''s = s<sub>1</sub> + ... + s<sub>u</sub> + e⋅g⋅tacc mod n''\n+* Return ''sig = ''xbytes(R) || bytes(32, s)''\n+</div>\n+\n+=== Test Vectors and Reference Code ===\n+\n+We provide a naive, highly inefficient, and non-constant time [[bip-musig2/reference.py|pure Python 3 reference implementation of the key aggregation, partial signing, and partial signature verification algorithms]].\n+\n+Standalone JSON test vectors are also available in the [[bip-musig2|same directory]], to facilitate porting the test vectors into other implementations.\n+\n+The reference implementation is for demonstration purposes only and not to be used in production environments.\n+\n+== Remarks on Security and Correctness ==\n+\n+=== Modifications to Nonce Generation ===\n+\n+Implementers must avoid modifying the ''NonceGen'' algorithm without being fully aware of the implications.\n+\n+One potential pitfall emerges when ''NonceGen'' is altered so the signer's public key ''pk'' is not part of the returned ''secnonce'' array.\n+This specification makes the signer provide ''pk'' at nonce generation time and write ''pk'' into the ''secnonce'' array (and check ''pk'' against ''sk'' in ''Sign'') to ensure that the public key of the signer is determined before sending out the ''pubnonce''.\n+If the public key is not determined before sending out the ''pubnonce'', an adversary can forge a signature by influencing the individual tweak of a victim signer after seeing the ''pubnonce'' (see the [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html bitcoin-dev mailing list post] and [https://github.com/jonasnick/musig2-tweaking writeup] for the details).\n+Thus, implementations must guarantee that the public key of the signer is determined before sending out the ''pubnonce'' if they cannot rule out that the signer's individual key is tweaked (e.g., derived via BIP32) with a tweak known to the adversary (e.g., as in BIP32 unhardened derivation).<ref>The nonce generation algorithm as given in the [https://eprint.iacr.org/2020/1261 MuSig2 paper] does not take ''pk'' as an input (and does not store it in the ''secnonce''). However, the security model considered in the paper does not cover security for signers who tweak their individual keys.</ref>\n+\n+We provide two modifications that are secure when applied correctly and may be useful in special circumstances, summarized in the following table.\n+\n+{| class=\"wikitable\" style=\"margin:auto\"\n+!                   !! needs secure randomness !! needs secure counter !! needs to keep state securely !! needs aggregated nonce of all other signers (only possible for one signer)\n+|-\n+! NonceGen          || ✓      || &nbsp; || ✓      || &nbsp;\n+|-\n+! CounterNonceGen   || &nbsp; || ✓      || ✓      || &nbsp;\n+|-\n+! DeterministicSign || &nbsp; || &nbsp; || &nbsp; || ✓\n+|}\n+\n+First, on systems where obtaining uniformly random values is much harder than maintaining a global atomic counter, it can be beneficial to modify ''NonceGen''.\n+The resulting algorithm ''CounterNonceGen'' does not draw ''rand' '' uniformly at random but instead sets ''rand' '' to the value of an atomic counter that is incremented whenever it is read.\n+With this modification, the secret signing key ''sk'' of the signer generating the nonce is '''not''' an optional argument and must be provided to ''NonceGen''.\n+The security of the resulting scheme is then depending on the requirement that reading the counter must never yield the same counter value in two ''NonceGen'' invocations with the same ''sk''.\n+\n+Second, if there is a unique signer who is supposed to send the ''pubnonce'' last, it is possible to modify nonce generation for this single signer to not require high-quality randomness.\n+Such a nonce generation algorithm ''DeterministicSign'' is specified below.\n+Note that the only optional argument is ''rand'', which can be omitted if randomness is entirely unavailable.",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 547,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": null,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> if randomness is entirely unavailable.\r\n\r\nalso useful if the secret key is stored in multiple locations and it is not feasible to ensure that both signing rounds execute in the same location.",
      "created_at": "2022-11-21T22:30:24Z",
      "updated_at": "2022-11-23T00:31:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1028573847",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1028573847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1028604028",
      "pull_request_review_id": 1189017631,
      "id": 1028604028,
      "node_id": "PRRC_kwDOAN28mc49T0B8",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 51,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": null,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The benefit of this is somewhat restricted with the requirement to know the exact derived public key prior to nonce generation.",
      "created_at": "2022-11-21T23:22:42Z",
      "updated_at": "2022-11-23T00:31:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1028604028",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1028604028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1028615910",
      "pull_request_review_id": 1189017631,
      "id": 1028615910,
      "node_id": "PRRC_kwDOAN28mc49T27m",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": null,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "An additional algorithm `GetParity(keygen_ctx)` or `HasEvenY(keygen_ctx)` would make using Taproot x-only tweaked MuSig keys easier (eg. for building the corresponding control blocks).\r\n\r\nAlternatively, since this algorithm appears intended for use in that context, it could return implementation dependent structured data of `has_even_y(Q), xbytes(Q)`.",
      "created_at": "2022-11-21T23:46:52Z",
      "updated_at": "2022-11-23T00:31:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1028615910",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1028615910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1029760862",
      "pull_request_review_id": 1189017631,
      "id": 1029760862,
      "node_id": "PRRC_kwDOAN28mc49YOde",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''xbytes(Q)''\n+</div>\n+\n+<div>\n+Algorithm ''GetPlainPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''cbytes(Q)''\n+</div>\n+\n+==== Key Sorting ====\n+\n+<div>\n+Algorithm ''KeySort(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Return ''pk<sub>1..u</sub>'' sorted in lexicographical order.\n+</div>\n+\n+==== Key Aggregation ====\n+\n+<div>\n+Algorithm ''KeyAgg(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)''\n+* For ''i = 1 .. u'':\n+** Let ''P<sub>i</sub> = cpoint(pk<sub>i</sub>)''; fail if that fails and blame signer ''i'' for invalid public key.\n+** Let ''a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>, pk<sub>i</sub>, pk2)''.\n+* Let ''Q = a<sub>1</sub>⋅P<sub>1</sub> + a<sub>2</sub>⋅P<sub>2</sub> + ... + a<sub>u</sub>⋅P<sub>u</sub>''\n+* Fail if ''is_infinite(Q)''.\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''keygen_ctx = (Q, gacc, tacc)''.\n+</div>\n+\n+<div>\n+Internal Algorithm ''HashKeys(pk<sub>1..u</sub>)'':\n+* Return ''hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub> || ... || pk<sub>u</sub>)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''GetSecondKey(pk<sub>1..u</sub>)'':\n+* For ''j = 1 .. u'':\n+** If ''pk<sub>j</sub> &ne; pk<sub>1</sub>'':\n+*** Return ''pk<sub>j</sub>''\n+* Return ''bytes(33, 0)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeff(pk<sub>1..u</sub>, pk')'':\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)'':\n+* Return ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)'':\n+* Let ''L = HashKeys(pk<sub>1..u</sub>)''\n+* If ''pk' = pk2'':\n+** Return 1\n+* Return ''int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n''<ref>The key aggregation coefficient is computed by hashing the public key instead of its index, which requires one more invocation of the SHA-256 compression function. However, it results in significantly simpler implementations because signers do not need to translate between public key indices before and after sorting.</ref>\n+</div>\n+\n+==== Applying Tweaks ====\n+\n+<div>\n+Algorithm ''ApplyTweak(keygen_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''keygen_ctx'': a [[#keygen-context|KeyGen Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = keygen_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''keygen_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=== Nonce Generation ===\n+\n+<div>\n+Algorithm ''NonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array (optional argument)\n+** The plain public key ''pk'': a 33-byte array (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]] for the reason that this argument is mandatory)\n+** The aggregate x-only public key ''aggpk'': a 32-byte array (optional argument)\n+** The message ''m'': a byte array (optional argument)<ref name=\"mlen\">In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).</ref>\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>.\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''aggpk'' is not present:\n+** Let ''aggpk = empty_bytestring''\n+* If the optional argument ''m'' is not present:\n+** Let ''m_prefixed = bytes(1, 0)''",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 365,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": null,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't see a justification for differentiating absence from zero-length for `m` but not for `extra_in` or `aggpk`.",
      "created_at": "2022-11-22T19:51:22Z",
      "updated_at": "2022-11-23T00:31:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1029760862",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1029760862"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 379,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1029784791",
      "pull_request_review_id": 1189017631,
      "id": 1029784791,
      "node_id": "PRRC_kwDOAN28mc49YUTX",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''xbytes(Q)''\n+</div>\n+\n+<div>\n+Algorithm ''GetPlainPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''cbytes(Q)''\n+</div>\n+\n+==== Key Sorting ====\n+\n+<div>\n+Algorithm ''KeySort(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Return ''pk<sub>1..u</sub>'' sorted in lexicographical order.\n+</div>\n+\n+==== Key Aggregation ====\n+\n+<div>\n+Algorithm ''KeyAgg(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)''\n+* For ''i = 1 .. u'':\n+** Let ''P<sub>i</sub> = cpoint(pk<sub>i</sub>)''; fail if that fails and blame signer ''i'' for invalid public key.\n+** Let ''a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>, pk<sub>i</sub>, pk2)''.\n+* Let ''Q = a<sub>1</sub>⋅P<sub>1</sub> + a<sub>2</sub>⋅P<sub>2</sub> + ... + a<sub>u</sub>⋅P<sub>u</sub>''\n+* Fail if ''is_infinite(Q)''.\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''keygen_ctx = (Q, gacc, tacc)''.\n+</div>\n+\n+<div>\n+Internal Algorithm ''HashKeys(pk<sub>1..u</sub>)'':\n+* Return ''hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub> || ... || pk<sub>u</sub>)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''GetSecondKey(pk<sub>1..u</sub>)'':\n+* For ''j = 1 .. u'':\n+** If ''pk<sub>j</sub> &ne; pk<sub>1</sub>'':\n+*** Return ''pk<sub>j</sub>''\n+* Return ''bytes(33, 0)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeff(pk<sub>1..u</sub>, pk')'':\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)'':\n+* Return ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)'':\n+* Let ''L = HashKeys(pk<sub>1..u</sub>)''\n+* If ''pk' = pk2'':\n+** Return 1\n+* Return ''int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n''<ref>The key aggregation coefficient is computed by hashing the public key instead of its index, which requires one more invocation of the SHA-256 compression function. However, it results in significantly simpler implementations because signers do not need to translate between public key indices before and after sorting.</ref>\n+</div>\n+\n+==== Applying Tweaks ====\n+\n+<div>\n+Algorithm ''ApplyTweak(keygen_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''keygen_ctx'': a [[#keygen-context|KeyGen Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = keygen_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''keygen_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=== Nonce Generation ===\n+\n+<div>\n+Algorithm ''NonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array (optional argument)\n+** The plain public key ''pk'': a 33-byte array (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]] for the reason that this argument is mandatory)\n+** The aggregate x-only public key ''aggpk'': a 32-byte array (optional argument)\n+** The message ''m'': a byte array (optional argument)<ref name=\"mlen\">In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).</ref>\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>.\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''aggpk'' is not present:\n+** Let ''aggpk = empty_bytestring''\n+* If the optional argument ''m'' is not present:\n+** Let ''m_prefixed = bytes(1, 0)''\n+* Else:\n+** Let ''m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k<sub>i</sub> = int(hash<sub>MuSig/nonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(1, len(aggpk)) || aggpk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n+* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n+* Let ''R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> = k<sub>2</sub>⋅G''\n+* Let ''pubnonce = cbytes(R<sub>⁎,1</sub>) || cbytes(R<sub>⁎,2</sub>)''\n+* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=== Nonce Aggregation ===\n+\n+<div>\n+Algorithm ''NonceAgg(pubnonce<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of ''pubnonces'' with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+* For ''j = 1 .. 2'':\n+** For ''i = 1 .. u'':\n+*** Let ''R<sub>i,j</sub> = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])''; fail if that fails and blame signer ''i'' for invalid ''pubnonce''.\n+** Let ''R<sub>j</sub> = R<sub>1,j</sub> + R<sub>2,j</sub> + ... + R<sub>u,j</sub>''\n+* Return ''aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)''\n+</div>\n+\n+=== Session Context ===\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The aggregate public nonce ''aggnonce'': a 66-byte array\n+* The number ''u'' of public keys with ''0 < u < 2^32''\n+* The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+* The message ''m'': a byte array<ref name=\"mlen\" />\n+\n+We write \"Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\n+* Let ''keygen_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''keygen_ctx<sub>i</sub> = ApplyTweak(keygen_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = keygen_ctx<sub>v</sub>''\n+* Let ''b = int(hash<sub>MuSig/noncecoef</sub>(aggnonce || xbytes(Q) || m)) mod n''\n+* Let ''R<sub>1</sub> = cpoint_ext(aggnonce[0:33]), R<sub>2</sub> = cpoint_ext(aggnonce[33:66])''; fail if that fails and blame nonce aggregator for invalid ''aggnonce''.\n+* Let ''R' = R<sub>1</sub> + b⋅R<sub>2</sub>''\n+* If ''is_infinite(R'):\n+** Let final nonce ''R = G'' (see [[#dealing-with-infinity-in-nonce-aggregation|Dealing with Infinity in Nonce Aggregation]])\n+* Else:\n+** Let final nonce ''R = R' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Return ''(Q, gacc, tacc, b, R, e)''\n+</div>\n+\n+<div>\n+Algorithm ''GetSessionKeyAggCoeff(session_ctx, P)'':\n+* Let ''(_, u, pk<sub>1..u</sub>, _, _, _, _) = session_ctx''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk'' not in ''pk<sub>1..u</sub>''\n+* Return ''KeyAggCoeff(pk<sub>1..u</sub>, pk)''\n+</div>\n+\n+=== Signing ===\n+\n+<div>\n+Algorithm ''Sign(secnonce, sk, session_ctx)'':\n+* Inputs:\n+** The secret nonce ''secnonce'' that has never been used as input to ''Sign'' before: a 97-byte array\n+** The secret key ''sk'': a 32-byte array\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''k<sub>1</sub>' = int(secnonce[0:32]), k<sub>2</sub>' = int(secnonce[32:64])''\n+* Fail if ''k<sub>i</sub>' = 0'' or ''k<sub>i</sub>' &ge; n'' for ''i = 1..2''\n+* Let ''k<sub>1</sub> = k<sub>1</sub>', k<sub>2</sub> = k<sub>2</sub>' '' if ''has_even_y(R)'', otherwise let ''k<sub>1</sub> = n - k<sub>1</sub>', k<sub>2</sub> = n - k<sub>2</sub>' ''\n+* Let ''d' = int(sk)''\n+* Fail if ''d' = 0'' or ''d' &ge; n''\n+* Let ''P = d'⋅G''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk &ne; secnonce[64:97]''\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"Sign negation\"></div>Let ''d = g⋅gacc⋅d' mod n'' (See [[negation-of-the-secret-key-when-signing|Negation Of The Secret Key When Signing]])\n+* Let ''s = (k<sub>1</sub> + b⋅k<sub>2</sub> + e⋅a⋅d) mod n''\n+* Let ''psig = bytes(32, s)''\n+* Let ''pubnonce = cbytes(k<sub>1</sub>'⋅G) || cbytes(k<sub>2</sub>'⋅G)''\n+* If ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'' (see below) returns failure, abort<ref>Verifying the signature before leaving the signer prevents random or attacker provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret key. It is recommended, but can be omitted if the computation cost is prohibitive.</ref>.\n+* Return partial signature ''psig''\n+</div>\n+\n+=== Partial Signature Verification ===\n+\n+<div>\n+Algorithm ''PartialSigVerify(psig, pubnonce<sub>1..u</sub>, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)'':\n+* Inputs:\n+** The partial signature ''psig'': a 32-byte array\n+** The number ''u'' of public nonces and public keys with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+** The message ''m'': a byte array<ref name=\"mlen\" />\n+** The index of the signer ''i'' in the public nonces and public keys with ''0 < i &le; u''\n+* Let ''aggnonce = NonceAgg(pubnonce<sub>1..u</sub>)''; fail if that fails\n+* Let ''session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)''\n+* Run ''PartialSigVerifyInternal(psig, pubnonce<sub>i</sub>, pk<sub>i</sub>, session_ctx)''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+<div>\n+Internal Algorithm ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'':\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''s = int(psig)''; fail if ''s &ge; n''\n+* Let ''R<sub>⁎,1</sub> = cpoint(pubnonce[0:33]), R<sub>⁎,2</sub> = cpoint(pubnonce[33:66])''\n+* Let ''Re<sub>⁎</sub>' = R<sub>⁎,1</sub> + b⋅R<sub>⁎,2</sub>''\n+* Let effective nonce ''Re<sub>⁎</sub> = Re<sub>⁎</sub>' '' if ''has_even_y(R)'', otherwise let ''Re<sub>⁎</sub> = -Re<sub>⁎</sub>' ''\n+* Let ''P = cpoint(pk)''; fail if that fails\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"SigVerify negation\"></div>Let ''g' = g⋅gacc mod n'' (See [[#negation-of-the-public-key-when-partially-verifying|Negation Of The Public Key When Partially Verifying]])\n+* Fail if ''s⋅G &ne; Re<sub>⁎</sub> + e⋅a⋅g'⋅P''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+=== Partial Signature Aggregation ===\n+\n+<div>\n+Algorithm ''PartialSigAgg(psig<sub>1..u</sub>, session_ctx)'':\n+* Inputs:\n+** The number ''u'' of signatures with ''0 < u < 2^32''\n+** The partial signatures ''psig<sub>1..u</sub>'': ''u'' 32-byte arrays\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, _, tacc, _, _, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* For ''i = 1 .. u'':\n+** Let ''s<sub>i</sub> = int(psig<sub>i</sub>)''; fail if ''s<sub>i</sub> &ge; n'' and blame signer ''i'' for invalid partial signature.\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* Let ''s = s<sub>1</sub> + ... + s<sub>u</sub> + e⋅g⋅tacc mod n''\n+* Return ''sig = ''xbytes(R) || bytes(32, s)''\n+</div>\n+\n+=== Test Vectors and Reference Code ===\n+\n+We provide a naive, highly inefficient, and non-constant time [[bip-musig2/reference.py|pure Python 3 reference implementation of the key aggregation, partial signing, and partial signature verification algorithms]].\n+\n+Standalone JSON test vectors are also available in the [[bip-musig2|same directory]], to facilitate porting the test vectors into other implementations.\n+\n+The reference implementation is for demonstration purposes only and not to be used in production environments.\n+\n+== Remarks on Security and Correctness ==\n+\n+=== Modifications to Nonce Generation ===\n+\n+Implementers must avoid modifying the ''NonceGen'' algorithm without being fully aware of the implications.\n+\n+One potential pitfall emerges when ''NonceGen'' is altered so the signer's public key ''pk'' is not part of the returned ''secnonce'' array.\n+This specification makes the signer provide ''pk'' at nonce generation time and write ''pk'' into the ''secnonce'' array (and check ''pk'' against ''sk'' in ''Sign'') to ensure that the public key of the signer is determined before sending out the ''pubnonce''.\n+If the public key is not determined before sending out the ''pubnonce'', an adversary can forge a signature by influencing the individual tweak of a victim signer after seeing the ''pubnonce'' (see the [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html bitcoin-dev mailing list post] and [https://github.com/jonasnick/musig2-tweaking writeup] for the details).\n+Thus, implementations must guarantee that the public key of the signer is determined before sending out the ''pubnonce'' if they cannot rule out that the signer's individual key is tweaked (e.g., derived via BIP32) with a tweak known to the adversary (e.g., as in BIP32 unhardened derivation).<ref>The nonce generation algorithm as given in the [https://eprint.iacr.org/2020/1261 MuSig2 paper] does not take ''pk'' as an input (and does not store it in the ''secnonce''). However, the security model considered in the paper does not cover security for signers who tweak their individual keys.</ref>\n+\n+We provide two modifications that are secure when applied correctly and may be useful in special circumstances, summarized in the following table.\n+\n+{| class=\"wikitable\" style=\"margin:auto\"\n+!                   !! needs secure randomness !! needs secure counter !! needs to keep state securely !! needs aggregated nonce of all other signers (only possible for one signer)\n+|-\n+! NonceGen          || ✓      || &nbsp; || ✓      || &nbsp;\n+|-\n+! CounterNonceGen   || &nbsp; || ✓      || ✓      || &nbsp;\n+|-\n+! DeterministicSign || &nbsp; || &nbsp; || &nbsp; || ✓\n+|}\n+\n+First, on systems where obtaining uniformly random values is much harder than maintaining a global atomic counter, it can be beneficial to modify ''NonceGen''.\n+The resulting algorithm ''CounterNonceGen'' does not draw ''rand' '' uniformly at random but instead sets ''rand' '' to the value of an atomic counter that is incremented whenever it is read.\n+With this modification, the secret signing key ''sk'' of the signer generating the nonce is '''not''' an optional argument and must be provided to ''NonceGen''.\n+The security of the resulting scheme is then depending on the requirement that reading the counter must never yield the same counter value in two ''NonceGen'' invocations with the same ''sk''.\n+\n+Second, if there is a unique signer who is supposed to send the ''pubnonce'' last, it is possible to modify nonce generation for this single signer to not require high-quality randomness.\n+Such a nonce generation algorithm ''DeterministicSign'' is specified below.\n+Note that the only optional argument is ''rand'', which can be omitted if randomness is entirely unavailable.\n+''DeterministicSign'' requires the argument ''aggothernonce'' which should be set to the output of ''NonceAgg'' run on the ''pubnonce'' value of '''all''' other signers (but can be provided by an untrusted party).\n+Hence, using ''DeterministicSign'' is only possible for the last signer to generate a nonce and makes the signer stateless, similar to the stateless signer described in the [[#nonce-generation|Nonce Generation]] section.\n+\n+==== Deterministic and Stateless Signing for a Single Signer ====\n+\n+<div>\n+Algorithm ''DeterministicSign(sk, aggothernonce, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, rand)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array\n+** The aggregate public nonce ''aggothernonce'' (see [[#modifications-to-nonce-generation|above]]): a 66-byte array\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 32-byte arrays\n+** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak methods ''is_xonly_t<sub>1..v</sub>'': ''v'' booleans\n+** The message ''m'': a byte array<ref name=\"mlen\" />\n+** The auxiliary randomness ''rand'': a 32-byte array (optional argument)\n+* If the optional argument ''rand'' is present:\n+** Let ''sk' '' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand)''\n+* Else:\n+** Let ''sk' = sk''\n+* Let ''keygen_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''keygen_ctx<sub>i</sub> = ApplyTweak(keygen_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''aggpk = GetPubkey(keygen_ctx<sub>v</sub>)''\n+* Let ''k<sub>i</sub> = int(hash<sub>MuSig/deterministic/nonce</sub>(sk' || aggothernonce || aggpk || bytes(8, len(m)) || m || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n+* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n+* Let ''R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> = k<sub>2</sub>⋅G''\n+* Let ''pubnonce = cbytes(R<sub>⁎,2</sub>) || cbytes(R<sub>⁎,2</sub>)''\n+* Let ''d = int(sk)''\n+* Fail if ''d = 0'' or ''d &ge; n''\n+* Let ''pk = cbytes(d⋅G)''\n+* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''\n+* Let ''aggnonce = NonceAgg((pubnonce, aggothernonce))''; fail if that fails and blame nonce aggregator for invalid ''aggothernonce''.",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 581,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": null,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems odd to define `DeterministicSign` instead of `DeterministicNonceGen`, given that `DeterministicSign` converges with `Sign` at this point.\r\n\r\nIs there a reason that it is not safe / allowable to send the generated `pubnonce` to other signers here, and then have the stateless signer verify their partial signatures before creating its own?\r\n\r\nPut another way: is there a modification that can be made to allow the stateless signer require partial signatures from other parties before creating and publishing its partial signature?",
      "created_at": "2022-11-22T20:19:40Z",
      "updated_at": "2022-11-23T00:33:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1029784791",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1029784791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 631,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1036050443",
      "pull_request_review_id": 1199445016,
      "id": 1036050443,
      "node_id": "PRRC_kwDOAN28mc49wOAL",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 51,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": 1028604028,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "True. Maybe it makes sense to make this clearer in the paragraph.",
      "created_at": "2022-11-30T14:37:16Z",
      "updated_at": "2022-11-30T14:37:16Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1036050443",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1036050443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1036050629",
      "pull_request_review_id": 1199445315,
      "id": 1036050629,
      "node_id": "PRRC_kwDOAN28mc49wODF",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": 1028615910,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Your suggestion is very close to what `GetPlainPubkey` already does. In particular, the control block bit can be obtained with `GetPlainPubkey[0] & 1`. It seems like we don't explain this, but I think we should.",
      "created_at": "2022-11-30T14:37:25Z",
      "updated_at": "2022-11-30T14:37:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1036050629",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1036050629"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1036050842",
      "pull_request_review_id": 1199445611,
      "id": 1036050842,
      "node_id": "PRRC_kwDOAN28mc49wOGa",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''xbytes(Q)''\n+</div>\n+\n+<div>\n+Algorithm ''GetPlainPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''cbytes(Q)''\n+</div>\n+\n+==== Key Sorting ====\n+\n+<div>\n+Algorithm ''KeySort(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Return ''pk<sub>1..u</sub>'' sorted in lexicographical order.\n+</div>\n+\n+==== Key Aggregation ====\n+\n+<div>\n+Algorithm ''KeyAgg(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)''\n+* For ''i = 1 .. u'':\n+** Let ''P<sub>i</sub> = cpoint(pk<sub>i</sub>)''; fail if that fails and blame signer ''i'' for invalid public key.\n+** Let ''a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>, pk<sub>i</sub>, pk2)''.\n+* Let ''Q = a<sub>1</sub>⋅P<sub>1</sub> + a<sub>2</sub>⋅P<sub>2</sub> + ... + a<sub>u</sub>⋅P<sub>u</sub>''\n+* Fail if ''is_infinite(Q)''.\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''keygen_ctx = (Q, gacc, tacc)''.\n+</div>\n+\n+<div>\n+Internal Algorithm ''HashKeys(pk<sub>1..u</sub>)'':\n+* Return ''hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub> || ... || pk<sub>u</sub>)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''GetSecondKey(pk<sub>1..u</sub>)'':\n+* For ''j = 1 .. u'':\n+** If ''pk<sub>j</sub> &ne; pk<sub>1</sub>'':\n+*** Return ''pk<sub>j</sub>''\n+* Return ''bytes(33, 0)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeff(pk<sub>1..u</sub>, pk')'':\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)'':\n+* Return ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)'':\n+* Let ''L = HashKeys(pk<sub>1..u</sub>)''\n+* If ''pk' = pk2'':\n+** Return 1\n+* Return ''int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n''<ref>The key aggregation coefficient is computed by hashing the public key instead of its index, which requires one more invocation of the SHA-256 compression function. However, it results in significantly simpler implementations because signers do not need to translate between public key indices before and after sorting.</ref>\n+</div>\n+\n+==== Applying Tweaks ====\n+\n+<div>\n+Algorithm ''ApplyTweak(keygen_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''keygen_ctx'': a [[#keygen-context|KeyGen Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = keygen_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''keygen_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=== Nonce Generation ===\n+\n+<div>\n+Algorithm ''NonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array (optional argument)\n+** The plain public key ''pk'': a 33-byte array (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]] for the reason that this argument is mandatory)\n+** The aggregate x-only public key ''aggpk'': a 32-byte array (optional argument)\n+** The message ''m'': a byte array (optional argument)<ref name=\"mlen\">In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).</ref>\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>.\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''aggpk'' is not present:\n+** Let ''aggpk = empty_bytestring''\n+* If the optional argument ''m'' is not present:\n+** Let ''m_prefixed = bytes(1, 0)''",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 365,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": 1029760862,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`aggpk` is always 32 and never 0 bytes. `extra_in` is supposed to \"contain additional contextual data that has a chance of changing between `NonceGen` runs\" which implies that a 0-byte `extra_in` is not useful. We still allow it to avoid adding complexity to the spec.\r\n",
      "created_at": "2022-11-30T14:37:34Z",
      "updated_at": "2022-11-30T14:37:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1036050842",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1036050842"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 379,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1036053753",
      "pull_request_review_id": 1199450020,
      "id": 1036053753,
      "node_id": "PRRC_kwDOAN28mc49wOz5",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''xbytes(Q)''\n+</div>\n+\n+<div>\n+Algorithm ''GetPlainPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''cbytes(Q)''\n+</div>\n+\n+==== Key Sorting ====\n+\n+<div>\n+Algorithm ''KeySort(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Return ''pk<sub>1..u</sub>'' sorted in lexicographical order.\n+</div>\n+\n+==== Key Aggregation ====\n+\n+<div>\n+Algorithm ''KeyAgg(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)''\n+* For ''i = 1 .. u'':\n+** Let ''P<sub>i</sub> = cpoint(pk<sub>i</sub>)''; fail if that fails and blame signer ''i'' for invalid public key.\n+** Let ''a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>, pk<sub>i</sub>, pk2)''.\n+* Let ''Q = a<sub>1</sub>⋅P<sub>1</sub> + a<sub>2</sub>⋅P<sub>2</sub> + ... + a<sub>u</sub>⋅P<sub>u</sub>''\n+* Fail if ''is_infinite(Q)''.\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''keygen_ctx = (Q, gacc, tacc)''.\n+</div>\n+\n+<div>\n+Internal Algorithm ''HashKeys(pk<sub>1..u</sub>)'':\n+* Return ''hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub> || ... || pk<sub>u</sub>)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''GetSecondKey(pk<sub>1..u</sub>)'':\n+* For ''j = 1 .. u'':\n+** If ''pk<sub>j</sub> &ne; pk<sub>1</sub>'':\n+*** Return ''pk<sub>j</sub>''\n+* Return ''bytes(33, 0)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeff(pk<sub>1..u</sub>, pk')'':\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)'':\n+* Return ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)'':\n+* Let ''L = HashKeys(pk<sub>1..u</sub>)''\n+* If ''pk' = pk2'':\n+** Return 1\n+* Return ''int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n''<ref>The key aggregation coefficient is computed by hashing the public key instead of its index, which requires one more invocation of the SHA-256 compression function. However, it results in significantly simpler implementations because signers do not need to translate between public key indices before and after sorting.</ref>\n+</div>\n+\n+==== Applying Tweaks ====\n+\n+<div>\n+Algorithm ''ApplyTweak(keygen_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''keygen_ctx'': a [[#keygen-context|KeyGen Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = keygen_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''keygen_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=== Nonce Generation ===\n+\n+<div>\n+Algorithm ''NonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array (optional argument)\n+** The plain public key ''pk'': a 33-byte array (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]] for the reason that this argument is mandatory)\n+** The aggregate x-only public key ''aggpk'': a 32-byte array (optional argument)\n+** The message ''m'': a byte array (optional argument)<ref name=\"mlen\">In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).</ref>\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>.\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''aggpk'' is not present:\n+** Let ''aggpk = empty_bytestring''\n+* If the optional argument ''m'' is not present:\n+** Let ''m_prefixed = bytes(1, 0)''\n+* Else:\n+** Let ''m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k<sub>i</sub> = int(hash<sub>MuSig/nonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(1, len(aggpk)) || aggpk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n+* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n+* Let ''R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> = k<sub>2</sub>⋅G''\n+* Let ''pubnonce = cbytes(R<sub>⁎,1</sub>) || cbytes(R<sub>⁎,2</sub>)''\n+* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=== Nonce Aggregation ===\n+\n+<div>\n+Algorithm ''NonceAgg(pubnonce<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of ''pubnonces'' with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+* For ''j = 1 .. 2'':\n+** For ''i = 1 .. u'':\n+*** Let ''R<sub>i,j</sub> = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])''; fail if that fails and blame signer ''i'' for invalid ''pubnonce''.\n+** Let ''R<sub>j</sub> = R<sub>1,j</sub> + R<sub>2,j</sub> + ... + R<sub>u,j</sub>''\n+* Return ''aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)''\n+</div>\n+\n+=== Session Context ===\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The aggregate public nonce ''aggnonce'': a 66-byte array\n+* The number ''u'' of public keys with ''0 < u < 2^32''\n+* The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+* The message ''m'': a byte array<ref name=\"mlen\" />\n+\n+We write \"Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\n+* Let ''keygen_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''keygen_ctx<sub>i</sub> = ApplyTweak(keygen_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = keygen_ctx<sub>v</sub>''\n+* Let ''b = int(hash<sub>MuSig/noncecoef</sub>(aggnonce || xbytes(Q) || m)) mod n''\n+* Let ''R<sub>1</sub> = cpoint_ext(aggnonce[0:33]), R<sub>2</sub> = cpoint_ext(aggnonce[33:66])''; fail if that fails and blame nonce aggregator for invalid ''aggnonce''.\n+* Let ''R' = R<sub>1</sub> + b⋅R<sub>2</sub>''\n+* If ''is_infinite(R'):\n+** Let final nonce ''R = G'' (see [[#dealing-with-infinity-in-nonce-aggregation|Dealing with Infinity in Nonce Aggregation]])\n+* Else:\n+** Let final nonce ''R = R' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Return ''(Q, gacc, tacc, b, R, e)''\n+</div>\n+\n+<div>\n+Algorithm ''GetSessionKeyAggCoeff(session_ctx, P)'':\n+* Let ''(_, u, pk<sub>1..u</sub>, _, _, _, _) = session_ctx''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk'' not in ''pk<sub>1..u</sub>''\n+* Return ''KeyAggCoeff(pk<sub>1..u</sub>, pk)''\n+</div>\n+\n+=== Signing ===\n+\n+<div>\n+Algorithm ''Sign(secnonce, sk, session_ctx)'':\n+* Inputs:\n+** The secret nonce ''secnonce'' that has never been used as input to ''Sign'' before: a 97-byte array\n+** The secret key ''sk'': a 32-byte array\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''k<sub>1</sub>' = int(secnonce[0:32]), k<sub>2</sub>' = int(secnonce[32:64])''\n+* Fail if ''k<sub>i</sub>' = 0'' or ''k<sub>i</sub>' &ge; n'' for ''i = 1..2''\n+* Let ''k<sub>1</sub> = k<sub>1</sub>', k<sub>2</sub> = k<sub>2</sub>' '' if ''has_even_y(R)'', otherwise let ''k<sub>1</sub> = n - k<sub>1</sub>', k<sub>2</sub> = n - k<sub>2</sub>' ''\n+* Let ''d' = int(sk)''\n+* Fail if ''d' = 0'' or ''d' &ge; n''\n+* Let ''P = d'⋅G''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk &ne; secnonce[64:97]''\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"Sign negation\"></div>Let ''d = g⋅gacc⋅d' mod n'' (See [[negation-of-the-secret-key-when-signing|Negation Of The Secret Key When Signing]])\n+* Let ''s = (k<sub>1</sub> + b⋅k<sub>2</sub> + e⋅a⋅d) mod n''\n+* Let ''psig = bytes(32, s)''\n+* Let ''pubnonce = cbytes(k<sub>1</sub>'⋅G) || cbytes(k<sub>2</sub>'⋅G)''\n+* If ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'' (see below) returns failure, abort<ref>Verifying the signature before leaving the signer prevents random or attacker provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret key. It is recommended, but can be omitted if the computation cost is prohibitive.</ref>.\n+* Return partial signature ''psig''\n+</div>\n+\n+=== Partial Signature Verification ===\n+\n+<div>\n+Algorithm ''PartialSigVerify(psig, pubnonce<sub>1..u</sub>, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)'':\n+* Inputs:\n+** The partial signature ''psig'': a 32-byte array\n+** The number ''u'' of public nonces and public keys with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+** The message ''m'': a byte array<ref name=\"mlen\" />\n+** The index of the signer ''i'' in the public nonces and public keys with ''0 < i &le; u''\n+* Let ''aggnonce = NonceAgg(pubnonce<sub>1..u</sub>)''; fail if that fails\n+* Let ''session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)''\n+* Run ''PartialSigVerifyInternal(psig, pubnonce<sub>i</sub>, pk<sub>i</sub>, session_ctx)''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+<div>\n+Internal Algorithm ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'':\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''s = int(psig)''; fail if ''s &ge; n''\n+* Let ''R<sub>⁎,1</sub> = cpoint(pubnonce[0:33]), R<sub>⁎,2</sub> = cpoint(pubnonce[33:66])''\n+* Let ''Re<sub>⁎</sub>' = R<sub>⁎,1</sub> + b⋅R<sub>⁎,2</sub>''\n+* Let effective nonce ''Re<sub>⁎</sub> = Re<sub>⁎</sub>' '' if ''has_even_y(R)'', otherwise let ''Re<sub>⁎</sub> = -Re<sub>⁎</sub>' ''\n+* Let ''P = cpoint(pk)''; fail if that fails\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"SigVerify negation\"></div>Let ''g' = g⋅gacc mod n'' (See [[#negation-of-the-public-key-when-partially-verifying|Negation Of The Public Key When Partially Verifying]])\n+* Fail if ''s⋅G &ne; Re<sub>⁎</sub> + e⋅a⋅g'⋅P''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+=== Partial Signature Aggregation ===\n+\n+<div>\n+Algorithm ''PartialSigAgg(psig<sub>1..u</sub>, session_ctx)'':\n+* Inputs:\n+** The number ''u'' of signatures with ''0 < u < 2^32''\n+** The partial signatures ''psig<sub>1..u</sub>'': ''u'' 32-byte arrays\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, _, tacc, _, _, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* For ''i = 1 .. u'':\n+** Let ''s<sub>i</sub> = int(psig<sub>i</sub>)''; fail if ''s<sub>i</sub> &ge; n'' and blame signer ''i'' for invalid partial signature.\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* Let ''s = s<sub>1</sub> + ... + s<sub>u</sub> + e⋅g⋅tacc mod n''\n+* Return ''sig = ''xbytes(R) || bytes(32, s)''\n+</div>\n+\n+=== Test Vectors and Reference Code ===\n+\n+We provide a naive, highly inefficient, and non-constant time [[bip-musig2/reference.py|pure Python 3 reference implementation of the key aggregation, partial signing, and partial signature verification algorithms]].\n+\n+Standalone JSON test vectors are also available in the [[bip-musig2|same directory]], to facilitate porting the test vectors into other implementations.\n+\n+The reference implementation is for demonstration purposes only and not to be used in production environments.\n+\n+== Remarks on Security and Correctness ==\n+\n+=== Modifications to Nonce Generation ===\n+\n+Implementers must avoid modifying the ''NonceGen'' algorithm without being fully aware of the implications.\n+\n+One potential pitfall emerges when ''NonceGen'' is altered so the signer's public key ''pk'' is not part of the returned ''secnonce'' array.\n+This specification makes the signer provide ''pk'' at nonce generation time and write ''pk'' into the ''secnonce'' array (and check ''pk'' against ''sk'' in ''Sign'') to ensure that the public key of the signer is determined before sending out the ''pubnonce''.\n+If the public key is not determined before sending out the ''pubnonce'', an adversary can forge a signature by influencing the individual tweak of a victim signer after seeing the ''pubnonce'' (see the [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html bitcoin-dev mailing list post] and [https://github.com/jonasnick/musig2-tweaking writeup] for the details).\n+Thus, implementations must guarantee that the public key of the signer is determined before sending out the ''pubnonce'' if they cannot rule out that the signer's individual key is tweaked (e.g., derived via BIP32) with a tweak known to the adversary (e.g., as in BIP32 unhardened derivation).<ref>The nonce generation algorithm as given in the [https://eprint.iacr.org/2020/1261 MuSig2 paper] does not take ''pk'' as an input (and does not store it in the ''secnonce''). However, the security model considered in the paper does not cover security for signers who tweak their individual keys.</ref>\n+\n+We provide two modifications that are secure when applied correctly and may be useful in special circumstances, summarized in the following table.\n+\n+{| class=\"wikitable\" style=\"margin:auto\"\n+!                   !! needs secure randomness !! needs secure counter !! needs to keep state securely !! needs aggregated nonce of all other signers (only possible for one signer)\n+|-\n+! NonceGen          || ✓      || &nbsp; || ✓      || &nbsp;\n+|-\n+! CounterNonceGen   || &nbsp; || ✓      || ✓      || &nbsp;\n+|-\n+! DeterministicSign || &nbsp; || &nbsp; || &nbsp; || ✓\n+|}\n+\n+First, on systems where obtaining uniformly random values is much harder than maintaining a global atomic counter, it can be beneficial to modify ''NonceGen''.\n+The resulting algorithm ''CounterNonceGen'' does not draw ''rand' '' uniformly at random but instead sets ''rand' '' to the value of an atomic counter that is incremented whenever it is read.\n+With this modification, the secret signing key ''sk'' of the signer generating the nonce is '''not''' an optional argument and must be provided to ''NonceGen''.\n+The security of the resulting scheme is then depending on the requirement that reading the counter must never yield the same counter value in two ''NonceGen'' invocations with the same ''sk''.\n+\n+Second, if there is a unique signer who is supposed to send the ''pubnonce'' last, it is possible to modify nonce generation for this single signer to not require high-quality randomness.\n+Such a nonce generation algorithm ''DeterministicSign'' is specified below.\n+Note that the only optional argument is ''rand'', which can be omitted if randomness is entirely unavailable.\n+''DeterministicSign'' requires the argument ''aggothernonce'' which should be set to the output of ''NonceAgg'' run on the ''pubnonce'' value of '''all''' other signers (but can be provided by an untrusted party).\n+Hence, using ''DeterministicSign'' is only possible for the last signer to generate a nonce and makes the signer stateless, similar to the stateless signer described in the [[#nonce-generation|Nonce Generation]] section.\n+\n+==== Deterministic and Stateless Signing for a Single Signer ====\n+\n+<div>\n+Algorithm ''DeterministicSign(sk, aggothernonce, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, rand)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array\n+** The aggregate public nonce ''aggothernonce'' (see [[#modifications-to-nonce-generation|above]]): a 66-byte array\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 32-byte arrays\n+** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak methods ''is_xonly_t<sub>1..v</sub>'': ''v'' booleans\n+** The message ''m'': a byte array<ref name=\"mlen\" />\n+** The auxiliary randomness ''rand'': a 32-byte array (optional argument)\n+* If the optional argument ''rand'' is present:\n+** Let ''sk' '' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand)''\n+* Else:\n+** Let ''sk' = sk''\n+* Let ''keygen_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''keygen_ctx<sub>i</sub> = ApplyTweak(keygen_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''aggpk = GetPubkey(keygen_ctx<sub>v</sub>)''\n+* Let ''k<sub>i</sub> = int(hash<sub>MuSig/deterministic/nonce</sub>(sk' || aggothernonce || aggpk || bytes(8, len(m)) || m || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n+* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n+* Let ''R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> = k<sub>2</sub>⋅G''\n+* Let ''pubnonce = cbytes(R<sub>⁎,2</sub>) || cbytes(R<sub>⁎,2</sub>)''\n+* Let ''d = int(sk)''\n+* Fail if ''d = 0'' or ''d &ge; n''\n+* Let ''pk = cbytes(d⋅G)''\n+* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''\n+* Let ''aggnonce = NonceAgg((pubnonce, aggothernonce))''; fail if that fails and blame nonce aggregator for invalid ''aggothernonce''.",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 581,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": 1029784791,
      "user": {
        "login": "jonasnick",
        "id": 2582071,
        "node_id": "MDQ6VXNlcjI1ODIwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonasnick",
        "html_url": "https://github.com/jonasnick",
        "followers_url": "https://api.github.com/users/jonasnick/followers",
        "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
        "organizations_url": "https://api.github.com/users/jonasnick/orgs",
        "repos_url": "https://api.github.com/users/jonasnick/repos",
        "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonasnick/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The reason that there's no independent `DeterministicNonceGen` is that it is extremely fragile. When it is not used correctly, the secret signing key can leak to the public. For example, `aggnonce` must be the result of calling `NonceAgg` with the deterministic signers nonce and `aggothernonce`, which must be input to the nonce hash. If we had an independent `DeterministicNonceGen` instead of a `DeterministicSign` algorithm, we'd have to describe all of this in prose, which is susceptible to accidental misuse. `DeterministicSign`, on the other hand, is safe to use and can be tested using the provided test vectors.\r\n\r\nYes, it's possible to securely modify the stateless signer to require partial signatures from other parties before creating and publishing its partial signature. For example, this would be achieved by the following two algorithms wrapping `deterministic_sign`.\r\n\r\n```python\r\ndef deterministic_sign_stage1(sk, aggothernonce, pubkeys, tweaks, is_xonly, msg, rand):\r\n  pubnonce, _ = deterministic_sign(sk, aggothernonce, pubkeys, tweaks, is_xonly, msg, rand)\r\n  return pubnonce\r\n\r\ndef deterministic_sign_stage2(sk, aggothernonce, pubkeys, tweaks, is_xonly, msg, rand, psigs):\r\n  _, psig = deterministic_sign(sk, aggothernonce, pubkeys, tweaks, is_xonly, msg, rand)\r\n  for i in range(len(pubkeys)):\r\n    if pubkeys[i] == plain_pk_gen(sk):\r\n      continue\r\n    assert partial_sig_verify(psigs[i], pubnonces, pubkeys, tweaks, is_xonly, msg, i)\r\n  return psig\r\n```\r\n\r\nNote that the `stage2` requires recomputing a bunch of things that have been computed in `stage1` already but this is necessary to keep the signer stateless. Similarly, if the inputs in stage2 differ from `stage1`, the signer may produce a `psig` that doesn't match the pubnonce. It's possible in `stage1` to call a modified `deterministic_sign` that aborts as soon as the `pubnonce` is computed and does not compute a partial signature that is thrown away anyway. This is easy to see since the observable behavior of that `stage1` is indistinguishable from the original one.",
      "created_at": "2022-11-30T14:39:56Z",
      "updated_at": "2022-11-30T14:39:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1036053753",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1036053753"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 631,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1062495598",
      "pull_request_review_id": 1237424100,
      "id": 1062495598,
      "node_id": "PRRC_kwDOAN28mc4_VGVu",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''xbytes(Q)''\n+</div>\n+\n+<div>\n+Algorithm ''GetPlainPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''cbytes(Q)''\n+</div>\n+\n+==== Key Sorting ====\n+\n+<div>\n+Algorithm ''KeySort(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Return ''pk<sub>1..u</sub>'' sorted in lexicographical order.\n+</div>\n+\n+==== Key Aggregation ====\n+\n+<div>\n+Algorithm ''KeyAgg(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)''\n+* For ''i = 1 .. u'':\n+** Let ''P<sub>i</sub> = cpoint(pk<sub>i</sub>)''; fail if that fails and blame signer ''i'' for invalid public key.\n+** Let ''a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>, pk<sub>i</sub>, pk2)''.\n+* Let ''Q = a<sub>1</sub>⋅P<sub>1</sub> + a<sub>2</sub>⋅P<sub>2</sub> + ... + a<sub>u</sub>⋅P<sub>u</sub>''\n+* Fail if ''is_infinite(Q)''.\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''keygen_ctx = (Q, gacc, tacc)''.\n+</div>\n+\n+<div>\n+Internal Algorithm ''HashKeys(pk<sub>1..u</sub>)'':\n+* Return ''hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub> || ... || pk<sub>u</sub>)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''GetSecondKey(pk<sub>1..u</sub>)'':\n+* For ''j = 1 .. u'':\n+** If ''pk<sub>j</sub> &ne; pk<sub>1</sub>'':\n+*** Return ''pk<sub>j</sub>''\n+* Return ''bytes(33, 0)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeff(pk<sub>1..u</sub>, pk')'':\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)'':\n+* Return ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)'':\n+* Let ''L = HashKeys(pk<sub>1..u</sub>)''\n+* If ''pk' = pk2'':\n+** Return 1\n+* Return ''int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n''<ref>The key aggregation coefficient is computed by hashing the public key instead of its index, which requires one more invocation of the SHA-256 compression function. However, it results in significantly simpler implementations because signers do not need to translate between public key indices before and after sorting.</ref>\n+</div>\n+\n+==== Applying Tweaks ====\n+\n+<div>\n+Algorithm ''ApplyTweak(keygen_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''keygen_ctx'': a [[#keygen-context|KeyGen Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = keygen_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''keygen_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=== Nonce Generation ===\n+\n+<div>\n+Algorithm ''NonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array (optional argument)\n+** The plain public key ''pk'': a 33-byte array (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]] for the reason that this argument is mandatory)\n+** The aggregate x-only public key ''aggpk'': a 32-byte array (optional argument)\n+** The message ''m'': a byte array (optional argument)<ref name=\"mlen\">In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).</ref>\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>.\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''aggpk'' is not present:\n+** Let ''aggpk = empty_bytestring''\n+* If the optional argument ''m'' is not present:\n+** Let ''m_prefixed = bytes(1, 0)''\n+* Else:\n+** Let ''m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k<sub>i</sub> = int(hash<sub>MuSig/nonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(1, len(aggpk)) || aggpk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n+* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n+* Let ''R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> = k<sub>2</sub>⋅G''\n+* Let ''pubnonce = cbytes(R<sub>⁎,1</sub>) || cbytes(R<sub>⁎,2</sub>)''\n+* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=== Nonce Aggregation ===\n+\n+<div>\n+Algorithm ''NonceAgg(pubnonce<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of ''pubnonces'' with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+* For ''j = 1 .. 2'':\n+** For ''i = 1 .. u'':\n+*** Let ''R<sub>i,j</sub> = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])''; fail if that fails and blame signer ''i'' for invalid ''pubnonce''.\n+** Let ''R<sub>j</sub> = R<sub>1,j</sub> + R<sub>2,j</sub> + ... + R<sub>u,j</sub>''\n+* Return ''aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)''\n+</div>\n+\n+=== Session Context ===\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The aggregate public nonce ''aggnonce'': a 66-byte array\n+* The number ''u'' of public keys with ''0 < u < 2^32''\n+* The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+* The message ''m'': a byte array<ref name=\"mlen\" />\n+\n+We write \"Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\n+* Let ''keygen_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''keygen_ctx<sub>i</sub> = ApplyTweak(keygen_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = keygen_ctx<sub>v</sub>''\n+* Let ''b = int(hash<sub>MuSig/noncecoef</sub>(aggnonce || xbytes(Q) || m)) mod n''\n+* Let ''R<sub>1</sub> = cpoint_ext(aggnonce[0:33]), R<sub>2</sub> = cpoint_ext(aggnonce[33:66])''; fail if that fails and blame nonce aggregator for invalid ''aggnonce''.\n+* Let ''R' = R<sub>1</sub> + b⋅R<sub>2</sub>''\n+* If ''is_infinite(R'):\n+** Let final nonce ''R = G'' (see [[#dealing-with-infinity-in-nonce-aggregation|Dealing with Infinity in Nonce Aggregation]])\n+* Else:\n+** Let final nonce ''R = R' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Return ''(Q, gacc, tacc, b, R, e)''\n+</div>\n+\n+<div>\n+Algorithm ''GetSessionKeyAggCoeff(session_ctx, P)'':\n+* Let ''(_, u, pk<sub>1..u</sub>, _, _, _, _) = session_ctx''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk'' not in ''pk<sub>1..u</sub>''\n+* Return ''KeyAggCoeff(pk<sub>1..u</sub>, pk)''\n+</div>\n+\n+=== Signing ===\n+\n+<div>\n+Algorithm ''Sign(secnonce, sk, session_ctx)'':\n+* Inputs:\n+** The secret nonce ''secnonce'' that has never been used as input to ''Sign'' before: a 97-byte array\n+** The secret key ''sk'': a 32-byte array\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''k<sub>1</sub>' = int(secnonce[0:32]), k<sub>2</sub>' = int(secnonce[32:64])''\n+* Fail if ''k<sub>i</sub>' = 0'' or ''k<sub>i</sub>' &ge; n'' for ''i = 1..2''\n+* Let ''k<sub>1</sub> = k<sub>1</sub>', k<sub>2</sub> = k<sub>2</sub>' '' if ''has_even_y(R)'', otherwise let ''k<sub>1</sub> = n - k<sub>1</sub>', k<sub>2</sub> = n - k<sub>2</sub>' ''\n+* Let ''d' = int(sk)''\n+* Fail if ''d' = 0'' or ''d' &ge; n''\n+* Let ''P = d'⋅G''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk &ne; secnonce[64:97]''\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"Sign negation\"></div>Let ''d = g⋅gacc⋅d' mod n'' (See [[negation-of-the-secret-key-when-signing|Negation Of The Secret Key When Signing]])\n+* Let ''s = (k<sub>1</sub> + b⋅k<sub>2</sub> + e⋅a⋅d) mod n''\n+* Let ''psig = bytes(32, s)''\n+* Let ''pubnonce = cbytes(k<sub>1</sub>'⋅G) || cbytes(k<sub>2</sub>'⋅G)''\n+* If ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'' (see below) returns failure, abort<ref>Verifying the signature before leaving the signer prevents random or attacker provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret key. It is recommended, but can be omitted if the computation cost is prohibitive.</ref>.\n+* Return partial signature ''psig''\n+</div>\n+\n+=== Partial Signature Verification ===\n+\n+<div>\n+Algorithm ''PartialSigVerify(psig, pubnonce<sub>1..u</sub>, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)'':\n+* Inputs:\n+** The partial signature ''psig'': a 32-byte array\n+** The number ''u'' of public nonces and public keys with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+** The message ''m'': a byte array<ref name=\"mlen\" />\n+** The index of the signer ''i'' in the public nonces and public keys with ''0 < i &le; u''\n+* Let ''aggnonce = NonceAgg(pubnonce<sub>1..u</sub>)''; fail if that fails\n+* Let ''session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)''\n+* Run ''PartialSigVerifyInternal(psig, pubnonce<sub>i</sub>, pk<sub>i</sub>, session_ctx)''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+<div>\n+Internal Algorithm ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'':\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''s = int(psig)''; fail if ''s &ge; n''\n+* Let ''R<sub>⁎,1</sub> = cpoint(pubnonce[0:33]), R<sub>⁎,2</sub> = cpoint(pubnonce[33:66])''\n+* Let ''Re<sub>⁎</sub>' = R<sub>⁎,1</sub> + b⋅R<sub>⁎,2</sub>''\n+* Let effective nonce ''Re<sub>⁎</sub> = Re<sub>⁎</sub>' '' if ''has_even_y(R)'', otherwise let ''Re<sub>⁎</sub> = -Re<sub>⁎</sub>' ''\n+* Let ''P = cpoint(pk)''; fail if that fails\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"SigVerify negation\"></div>Let ''g' = g⋅gacc mod n'' (See [[#negation-of-the-public-key-when-partially-verifying|Negation Of The Public Key When Partially Verifying]])\n+* Fail if ''s⋅G &ne; Re<sub>⁎</sub> + e⋅a⋅g'⋅P''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+=== Partial Signature Aggregation ===\n+\n+<div>\n+Algorithm ''PartialSigAgg(psig<sub>1..u</sub>, session_ctx)'':\n+* Inputs:\n+** The number ''u'' of signatures with ''0 < u < 2^32''\n+** The partial signatures ''psig<sub>1..u</sub>'': ''u'' 32-byte arrays\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, _, tacc, _, _, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* For ''i = 1 .. u'':\n+** Let ''s<sub>i</sub> = int(psig<sub>i</sub>)''; fail if ''s<sub>i</sub> &ge; n'' and blame signer ''i'' for invalid partial signature.\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* Let ''s = s<sub>1</sub> + ... + s<sub>u</sub> + e⋅g⋅tacc mod n''\n+* Return ''sig = ''xbytes(R) || bytes(32, s)''\n+</div>\n+\n+=== Test Vectors and Reference Code ===\n+\n+We provide a naive, highly inefficient, and non-constant time [[bip-musig2/reference.py|pure Python 3 reference implementation of the key aggregation, partial signing, and partial signature verification algorithms]].\n+\n+Standalone JSON test vectors are also available in the [[bip-musig2|same directory]], to facilitate porting the test vectors into other implementations.\n+\n+The reference implementation is for demonstration purposes only and not to be used in production environments.\n+\n+== Remarks on Security and Correctness ==\n+\n+=== Modifications to Nonce Generation ===\n+\n+Implementers must avoid modifying the ''NonceGen'' algorithm without being fully aware of the implications.\n+\n+One potential pitfall emerges when ''NonceGen'' is altered so the signer's public key ''pk'' is not part of the returned ''secnonce'' array.\n+This specification makes the signer provide ''pk'' at nonce generation time and write ''pk'' into the ''secnonce'' array (and check ''pk'' against ''sk'' in ''Sign'') to ensure that the public key of the signer is determined before sending out the ''pubnonce''.\n+If the public key is not determined before sending out the ''pubnonce'', an adversary can forge a signature by influencing the individual tweak of a victim signer after seeing the ''pubnonce'' (see the [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html bitcoin-dev mailing list post] and [https://github.com/jonasnick/musig2-tweaking writeup] for the details).\n+Thus, implementations must guarantee that the public key of the signer is determined before sending out the ''pubnonce'' if they cannot rule out that the signer's individual key is tweaked (e.g., derived via BIP32) with a tweak known to the adversary (e.g., as in BIP32 unhardened derivation).<ref>The nonce generation algorithm as given in the [https://eprint.iacr.org/2020/1261 MuSig2 paper] does not take ''pk'' as an input (and does not store it in the ''secnonce''). However, the security model considered in the paper does not cover security for signers who tweak their individual keys.</ref>\n+\n+We provide two modifications that are secure when applied correctly and may be useful in special circumstances, summarized in the following table.\n+\n+{| class=\"wikitable\" style=\"margin:auto\"\n+!                   !! needs secure randomness !! needs secure counter !! needs to keep state securely !! needs aggregated nonce of all other signers (only possible for one signer)\n+|-\n+! NonceGen          || ✓      || &nbsp; || ✓      || &nbsp;\n+|-\n+! CounterNonceGen   || &nbsp; || ✓      || ✓      || &nbsp;\n+|-\n+! DeterministicSign || &nbsp; || &nbsp; || &nbsp; || ✓\n+|}\n+\n+First, on systems where obtaining uniformly random values is much harder than maintaining a global atomic counter, it can be beneficial to modify ''NonceGen''.\n+The resulting algorithm ''CounterNonceGen'' does not draw ''rand' '' uniformly at random but instead sets ''rand' '' to the value of an atomic counter that is incremented whenever it is read.\n+With this modification, the secret signing key ''sk'' of the signer generating the nonce is '''not''' an optional argument and must be provided to ''NonceGen''.\n+The security of the resulting scheme is then depending on the requirement that reading the counter must never yield the same counter value in two ''NonceGen'' invocations with the same ''sk''.\n+\n+Second, if there is a unique signer who is supposed to send the ''pubnonce'' last, it is possible to modify nonce generation for this single signer to not require high-quality randomness.\n+Such a nonce generation algorithm ''DeterministicSign'' is specified below.\n+Note that the only optional argument is ''rand'', which can be omitted if randomness is entirely unavailable.",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 547,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": 1028573847,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I can't follow, can you elaborate?",
      "created_at": "2023-01-05T13:52:02Z",
      "updated_at": "2023-01-05T13:52:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1062495598",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1062495598"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1062747976",
      "pull_request_review_id": 1237813695,
      "id": 1062747976,
      "node_id": "PRRC_kwDOAN28mc4_WD9I",
      "diff_hunk": "@@ -0,0 +1,761 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2\n+  Author: Jonas Nick <jonasd.nick@gmail.com>\n+          Tim Ruffing <crypto@timruffing.de>\n+          Elliott Jin <elliott.jin@gmail.com>\n+  Status: Draft\n+  License: BSD-3-Clause\n+  Type: Informational\n+  Created: 2022-03-22\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document proposes a standard for the [https://eprint.iacr.org/2020/1261.pdf MuSig2] protocol.\n+The standard is compatible with [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] public keys and signatures.\n+It supports ''tweaking'', which allows deriving [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] child keys from aggregate keys and creating [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] Taproot outputs with key and script paths.\n+\n+=== Copyright ===\n+\n+This document is licensed under the 3-clause BSD license.\n+\n+=== Motivation ===\n+\n+MuSig2 is a multi-signature scheme that allows multiple signers to create a single aggregate public key and cooperatively create ordinary Schnorr signatures valid under the aggregate key.\n+Signing requires interaction between ''all'' signers involved in key aggregation.\n+(MuSig2 is a ''n-of-n'' multi-signature scheme and not a ''t-of-n'' threshold-signature scheme.)\n+\n+The primary motivation is to create a standard that allows users of different software projects to jointly control Taproot outputs ([https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341]).\n+Such an output contains a public key which, in this case, would be the aggregate of all users' public keys.\n+It can be spent using MuSig2 to produce a signature for the key-based spending path.\n+\n+The on-chain footprint of a MuSig2 Taproot output is essentially a single BIP340 public key, and a transaction spending the output only requires a single signature cooperatively produced by all signers. This is '''more compact''' and has '''lower verification cost''' than each signer providing an individual public key and signature, as would be required by an ''n-of-n'' policy implemented using <code>OP_CHECKSIGADD</code> as introduced in ([https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki BIP342]).\n+As a side effect, the number ''n'' of signers is not limited by any consensus rules when using MuSig2.\n+\n+Moreover, MuSig2 offers a '''higher level of privacy''' than <code>OP_CHECKSIGADD</code>: MuSig2 Taproot outputs are indistinguishable for a blockchain observer from regular, single-signer Taproot outputs even though they are actually controlled by multiple signers. By tweaking an aggregate key, the shared Taproot output can have script spending paths that are hidden unless used.\n+\n+There are multi-signature schemes other than MuSig2 that are fully compatible with Schnorr signatures.\n+The MuSig2 variant in this specification stands out by combining all of the following features:\n+* '''Simple Key Setup''': Key aggregation is non-interactive and fully compatible with BIP340 public keys.\n+* '''Two Communication Rounds''': MuSig2 is faster in practice than previous three-round multi-signature protocols such as [https://eprint.iacr.org/2018/068.pdf MuSig1], particularly when signers are connected through high-latency anonymous links. Moreover, the need for fewer communication rounds simplifies the specification and reduces the probability that implementations and users make security-relevant mistakes.\n+* '''Provable security''': MuSig2 has been [https://eprint.iacr.org/2020/1261.pdf proven existentially unforgeable] under the algebraic one-more discrete logarithm (AOMDL) assumption (instead of the discrete logarithm assumption required for single-signer Schnorr signatures). AOMDL is a falsifiable and weaker variant of the well-studied OMDL problem.\n+* '''Low complexity''': MuSig2 has a substantially lower computational and implementation complexity than alternative schemes like [https://eprint.iacr.org/2020/1057 MuSig-DN]. However, this comes at the cost of having no ability to generate nonces deterministically and the requirement to securely handle signing state.\n+\n+=== Design ===\n+\n+* '''Compatibility with BIP340''': The aggregate public key created as part of this MuSig2 specification is a BIP340 X-only public key, and the signature output at the end of the protocol is a BIP340 signature that passes BIP340 verification for the aggregate key and a message. The public keys that are input to the key aggregation algorithm are ''plain'' public keys in compressed format.\n+* '''Tweaking for BIP32 derivations and Taproot''': The specification supports tweaking aggregate public keys and signing for tweaked aggregate public keys. We distinguish two modes of tweaking: ''Plain'' tweaking can be used to derive child aggregate public keys per [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32]. ''X-only'' tweaking, on the other hand, allows creating a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] tweak to add script paths to a Taproot output. See section [[#tweaking|Tweaking]] below for details.\n+* '''Non-interactive signing with preprocessing''': The first communication round, exchanging the nonces, can happen before the message or even the exact set of signers is determined. Therefore, the signers can view it as a preprocessing step. Later, when the parameters of the signing session are chosen, they can send partial signatures without additional interaction.\n+* '''Key aggregation optionally independent of order''': The output of the key aggregation algorithm depends on the order of the input public keys. The specification defines a function to sort the public keys before key aggregation. This will ensure the same output, independent of the initial order. Key aggregation does not sort the public keys by default because applications often already have a canonical order of signers. Nonetheless, applications using this specification can mandate sorting before aggregation<ref>Applications that sort input public keys before aggregation should ensure that the sort implementation is reasonably efficient, and in particular does not degenerate to quadratic runtime on pathological inputs.</ref>.\n+* '''Third-party nonce and partial signature aggregation''': Instead of every signer sending their nonce and partial signature to every other signer, it is possible to use an untrusted third-party ''aggregator'' in order to reduce the communication complexity from quadratic to linear in the number of signers. In each of the two rounds, the aggregator collects all signers' contributions (nonces or partial signatures), aggregates them, and broadcasts the aggregate back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+* '''Partial signature verification''': If any signer sends a partial signature contribution that was not created by honestly following the protocol, the signing session will fail to produce a valid Schnorr signature. This standard specifies a partial signature verification algorithm to identify disruptive signers. It is incompatible with third-party nonce aggregation because the individual nonce is required for partial verification.\n+* '''MuSig2* optimization''': The specification uses an optimization that allows saving a point multiplication in key aggregation. The MuSig2 scheme with this optimization is called MuSig2* and proven secure in the appendix of the [https://eprint.iacr.org/2020/1261 MuSig2 paper]. The optimization is that the second distinct key in the list of public keys given to the key aggregation algorithm (as well as any keys identical to this key) gets the constant key aggregation coefficient ''1''.\n+* '''Parameterization of MuSig2 and security''': In this specification, each signer's nonce consists of two elliptic curve points. The [https://eprint.iacr.org/2020/1261 MuSig2 paper] gives distinct security proofs depending on the number of points that constitute a nonce. See section [[#choosing-the-size-of-the-nonce|Choosing the Size of the Nonce]] for a discussion.\n+\n+== Overview ==\n+\n+Implementers of this specification must make sure to understand this section thoroughly to avoid subtle mistakes that may lead to catastrophic failure.\n+\n+=== Optionality of Features ===\n+\n+The goal of this specification is to support a wide range of possible application scenarios.\n+Given a specific application scenario, some features supported by this specification may be unnecessary or not desirable, and implementers can choose not to support them.\n+Such optional features include:\n+* Applying plain tweaks after x-only tweaks.\n+* Applying tweaks at all.\n+* Dealing with messages that are not exactly 32 bytes.\n+* Identifying a disruptive signer after aborting (aborting itself remains mandatory).\n+* Dealing with duplicate public keys in key aggregation.\n+If applicable, the corresponding algorithms should simply fail when encountering inputs unsupported by a particular implementation. (For example, the signing algorithm may fail when given a message which is not 32 bytes.)\n+Similarly, the test vectors that exercise the unimplemented features should be re-interpreted to expect an error, or be skipped if appropriate.\n+\n+=== General Signing Flow ===\n+\n+The signers start by exchanging public keys and computing an aggregate public key using the ''KeyAgg'' algorithm.\n+Whenever they want to sign a message, the basic order of operations to create a multi-signature with the specification is as follows:\n+\n+'''First broadcast round:'''\n+The signers start the signing session by running ''NonceGen'' to compute ''secnonce'' and ''pubnonce''<ref>We treat the ''secnonce'' and ''pubnonce'' as grammatically singular even though they include serializations of two scalars and two elliptic curve points, respectively. This treatment may be confusing for readers familiar with the MuSig2 paper. However, serialization is a technical detail that is irrelevant for users of MuSig2 interfaces.</ref>.\n+Then, the signers broadcast their ''pubnonce'' to each other and run ''NonceAgg'' to compute an aggregate nonce.\n+\n+'''Second broadcast round:'''\n+At this point, every signer has the required data to sign, which, in the specification, is stored in a data structure called [[#session-context|Session Context]].\n+Every signer computes a partial signature by running ''Sign'' with the secret signing key, the ''secnonce'' and the session context.\n+Then, the signers broadcast their partial signatures to each other and run ''PartialSigAgg'' to obtain the final signature.\n+If all signers behaved honestly, the result passes [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] verification.\n+\n+Both broadcast rounds can be optimized by using an aggregator who collects all signers' nonces or partial signatures, aggregates them using ''NonceAgg'' or ''PartialSigAgg'', respectively, and broadcasts the aggregated result back to the signers. A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme, i.e., even a malicious aggregator colluding with all but one signer cannot forge a signature.\n+\n+'''IMPORTANT''': The ''Sign'' algorithm must '''not''' be executed twice with the same ''secnonce''.\n+Otherwise, it is possible to extract the secret signing key from the two partial signatures output by the two executions of ''Sign''.\n+To avoid accidental reuse of ''secnonce'', an implementation may securely erase the ''secnonce'' argument by overwriting it with 64 zero bytes after it has been read by ''Sign''.\n+A ''secnonce'' consisting of only zero bytes is invalid for ''Sign'' and will cause it to fail.\n+\n+To simplify the specification, some intermediary values are unnecessarily recomputed from scratch, e.g., when executing ''GetSessionValues'' multiple times.\n+Actual implementations can cache these values.\n+As a result, the [[#session-context|Session Context]] may look very different in implementations or may not exist at all.\n+However, computation of ''GetSessionValues'' and storage of the result must be protected against modification from an untrusted third party.\n+This party would have complete control over the aggregate public key and message to be signed.\n+\n+=== Public Key Aggregation  ===\n+\n+This specification distinguishes between ''plain public keys'', the traditional key type used in Bitcoin, and ''x-only public keys''.\n+Plain public keys are byte strings of length 33 (often called ''compressed'' format) in this specification.\n+In contrast, X-only public keys are 32-byte strings defined in [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340].\n+\n+The input of the key aggregation algorithm ''KeyAgg'' (and of ''GetSessionValues'' and ''PartialSigVerify'') are plain public keys.\n+The output of ''KeyAgg'' is a [[#keygen-context|KeyGen Context]] which stores information required for tweaking (see [[#tweaking|below]]).\n+In order to obtain the (X-only) aggregate public key for BIP340 verification, implementations call the ''GetXonlyPubkey'' function with the KeyGen Context.\n+It is also possible to get the plain aggregate public from the KeyGen Context using ''GetPlainPubkey'', which is required for some applications of [[#tweaking|tweaking]].\n+\n+The aggregate key produced by ''KeyAgg'' is dependent on the order of the input public keys.\n+If the application does not have a canonical order of the signers, the public keys can be sorted with the ''KeySort'' algorithm to ensure that the aggregate key is independent of the order of signers.\n+\n+The same public key is allowed to occur more than once in the input of ''KeyAgg'' and ''KeySort''.\n+This is by design: All algorithms in this specification handle multiple signers who (claim to) have identical public keys properly,\n+and applications are not required to check for duplicate public keys.\n+In fact, applications are recommended to omit checks for duplicate public keys in order to simplify error handling.\n+Moreover, it is often impossible to tell at key aggregation which signer is to blame for the duplicate, i.e., which signer came up with the public key honestly and which disruptive signer copied it.\n+In contrast, MuSig2 is designed to identify disruptive signers at signing time (see [[#identifiying-disruptive-signers|Identifiying Disruptive Signers]]).\n+\n+While this specification is able to deal with duplicate public keys, there are scenarios where applications may choose to abort when encountering duplicate public keys.\n+For example, we can imagine a scenario where a single entity creates a MuSig2 setup with multiple signing devices.\n+In that case, duplicate public keys may not result from a malicious signing device copying a public key of another signing device but from accidental initialization of two devices with the same seed.\n+Since MuSig2 key aggregation would accept the duplicate keys and not error out, which would in turn reduce the security compared to the intended key setup, applications may reject duplicate public keys before passing them to MuSig2 key aggregation and ask the user to investigate.\n+\n+=== Nonce Generation ===\n+\n+'''IMPORTANT''': ''NonceGen'' must have access to a high-quality random generator to draw an unbiased, uniformly random value ''rand' ''.\n+In contrast to BIP340 signing, the values ''k<sub>1</sub>'' and ''k<sub>2</sub>'' '''must not be derived deterministically''' from the session parameters because otherwise active attackers can  [https://medium.com/blockstream/musig-dn-schnorr-multisignatures-with-verifiably-deterministic-nonces-27424b5df9d6#e3b6 trick the victim into reusing a nonce].\n+\n+The optional arguments to ''NonceGen'' enable a defense-in-depth mechanism that may prevent secret key exposure if ''rand' '' is accidentally not drawn uniformly at random.\n+If the value ''rand' '' was identical in two ''NonceGen'' invocations, but any other argument was different, the ''secnonce'' would still be guaranteed be different as well (with overwhelming probability), and thus accidentally using the same ''secnonce'' for ''Sign'' in both sessions would be avoided.\n+Therefore, it is recommended to provide the optional arguments ''sk'', ''aggpk'', and ''m'' if these session parameters are already determined during nonce generation.\n+The auxiliary input ''extra_in'' can contain additional contextual data that has a chance of changing between ''NonceGen'' runs,\n+e.g., a supposedly unique session id (taken from the application), a session counter wide enough not to repeat in practice, any nonces by other signers (if already known), or the serialization of a data structure containing multiple of the above.\n+However, the protection provided by the optional arguments should only be viewed as a last resort.\n+In most conceivable scenarios, the assumption that the arguments are different between two executions of ''NonceGen'' is relatively strong, particularly when facing an active attacker.\n+\n+In some applications, it is beneficial to generate and send a ''pubnonce'' before the other signers, their public keys, or the message to sign is known.\n+In this case, only the available arguments are provided to the ''NonceGen'' algorithm.\n+After this preprocessing phase, the ''Sign'' algorithm can be run immediately when the message and set of signers is determined.\n+This way, the final signature is created quicker and with fewer roundtrips.\n+However, applications that use this method presumably store the nonces for a longer time and must therefore be even more careful not to reuse them.\n+Moreover, this method is not compatible with the defense-in-depth mechanism described in the previous paragraph.\n+\n+Instead of every signer broadcasting their ''pubnonce'' to every other signer, the signers can send their ''pubnonce'' to a single aggregator node that runs ''NonceAgg'' and sends the ''aggnonce'' back to the signers.\n+This technique reduces the overall communication.\n+A malicious aggregator can force the signing session to fail to produce a valid Schnorr signature but cannot negatively affect the unforgeability of the scheme.\n+\n+In general, MuSig2 signers are stateful in the sense that they first generate ''secnonce'' and then need to store it until they receive the other signers' ''pubnonces'' or the ''aggnonce''.\n+However, it is possible for one of the signers to be stateless.\n+This signer waits until it receives the ''pubnonce'' of all the other signers and until session parameters such as a message to sign, public keys, and tweaks are determined.\n+Then, the signer can run ''NonceGen'', ''NonceAgg'' and ''Sign'' in sequence and send out its ''pubnonce'' along with its partial signature.\n+Stateless signers may want to consider signing deterministically (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]]) to remove the reliance on the random number generator in the ''NonceGen'' algorithm.\n+\n+=== Identifying Disruptive Signers ===\n+\n+The signing protocol makes it possible to identify malicious signers who send invalid contributions to a signing session in order to make the signing session abort and prevent the honest signers from obtaining a valid signature.\n+This property is called \"identifiable aborts\" and ensures that honest parties can assign blame to malicious signers who cause an abort in the signing protocol.\n+\n+Aborts are identifiable for an honest party if the following conditions hold in a signing session:\n+* The contributions received from all signers have not been tampered with (e.g., because they were sent over authenticated connections).\n+* Nonce aggregation is performed honestly (e.g., because the honest signer performs nonce aggregation on its own or because the aggregator is trusted).\n+* The partial signatures received from all signers are verified using the algorithm ''PartialSigVerify''.\n+\n+If these conditions hold and an honest party (signer or aggregator) runs an algorithm that fails due to invalid protocol contributions from malicious signers, then the algorithm run by the honest party will output the index of exactly one malicious signer.\n+Additionally, if the honest parties agree on the contributions sent by all signers in the signing session, all the honest parties who run the aborting algorithm will identify the same malicious signer.\n+\n+==== Further remarks ====\n+\n+Some of the algorithms in this specification may also assign blame to a malicious aggregator.\n+While this is possible for some particular misbehavior of the aggregator, it is not guaranteed that a malicious aggregator can be identified.\n+More specifically, a malicious aggregator (whose existence violates the second condition above) can always make signing abort and wrongly hold honest signers accountable for the abort (e.g., by claiming to have received an invalid contribution from a particular honest signer).\n+\n+The only purpose of the algorithm ''PartialSigVerify'' is to ensure identifiable aborts, and it is not necessary to use it when identifiable aborts are not desired.\n+In particular, partial signatures are ''not'' signatures.\n+An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key<ref>Assume an adversary wants to forge a partial signature for public key ''P''. It joins the signing session pretending to be two different signers, one with public key ''P'' and one with another public key. The adversary can then set the second signer's nonce such that it will be able to produce a partial signature for ''P'', but not for the other claimed signer. An explanation of the individual steps required to create a partial signature forgery can be found in [https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b this writeup].</ref>.\n+However, if ''PartialSigVerify'' succeeds for all partial signatures then ''PartialSigAgg'' will return a valid Schnorr signature.<ref>Given a list of public keys, it is an open question whether a valid BIP-340 signature for the aggregate of the public keys is proof of knowledge of the secret keys corresponding to the input list.</ref>\n+\n+=== Tweaking ===\n+\n+The aggregate public key can be ''tweaked'', which modifies the key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+In order to apply a tweak, the KeyGen Context output by ''KeyAgg'' is provided to the ''ApplyTweak'' algorithm with the ''is_xonly_t'' argument set to false for plain tweaking and true for X-only tweaking.\n+The resulting KeyGen Context can be used to apply another tweak with ''ApplyTweak'' or obtain the aggregate public key with ''GetXonlyPubkey'' or ''GetPlainPubkey''.\n+\n+In addition to public keys, the ''KeyAgg'' algorithm accepts tweaks, which modify the aggregate public key as defined in the [[#tweaking-definition|Tweaking Definition]] subsection.\n+For example, if ''KeyAgg'' is run with ''v = 2'', ''is_xonly_t<sub>1</sub> = false'', ''is_xonly_t<sub>2</sub> = true'', then the aggregate key is first plain tweaked with ''tweak<sub>1</sub>'' and then X-only tweaked with ''tweak<sub>2</sub>''.\n+\n+The purpose of specifying tweaking is to ensure compatibility with existing uses of tweaking, i.e., that the result of signing is a valid signature for the tweaked public key.\n+The MuSig2 algorithms take arbitrary tweaks as input but accepting arbitrary tweaks may negatively affect the protocol's security.<ref>It is an open question whether allowing arbitrary tweaks from an adversary affects the unforgeability of MuSig2.</ref>\n+Instead, signers should obtain the tweaks according to other specifications.\n+This typically involves deriving the tweaks from a hash of the aggregate public key and some other information.\n+Depending on the specific scheme that is used for tweaking, either the plain or the X-only aggregate public key is required.\n+For example, to do [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32] derivation, you call ''GetPlainPubkey'' to be able to compute the tweak, whereas  [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] TapTweaks require X-only public keys that are obtained with ''GetXonlyPubkey''.\n+\n+The tweak mode provided to ''ApplyTweak'' depends on the application:\n+Plain tweaking can be used to derive child public keys from an aggregate public key using [https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki BIP32].\n+On the other hand, X-only tweaking is required for Taproot tweaking per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341].\n+A Taproot-tweaked public key commits to a ''script path'', allowing users to create transaction outputs that are spendable either with a MuSig2 multi-signature or by providing inputs that satisfy the script path.\n+\n+== Algorithms ==\n+\n+This specification is written with a focus on clarity.\n+As a result, the specified algorithms are not always optimal in terms of computation and space.\n+In particular, some values are recomputed but can be cached in actual implementations (see [[#signing-flow|Signing Flow]]).\n+\n+=== Notation ===\n+\n+The following conventions are used, with constants as defined for [https://www.secg.org/sec2-v2.pdf secp256k1]. We note that adapting this specification to other elliptic curves is not straightforward and can result in an insecure scheme.\n+* Lowercase variables represent integers or byte arrays.\n+** The constant ''p'' refers to the field size, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F''.\n+** The constant ''n'' refers to the curve order, ''0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141''.\n+* Uppercase variables refer to points on the curve with equation ''y<sup>2</sup> = x<sup>3</sup> + 7'' over the integers modulo ''p''.\n+** ''is_infinite(P)'' returns whether or not ''P'' is the point at infinity.\n+** ''x(P)'' and ''y(P)'' are integers in the range ''0..p-1'' and refer to the X and Y coordinates of a point ''P'' (assuming it is not infinity).\n+** The constant ''G'' refers to the base point, for which ''x(G) = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798'' and ''y(G) = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8''.\n+** Addition of points refers to the usual [https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law elliptic curve group operation].\n+** [https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication Multiplication (⋅) of an integer and a point] refers to the repeated application of the group operation.\n+* Functions and operations:\n+** ''||'' refers to byte array concatenation.\n+** The function ''x[i:j]'', where ''x'' is a byte array and ''i, j &ge; 0'', returns a ''(j - i)''-byte array with a copy of the ''i''-th byte (inclusive) to the ''j''-th byte (exclusive) of ''x''.\n+** The function ''bytes(n, x)'', where ''x'' is an integer, returns the n-byte encoding of ''x'', most significant byte first.\n+** The constant ''empty_bytestring'' refers to the empty byte array. It holds that ''len(empty_bytestring) = 0''.\n+** The function ''xbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''bytes(32, x(P))''.\n+** The function ''len(x)'' where ''x'' is a byte array returns the length of the array.\n+** The function ''has_even_y(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''y(P) mod 2 == 0''.\n+** The function ''with_even_y(P)'', where ''P'' is a point, returns ''P'' if ''is_infinite(P)'' or ''has_even_y(P)''. Otherwise,  ''with_even_y(P)'' returns ''-P''.\n+** The function ''cbytes(P)'', where ''P'' is a point for which ''not is_infinite(P)'', returns ''a || xbytes(P)'' where ''a'' is a byte that is ''2'' if ''has_even_y(P)'' and ''3'' otherwise.\n+** The function ''cbytes_ext(P)'', where ''P'' is a point, returns ''bytes(33, 0)'' if ''is_infinite(P)''. Otherwise, it returns ''cbytes(P)''.\n+** The function ''int(x)'', where ''x'' is a 32-byte array, returns the 256-bit unsigned integer whose most significant byte first encoding is ''x''.\n+** The function ''lift_x(x)'', where ''x'' is an integer in range ''0..2<sup>256</sup>-1'', returns the point ''P'' for which ''x(P) = x''<ref>\n+    Given a candidate X coordinate ''x'' in the range ''0..p-1'', there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then ''x'' is not a valid X coordinate either, i.e., no point ''P'' exists for which ''x(P) = x''. The valid Y coordinates for a given candidate ''x'' are the square roots of ''c = x<sup>3</sup> + 7 mod p'' and they can be computed as ''y = &plusmn;c<sup>(p+1)/4</sup> mod p'' (see [https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus Quadratic residue]) if they exist, which can be checked by squaring and comparing with ''c''.</ref> and ''has_even_y(P)'', or fails if ''x'' is greater than ''p-1'' or no such point exists. The function ''lift_x(x)'' is equivalent to the following pseudocode:\n+*** Fail if ''x &gt; p-1''.\n+*** Let ''c = x<sup>3</sup> + 7 mod p''.\n+*** Let ''y' = c<sup>(p+1)/4</sup> mod p''.\n+*** Fail if ''c &ne; y'<sup>2</sup> mod p''.\n+*** Let ''y = y' '' if ''y' mod 2 = 0'', otherwise let ''y = p - y' ''.\n+*** Return the unique point ''P'' such that ''x(P) = x'' and ''y(P) = y''.\n+** The function ''cpoint(x)'', where ''x'' is a 33-byte array (compressed serialization), sets ''P = lift_x(int(x[1:33]))'' and fails if that fails. If ''x[0] = 2'' it returns ''P'' and if ''x[0] = 3'' it returns ''-P''. Otherwise, it fails.\n+** The function ''cpoint_ext(x)'', where ''x'' is a 33-byte array (compressed serialization), returns the point at infinity if ''x = bytes(33, 0)''. Otherwise, it returns ''cpoint(x)'' and fails if that fails.\n+** The function ''hash<sub>tag</sub>(x)'' where ''tag'' is a UTF-8 encoded tag name and ''x'' is a byte array returns the 32-byte hash ''SHA256(SHA256(tag) || SHA256(tag) || x)''.\n+* Other:\n+** Tuples are written by listing the elements within parentheses and separated by commas. For example, ''(2, 3, 1)'' is a tuple.\n+\n+=== Key Generation ===\n+\n+==== KeyGen Context ====\n+\n+The KeyGen Context is a data structure consisting of the following elements:\n+* The point ''Q'' representing the aggregate and potentially tweaked public key: an elliptic curve point\n+* The accumulated tweak ''tacc'': an integer with ''0 &le; tacc < n''\n+* The value ''gacc'' : 1 or -1 mod n\n+\n+We write \"Let ''(Q, gacc, tacc) = keygen_ctx''\" to assign names to the elements of a KeyGen Context.\n+\n+<div>\n+Algorithm ''GetXonlyPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''xbytes(Q)''\n+</div>\n+\n+<div>\n+Algorithm ''GetPlainPubkey(keygen_ctx)'':\n+* Let ''(Q, _, _) = keygen_ctx''\n+* Return ''cbytes(Q)''\n+</div>\n+\n+==== Key Sorting ====\n+\n+<div>\n+Algorithm ''KeySort(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Return ''pk<sub>1..u</sub>'' sorted in lexicographical order.\n+</div>\n+\n+==== Key Aggregation ====\n+\n+<div>\n+Algorithm ''KeyAgg(pk<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of public keys with ''0 < u < 2^32''\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)''\n+* For ''i = 1 .. u'':\n+** Let ''P<sub>i</sub> = cpoint(pk<sub>i</sub>)''; fail if that fails and blame signer ''i'' for invalid public key.\n+** Let ''a<sub>i</sub> = KeyAggCoeffInternal(pk<sub>1..u</sub>, pk<sub>i</sub>, pk2)''.\n+* Let ''Q = a<sub>1</sub>⋅P<sub>1</sub> + a<sub>2</sub>⋅P<sub>2</sub> + ... + a<sub>u</sub>⋅P<sub>u</sub>''\n+* Fail if ''is_infinite(Q)''.\n+* Let ''gacc = 1''\n+* Let ''tacc = 0''\n+* Return ''keygen_ctx = (Q, gacc, tacc)''.\n+</div>\n+\n+<div>\n+Internal Algorithm ''HashKeys(pk<sub>1..u</sub>)'':\n+* Return ''hash<sub>KeyAgg list</sub>(pk<sub>1</sub> || pk<sub>2</sub> || ... || pk<sub>u</sub>)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''GetSecondKey(pk<sub>1..u</sub>)'':\n+* For ''j = 1 .. u'':\n+** If ''pk<sub>j</sub> &ne; pk<sub>1</sub>'':\n+*** Return ''pk<sub>j</sub>''\n+* Return ''bytes(33, 0)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeff(pk<sub>1..u</sub>, pk')'':\n+* Let ''pk2 = GetSecondKey(pk<sub>1..u</sub>)'':\n+* Return ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)''\n+</div>\n+\n+<div>\n+Internal Algorithm ''KeyAggCoeffInternal(pk<sub>1..u</sub>, pk', pk2)'':\n+* Let ''L = HashKeys(pk<sub>1..u</sub>)''\n+* If ''pk' = pk2'':\n+** Return 1\n+* Return ''int(hash<sub>KeyAgg coefficient</sub>(L || pk')) mod n''<ref>The key aggregation coefficient is computed by hashing the public key instead of its index, which requires one more invocation of the SHA-256 compression function. However, it results in significantly simpler implementations because signers do not need to translate between public key indices before and after sorting.</ref>\n+</div>\n+\n+==== Applying Tweaks ====\n+\n+<div>\n+Algorithm ''ApplyTweak(keygen_ctx, tweak, is_xonly_t)'':\n+* Inputs:\n+** The ''keygen_ctx'': a [[#keygen-context|KeyGen Context]] data structure\n+** The ''tweak'': a 32-byte array\n+** The tweak mode ''is_xonly_t'': a boolean\n+* Let ''(Q, gacc, tacc) = keygen_ctx''\n+* If ''is_xonly_t'' and ''not has_even_y(Q)'':\n+** Let ''g = -1 mod n''\n+* Else:\n+** Let ''g = 1''\n+* Let ''t = int(tweak)''; fail if ''t &ge; n''\n+* Let ''Q' = g⋅Q + t⋅G''\n+** Fail if ''is_infinite(Q')''\n+* Let ''gacc' = g⋅gacc mod n''\n+* Let ''tacc' = t + g⋅tacc mod n''\n+* Return ''keygen_ctx' = (Q', gacc', tacc')''\n+</div>\n+\n+=== Nonce Generation ===\n+\n+<div>\n+Algorithm ''NonceGen(sk, pk, aggpk, m, extra_in)'':\n+* Inputs:\n+** The secret signing key ''sk'': a 32-byte array (optional argument)\n+** The plain public key ''pk'': a 33-byte array (see [[#modifications-to-nonce-generation|Modifications to Nonce Generation]] for the reason that this argument is mandatory)\n+** The aggregate x-only public key ''aggpk'': a 32-byte array (optional argument)\n+** The message ''m'': a byte array (optional argument)<ref name=\"mlen\">In theory, the allowed message size is restricted because SHA256 accepts byte strings only up to size of 2^61-1 bytes (and because of the 8-byte length encoding).</ref>\n+** The auxiliary input ''extra_in'': a byte array with ''0 &le; len(extra_in) &le; 2<sup>32</sup>-1'' (optional argument)\n+* Let ''rand' '' be a 32-byte array freshly drawn uniformly at random\n+* If the optional argument ''sk'' is present:\n+** Let ''rand'' be the byte-wise xor of ''sk'' and ''hash<sub>MuSig/aux</sub>(rand')''<ref>The random data is hashed (with a unique tag) as a precaution against situations where the randomness may be correlated with the secret signing key itself. It is xored with the secret key (rather than combined with it in a hash) to reduce the number of operations exposed to the actual secret key.</ref>.\n+* Else:\n+** Let ''rand = rand' ''\n+* If the optional argument ''aggpk'' is not present:\n+** Let ''aggpk = empty_bytestring''\n+* If the optional argument ''m'' is not present:\n+** Let ''m_prefixed = bytes(1, 0)''\n+* Else:\n+** Let ''m_prefixed = bytes(1, 1) || bytes(8, len(m)) || m''\n+* If the optional argument ''extra_in'' is not present:\n+** Let ''extra_in = empty_bytestring''\n+* Let ''k<sub>i</sub> = int(hash<sub>MuSig/nonce</sub>(rand || bytes(1, len(pk)) || pk || bytes(1, len(aggpk)) || aggpk || m_prefixed || bytes(4, len(extra_in)) || extra_in || bytes(1, i - 1))) mod n'' for ''i = 1,2''\n+* Fail if ''k<sub>1</sub> = 0'' or ''k<sub>2</sub> = 0''\n+* Let ''R<sub>⁎,1</sub> = k<sub>1</sub>⋅G, R<sub>⁎,2</sub> = k<sub>2</sub>⋅G''\n+* Let ''pubnonce = cbytes(R<sub>⁎,1</sub>) || cbytes(R<sub>⁎,2</sub>)''\n+* Let ''secnonce = bytes(32, k<sub>1</sub>) || bytes(32, k<sub>2</sub>) || pk''\n+* Return ''(secnonce, pubnonce)''\n+</div>\n+\n+=== Nonce Aggregation ===\n+\n+<div>\n+Algorithm ''NonceAgg(pubnonce<sub>1..u</sub>)'':\n+* Inputs:\n+** The number ''u'' of ''pubnonces'' with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+* For ''j = 1 .. 2'':\n+** For ''i = 1 .. u'':\n+*** Let ''R<sub>i,j</sub> = cpoint(pubnonce<sub>i</sub>[(j-1)*33:j*33])''; fail if that fails and blame signer ''i'' for invalid ''pubnonce''.\n+** Let ''R<sub>j</sub> = R<sub>1,j</sub> + R<sub>2,j</sub> + ... + R<sub>u,j</sub>''\n+* Return ''aggnonce = cbytes_ext(R<sub>1</sub>) || cbytes_ext(R<sub>2</sub>)''\n+</div>\n+\n+=== Session Context ===\n+\n+The Session Context is a data structure consisting of the following elements:\n+* The aggregate public nonce ''aggnonce'': a 66-byte array\n+* The number ''u'' of public keys with ''0 < u < 2^32''\n+* The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+* The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+* The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+* The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+* The message ''m'': a byte array<ref name=\"mlen\" />\n+\n+We write \"Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\" to assign names to the elements of a Session Context.\n+\n+<div>\n+Algorithm ''GetSessionValues(session_ctx)'':\n+* Let ''(aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m) = session_ctx''\n+* Let ''keygen_ctx<sub>0</sub> = KeyAgg(pk<sub>1..u</sub>)''; fail if that fails\n+* For ''i = 1 .. v'':\n+** Let ''keygen_ctx<sub>i</sub> = ApplyTweak(keygen_ctx<sub>i-1</sub>, tweak<sub>i</sub>, is_xonly_t<sub>i</sub>)''; fail if that fails\n+* Let ''(Q, gacc, tacc) = keygen_ctx<sub>v</sub>''\n+* Let ''b = int(hash<sub>MuSig/noncecoef</sub>(aggnonce || xbytes(Q) || m)) mod n''\n+* Let ''R<sub>1</sub> = cpoint_ext(aggnonce[0:33]), R<sub>2</sub> = cpoint_ext(aggnonce[33:66])''; fail if that fails and blame nonce aggregator for invalid ''aggnonce''.\n+* Let ''R' = R<sub>1</sub> + b⋅R<sub>2</sub>''\n+* If ''is_infinite(R'):\n+** Let final nonce ''R = G'' (see [[#dealing-with-infinity-in-nonce-aggregation|Dealing with Infinity in Nonce Aggregation]])\n+* Else:\n+** Let final nonce ''R = R' ''\n+* Let ''e = int(hash<sub>BIP0340/challenge</sub>(xbytes(R) || xbytes(Q) || m)) mod n''\n+* Return ''(Q, gacc, tacc, b, R, e)''\n+</div>\n+\n+<div>\n+Algorithm ''GetSessionKeyAggCoeff(session_ctx, P)'':\n+* Let ''(_, u, pk<sub>1..u</sub>, _, _, _, _) = session_ctx''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk'' not in ''pk<sub>1..u</sub>''\n+* Return ''KeyAggCoeff(pk<sub>1..u</sub>, pk)''\n+</div>\n+\n+=== Signing ===\n+\n+<div>\n+Algorithm ''Sign(secnonce, sk, session_ctx)'':\n+* Inputs:\n+** The secret nonce ''secnonce'' that has never been used as input to ''Sign'' before: a 97-byte array\n+** The secret key ''sk'': a 32-byte array\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''k<sub>1</sub>' = int(secnonce[0:32]), k<sub>2</sub>' = int(secnonce[32:64])''\n+* Fail if ''k<sub>i</sub>' = 0'' or ''k<sub>i</sub>' &ge; n'' for ''i = 1..2''\n+* Let ''k<sub>1</sub> = k<sub>1</sub>', k<sub>2</sub> = k<sub>2</sub>' '' if ''has_even_y(R)'', otherwise let ''k<sub>1</sub> = n - k<sub>1</sub>', k<sub>2</sub> = n - k<sub>2</sub>' ''\n+* Let ''d' = int(sk)''\n+* Fail if ''d' = 0'' or ''d' &ge; n''\n+* Let ''P = d'⋅G''\n+* Let ''pk = cbytes(P)''\n+* Fail if ''pk &ne; secnonce[64:97]''\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"Sign negation\"></div>Let ''d = g⋅gacc⋅d' mod n'' (See [[negation-of-the-secret-key-when-signing|Negation Of The Secret Key When Signing]])\n+* Let ''s = (k<sub>1</sub> + b⋅k<sub>2</sub> + e⋅a⋅d) mod n''\n+* Let ''psig = bytes(32, s)''\n+* Let ''pubnonce = cbytes(k<sub>1</sub>'⋅G) || cbytes(k<sub>2</sub>'⋅G)''\n+* If ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'' (see below) returns failure, abort<ref>Verifying the signature before leaving the signer prevents random or attacker provoked computation errors. This prevents publishing invalid signatures which may leak information about the secret key. It is recommended, but can be omitted if the computation cost is prohibitive.</ref>.\n+* Return partial signature ''psig''\n+</div>\n+\n+=== Partial Signature Verification ===\n+\n+<div>\n+Algorithm ''PartialSigVerify(psig, pubnonce<sub>1..u</sub>, pk<sub>1..u</sub>, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m, i)'':\n+* Inputs:\n+** The partial signature ''psig'': a 32-byte array\n+** The number ''u'' of public nonces and public keys with ''0 < u < 2^32''\n+** The public nonces ''pubnonce<sub>1..u</sub>'': ''u'' 66-byte arrays\n+** The plain public keys ''pk<sub>1..u</sub>'': ''u'' 33-byte arrays\n+** The number ''v'' of tweaks with ''0 &le; v < 2^32''\n+** The tweaks ''tweak<sub>1..v</sub>'': ''v'' 32-byte arrays\n+** The tweak modes ''is_xonly_t<sub>1..v</sub>'' : ''v'' booleans\n+** The message ''m'': a byte array<ref name=\"mlen\" />\n+** The index of the signer ''i'' in the public nonces and public keys with ''0 < i &le; u''\n+* Let ''aggnonce = NonceAgg(pubnonce<sub>1..u</sub>)''; fail if that fails\n+* Let ''session_ctx = (aggnonce, u, pk<sub>1..u</sub>, v, tweak<sub>1..v</sub>, is_xonly_t<sub>1..v</sub>, m)''\n+* Run ''PartialSigVerifyInternal(psig, pubnonce<sub>i</sub>, pk<sub>i</sub>, session_ctx)''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+<div>\n+Internal Algorithm ''PartialSigVerifyInternal(psig, pubnonce, pk, session_ctx)'':\n+* Let ''(Q, gacc, _, b, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* Let ''s = int(psig)''; fail if ''s &ge; n''\n+* Let ''R<sub>⁎,1</sub> = cpoint(pubnonce[0:33]), R<sub>⁎,2</sub> = cpoint(pubnonce[33:66])''\n+* Let ''Re<sub>⁎</sub>' = R<sub>⁎,1</sub> + b⋅R<sub>⁎,2</sub>''\n+* Let effective nonce ''Re<sub>⁎</sub> = Re<sub>⁎</sub>' '' if ''has_even_y(R)'', otherwise let ''Re<sub>⁎</sub> = -Re<sub>⁎</sub>' ''\n+* Let ''P = cpoint(pk)''; fail if that fails\n+* Let ''a = GetSessionKeyAggCoeff(session_ctx, P)''; fail if that fails\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* <div id=\"SigVerify negation\"></div>Let ''g' = g⋅gacc mod n'' (See [[#negation-of-the-public-key-when-partially-verifying|Negation Of The Public Key When Partially Verifying]])\n+* Fail if ''s⋅G &ne; Re<sub>⁎</sub> + e⋅a⋅g'⋅P''\n+* Return success iff no failure occurred before reaching this point.\n+</div>\n+\n+=== Partial Signature Aggregation ===\n+\n+<div>\n+Algorithm ''PartialSigAgg(psig<sub>1..u</sub>, session_ctx)'':\n+* Inputs:\n+** The number ''u'' of signatures with ''0 < u < 2^32''\n+** The partial signatures ''psig<sub>1..u</sub>'': ''u'' 32-byte arrays\n+** The ''session_ctx'': a [[#session-context|Session Context]] data structure\n+* Let ''(Q, _, tacc, _, _, R, e) = GetSessionValues(session_ctx)''; fail if that fails\n+* For ''i = 1 .. u'':\n+** Let ''s<sub>i</sub> = int(psig<sub>i</sub>)''; fail if ''s<sub>i</sub> &ge; n'' and blame signer ''i'' for invalid partial signature.\n+* Let ''g = 1'' if ''has_even_y(Q)'', otherwise let ''g = -1 mod n''\n+* Let ''s = s<sub>1</sub> + ... + s<sub>u</sub> + e⋅g⋅tacc mod n''\n+* Return ''sig = ''xbytes(R) || bytes(32, s)''\n+</div>\n+\n+=== Test Vectors and Reference Code ===\n+\n+We provide a naive, highly inefficient, and non-constant time [[bip-musig2/reference.py|pure Python 3 reference implementation of the key aggregation, partial signing, and partial signature verification algorithms]].\n+\n+Standalone JSON test vectors are also available in the [[bip-musig2|same directory]], to facilitate porting the test vectors into other implementations.\n+\n+The reference implementation is for demonstration purposes only and not to be used in production environments.\n+\n+== Remarks on Security and Correctness ==\n+\n+=== Modifications to Nonce Generation ===\n+\n+Implementers must avoid modifying the ''NonceGen'' algorithm without being fully aware of the implications.\n+\n+One potential pitfall emerges when ''NonceGen'' is altered so the signer's public key ''pk'' is not part of the returned ''secnonce'' array.\n+This specification makes the signer provide ''pk'' at nonce generation time and write ''pk'' into the ''secnonce'' array (and check ''pk'' against ''sk'' in ''Sign'') to ensure that the public key of the signer is determined before sending out the ''pubnonce''.\n+If the public key is not determined before sending out the ''pubnonce'', an adversary can forge a signature by influencing the individual tweak of a victim signer after seeing the ''pubnonce'' (see the [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html bitcoin-dev mailing list post] and [https://github.com/jonasnick/musig2-tweaking writeup] for the details).\n+Thus, implementations must guarantee that the public key of the signer is determined before sending out the ''pubnonce'' if they cannot rule out that the signer's individual key is tweaked (e.g., derived via BIP32) with a tweak known to the adversary (e.g., as in BIP32 unhardened derivation).<ref>The nonce generation algorithm as given in the [https://eprint.iacr.org/2020/1261 MuSig2 paper] does not take ''pk'' as an input (and does not store it in the ''secnonce''). However, the security model considered in the paper does not cover security for signers who tweak their individual keys.</ref>\n+\n+We provide two modifications that are secure when applied correctly and may be useful in special circumstances, summarized in the following table.\n+\n+{| class=\"wikitable\" style=\"margin:auto\"\n+!                   !! needs secure randomness !! needs secure counter !! needs to keep state securely !! needs aggregated nonce of all other signers (only possible for one signer)\n+|-\n+! NonceGen          || ✓      || &nbsp; || ✓      || &nbsp;\n+|-\n+! CounterNonceGen   || &nbsp; || ✓      || ✓      || &nbsp;\n+|-\n+! DeterministicSign || &nbsp; || &nbsp; || &nbsp; || ✓\n+|}\n+\n+First, on systems where obtaining uniformly random values is much harder than maintaining a global atomic counter, it can be beneficial to modify ''NonceGen''.\n+The resulting algorithm ''CounterNonceGen'' does not draw ''rand' '' uniformly at random but instead sets ''rand' '' to the value of an atomic counter that is incremented whenever it is read.\n+With this modification, the secret signing key ''sk'' of the signer generating the nonce is '''not''' an optional argument and must be provided to ''NonceGen''.\n+The security of the resulting scheme is then depending on the requirement that reading the counter must never yield the same counter value in two ''NonceGen'' invocations with the same ''sk''.\n+\n+Second, if there is a unique signer who is supposed to send the ''pubnonce'' last, it is possible to modify nonce generation for this single signer to not require high-quality randomness.\n+Such a nonce generation algorithm ''DeterministicSign'' is specified below.\n+Note that the only optional argument is ''rand'', which can be omitted if randomness is entirely unavailable.",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 547,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "e615cea4a3a3504967c210559c59efcfd39cf1ba",
      "in_reply_to_id": 1028573847,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sure. If I have 2 copies of my secret key in separate physical locations, I may have cause to generate a nonce when near one copy, but create my partial signature when near the other copy. In that case I have no mechanism to ensure against nonce reuse unless I use 2-stage `DeterministicSign` (as [described](https://github.com/bitcoin/bips/pull/1372#discussion_r1036053753) by Jonas).",
      "created_at": "2023-01-05T18:02:05Z",
      "updated_at": "2023-01-05T18:02:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1062747976",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1062747976"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 597,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1148456620",
      "pull_request_review_id": 1357922649,
      "id": 1148456620,
      "node_id": "PRRC_kwDOAN28mc5EdA6s",
      "diff_hunk": "@@ -0,0 +1,824 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 3,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "4d996ec7c15315157f3c206c0c11c228c93272fb",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Something more here might be nice",
      "created_at": "2023-03-26T00:59:38Z",
      "updated_at": "2023-03-26T00:59:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1148456620",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1148456620"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1148465440",
      "pull_request_review_id": 1357930083,
      "id": 1148465440,
      "node_id": "PRRC_kwDOAN28mc5EdDEg",
      "diff_hunk": "@@ -0,0 +1,824 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 3,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "4d996ec7c15315157f3c206c0c11c228c93272fb",
      "in_reply_to_id": 1148456620,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just clarifying: You're saying that the title could be more elaborate?",
      "created_at": "2023-03-26T02:49:24Z",
      "updated_at": "2023-03-26T02:49:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1148465440",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1148465440"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1148572957",
      "pull_request_review_id": 1358040498,
      "id": 1148572957,
      "node_id": "PRRC_kwDOAN28mc5EddUd",
      "diff_hunk": "@@ -0,0 +1,824 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 3,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "4d996ec7c15315157f3c206c0c11c228c93272fb",
      "in_reply_to_id": 1148456620,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, with just this, nobody knows what it is",
      "created_at": "2023-03-26T14:52:08Z",
      "updated_at": "2023-03-26T14:52:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1148572957",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1148572957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1148734481",
      "pull_request_review_id": 1358249823,
      "id": 1148734481,
      "node_id": "PRRC_kwDOAN28mc5EeEwR",
      "diff_hunk": "@@ -0,0 +1,824 @@\n+<pre>\n+  BIP: ?\n+  Title: MuSig2",
      "path": "bip-musig2.mediawiki",
      "position": null,
      "original_position": 3,
      "commit_id": "87394eaeb436d02e0a68b38a1e94bc526d50056e",
      "original_commit_id": "4d996ec7c15315157f3c206c0c11c228c93272fb",
      "in_reply_to_id": 1148456620,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "updated",
      "created_at": "2023-03-27T02:50:11Z",
      "updated_at": "2023-03-27T02:50:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1372#discussion_r1148734481",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1148734481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1372"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 3,
      "side": "RIGHT"
    }
  ]
}