{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1003",
    "id": 496048873,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NDk2MDQ4ODcz",
    "html_url": "https://github.com/bitcoin/bips/pull/1003",
    "diff_url": "https://github.com/bitcoin/bips/pull/1003.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1003.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1003/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/75ec9631effc524364cded5c3eff02e4e27ebf9c",
    "number": 1003,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "BIP-322: switch to using tx based approach",
    "user": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It seems more people are leaning towards this being an update to BIP-322 over a new BIP, so I am swapping this to being an update instead of a new BIP.\r\n\r\nI am not sure if I like the legacy format compatibility, but people asked for it elsewhere, so I'm keeping it for now.",
    "labels": [],
    "created_at": "2020-10-01T07:54:36Z",
    "updated_at": "2023-04-02T09:11:36Z",
    "closed_at": "2020-10-24T13:18:21Z",
    "mergeable_state": "unknown",
    "merged_at": "2020-10-24T13:18:21Z",
    "merge_commit_sha": "7e3284dafda168da34888977dbf4a55519b0c54d",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "kallewoof:202010-signmsg",
      "ref": "202010-signmsg",
      "sha": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 86265104,
        "node_id": "MDEwOlJlcG9zaXRvcnk4NjI2NTEwNA==",
        "name": "bips",
        "full_name": "kallewoof/bips",
        "owner": {
          "login": "kallewoof",
          "id": 250224,
          "node_id": "MDQ6VXNlcjI1MDIyNA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/kallewoof",
          "html_url": "https://github.com/kallewoof",
          "followers_url": "https://api.github.com/users/kallewoof/followers",
          "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
          "organizations_url": "https://api.github.com/users/kallewoof/orgs",
          "repos_url": "https://api.github.com/users/kallewoof/repos",
          "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/kallewoof/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/kallewoof/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/kallewoof/bips",
        "archive_url": "https://api.github.com/repos/kallewoof/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/kallewoof/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/kallewoof/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/kallewoof/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/kallewoof/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/kallewoof/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/kallewoof/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/kallewoof/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/kallewoof/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/kallewoof/bips/contributors",
        "deployments_url": "https://api.github.com/repos/kallewoof/bips/deployments",
        "downloads_url": "https://api.github.com/repos/kallewoof/bips/downloads",
        "events_url": "https://api.github.com/repos/kallewoof/bips/events",
        "forks_url": "https://api.github.com/repos/kallewoof/bips/forks",
        "git_commits_url": "https://api.github.com/repos/kallewoof/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/kallewoof/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/kallewoof/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/kallewoof/bips.git",
        "issue_comment_url": "https://api.github.com/repos/kallewoof/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/kallewoof/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/kallewoof/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/kallewoof/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/kallewoof/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/kallewoof/bips/languages",
        "merges_url": "https://api.github.com/repos/kallewoof/bips/merges",
        "milestones_url": "https://api.github.com/repos/kallewoof/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/kallewoof/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/kallewoof/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/kallewoof/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:kallewoof/bips.git",
        "stargazers_url": "https://api.github.com/repos/kallewoof/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/kallewoof/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/kallewoof/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/kallewoof/bips/subscription",
        "tags_url": "https://api.github.com/repos/kallewoof/bips/tags",
        "teams_url": "https://api.github.com/repos/kallewoof/bips/teams",
        "trees_url": "https://api.github.com/repos/kallewoof/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/kallewoof/bips.git",
        "hooks_url": "https://api.github.com/repos/kallewoof/bips/hooks",
        "svn_url": "https://github.com/kallewoof/bips",
        "homepage": "bitcoin.org",
        "language": "Wikitext",
        "forks_count": 2,
        "stargazers_count": 2,
        "watchers_count": 2,
        "size": 13798,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-03-09T02:57:26Z",
        "created_at": "2017-03-26T21:09:34Z",
        "updated_at": "2023-03-11T09:18:52Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "f7ea92c02bf879d264ea9f5f465f0abd617a6c7b",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5535,
        "stargazers_count": 8220,
        "watchers_count": 8220,
        "size": 13787,
        "default_branch": "master",
        "open_issues_count": 112,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-01T12:09:15Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-08-01T09:08:43Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 59,
    "deletions": 137,
    "changed_files": 1,
    "commits": 1,
    "review_comments": 57,
    "comments": 36
  },
  "events": [
    {
      "event": "commented",
      "id": 701961124,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMTk2MTEyNA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/701961124",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-01T07:57:07Z",
      "updated_at": "2020-10-01T07:57:07Z",
      "author_association": "MEMBER",
      "body": "No idea what's up with Travis.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-701961124",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3828083005,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgyODA4MzAwNQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3828083005",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-01T08:01:26Z"
    },
    {
      "event": "reviewed",
      "id": 500101465,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMTAxNDY1",
      "url": null,
      "actor": null,
      "commit_id": "fc7479dffabb597ea3e15edaf56b51d278994753",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-500101465",
      "submitted_at": "2020-10-01T08:06:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3828237822,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgyODIzNzgyMg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3828237822",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-01T08:35:32Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3828241588,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgyODI0MTU4OA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3828241588",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-01T08:36:21Z"
    },
    {
      "event": "commented",
      "id": 702127909,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMjEyNzkwOQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/702127909",
      "actor": {
        "login": "stepansnigirev",
        "id": 1706012,
        "node_id": "MDQ6VXNlcjE3MDYwMTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1706012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stepansnigirev",
        "html_url": "https://github.com/stepansnigirev",
        "followers_url": "https://api.github.com/users/stepansnigirev/followers",
        "following_url": "https://api.github.com/users/stepansnigirev/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stepansnigirev/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stepansnigirev/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stepansnigirev/subscriptions",
        "organizations_url": "https://api.github.com/users/stepansnigirev/orgs",
        "repos_url": "https://api.github.com/users/stepansnigirev/repos",
        "events_url": "https://api.github.com/users/stepansnigirev/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stepansnigirev/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-01T13:17:25Z",
      "updated_at": "2020-10-01T13:17:25Z",
      "author_association": "CONTRIBUTOR",
      "body": "Regarding compatibility with legacy message signing,\r\nI think at the moment when you are signing messages with any wallet it calculates the hash in the following way:\r\n`SHA256d(0x18 || \"Bitcoin Signed Message:\\n\" || compactint(len(m)) || m)` where 0x18 is the length of the magic prefix.\r\nSo digest for the message `Hello` will be:\r\n`SHA256d(0x18 || \"Bitcoin Signed Message:\\n\" || 0x05 || \"Hello\")`\r\n\r\nIf this digest is used for legacy p2pkh signing I think it will be easier to integrate this BIP because it will be 100% backward compatible with currently used message signing.",
      "user": {
        "login": "stepansnigirev",
        "id": 1706012,
        "node_id": "MDQ6VXNlcjE3MDYwMTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1706012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stepansnigirev",
        "html_url": "https://github.com/stepansnigirev",
        "followers_url": "https://api.github.com/users/stepansnigirev/followers",
        "following_url": "https://api.github.com/users/stepansnigirev/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stepansnigirev/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stepansnigirev/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stepansnigirev/subscriptions",
        "organizations_url": "https://api.github.com/users/stepansnigirev/orgs",
        "repos_url": "https://api.github.com/users/stepansnigirev/repos",
        "events_url": "https://api.github.com/users/stepansnigirev/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stepansnigirev/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-702127909",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 702502091,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMjUwMjA5MQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/702502091",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-02T03:06:18Z",
      "updated_at": "2020-10-02T03:06:18Z",
      "author_association": "MEMBER",
      "body": "@stepansnigirev So the current approach is that people may use the legacy signing if they want to, in which case they will do exactly the same way (including digest derivation). If they don't, then the thing won't be backwards compatible anyway, even if we reuse the same digest derivation method. Or am I misunderstanding you?",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-702502091",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "mentioned",
      "id": 3832194091,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzgzMjE5NDA5MQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3832194091",
      "actor": {
        "login": "stepansnigirev",
        "id": 1706012,
        "node_id": "MDQ6VXNlcjE3MDYwMTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1706012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stepansnigirev",
        "html_url": "https://github.com/stepansnigirev",
        "followers_url": "https://api.github.com/users/stepansnigirev/followers",
        "following_url": "https://api.github.com/users/stepansnigirev/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stepansnigirev/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stepansnigirev/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stepansnigirev/subscriptions",
        "organizations_url": "https://api.github.com/users/stepansnigirev/orgs",
        "repos_url": "https://api.github.com/users/stepansnigirev/repos",
        "events_url": "https://api.github.com/users/stepansnigirev/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stepansnigirev/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-02T03:06:18Z"
    },
    {
      "event": "subscribed",
      "id": 3832194093,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM4MzIxOTQwOTM=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3832194093",
      "actor": {
        "login": "stepansnigirev",
        "id": 1706012,
        "node_id": "MDQ6VXNlcjE3MDYwMTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1706012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stepansnigirev",
        "html_url": "https://github.com/stepansnigirev",
        "followers_url": "https://api.github.com/users/stepansnigirev/followers",
        "following_url": "https://api.github.com/users/stepansnigirev/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stepansnigirev/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stepansnigirev/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stepansnigirev/subscriptions",
        "organizations_url": "https://api.github.com/users/stepansnigirev/orgs",
        "repos_url": "https://api.github.com/users/stepansnigirev/repos",
        "events_url": "https://api.github.com/users/stepansnigirev/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stepansnigirev/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-02T03:06:18Z"
    },
    {
      "event": "commented",
      "id": 702538850,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMjUzODg1MA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/702538850",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-02T05:50:34Z",
      "updated_at": "2020-10-02T05:50:34Z",
      "author_association": "MEMBER",
      "body": "Pushed a to-squash that overwrites BIP-322 instead of making this a new BIP. Will drop or squash once decided.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-702538850",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3832461246,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzMjQ2MTI0Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3832461246",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-02T05:52:57Z"
    },
    {
      "event": "commented",
      "id": 702973096,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMjk3MzA5Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/702973096",
      "actor": {
        "login": "stepansnigirev",
        "id": 1706012,
        "node_id": "MDQ6VXNlcjE3MDYwMTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1706012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stepansnigirev",
        "html_url": "https://github.com/stepansnigirev",
        "followers_url": "https://api.github.com/users/stepansnigirev/followers",
        "following_url": "https://api.github.com/users/stepansnigirev/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stepansnigirev/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stepansnigirev/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stepansnigirev/subscriptions",
        "organizations_url": "https://api.github.com/users/stepansnigirev/orgs",
        "repos_url": "https://api.github.com/users/stepansnigirev/repos",
        "events_url": "https://api.github.com/users/stepansnigirev/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stepansnigirev/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-02T21:51:01Z",
      "updated_at": "2020-10-02T21:51:01Z",
      "author_association": "CONTRIBUTOR",
      "body": "> So the current approach is that people may use the legacy signing if they want to, in which case they will do exactly the same way (including digest derivation). If they don't, then the thing won't be backwards compatible anyway, even if we reuse the same digest derivation method. Or am I misunderstanding you?\r\n\r\nI think it's ok to have a different digest (tagged hash) for the new message signing, I am just saying that **legacy** message signing is described in the document a bit unclear (I think). \r\n\r\nDoes this: `SHA56d(\"Bitcoin Signed Message:\\n\"||m)` mean I need to simply concatenate magic and the message, or do I need to prepend it with it's length?\r\n\r\nI was not able to find any documentation for legacy signing standard so I had to look up in the code of the wallets:\r\n\r\nBitcoin Core: https://github.com/bitcoin/bitcoin/blob/a12d9e5fd24a25bef476c10620317e43a5905754/src/util/message.cpp#L75\r\n\r\nElectrum: https://github.com/spesmilo/electrum/blob/9c5e49f432a4310aa4aec2f7985b52f032210b7e/electrum/ecc.py#L355-L358\r\n\r\nBitcoinlib:\r\nhttps://github.com/petertodd/python-bitcoinlib/blob/master/bitcoin/signmessage.py#L48-L63\r\n\r\nI am not 100% sure but it looks like the magic and the message are serialized with their lengths.\r\nIt would be nice to make this a bit more clear in the bip.\r\n\r\nRegarding the new standard to sign messages - I really like it.",
      "user": {
        "login": "stepansnigirev",
        "id": 1706012,
        "node_id": "MDQ6VXNlcjE3MDYwMTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1706012?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stepansnigirev",
        "html_url": "https://github.com/stepansnigirev",
        "followers_url": "https://api.github.com/users/stepansnigirev/followers",
        "following_url": "https://api.github.com/users/stepansnigirev/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stepansnigirev/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stepansnigirev/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stepansnigirev/subscriptions",
        "organizations_url": "https://api.github.com/users/stepansnigirev/orgs",
        "repos_url": "https://api.github.com/users/stepansnigirev/repos",
        "events_url": "https://api.github.com/users/stepansnigirev/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stepansnigirev/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-702973096",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 703025553,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzAyNTU1Mw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703025553",
      "actor": {
        "login": "ChristopherA",
        "id": 69103,
        "node_id": "MDQ6VXNlcjY5MTAz",
        "avatar_url": "https://avatars.githubusercontent.com/u/69103?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ChristopherA",
        "html_url": "https://github.com/ChristopherA",
        "followers_url": "https://api.github.com/users/ChristopherA/followers",
        "following_url": "https://api.github.com/users/ChristopherA/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ChristopherA/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ChristopherA/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ChristopherA/subscriptions",
        "organizations_url": "https://api.github.com/users/ChristopherA/orgs",
        "repos_url": "https://api.github.com/users/ChristopherA/repos",
        "events_url": "https://api.github.com/users/ChristopherA/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ChristopherA/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-03T01:41:46Z",
      "updated_at": "2020-10-03T01:41:46Z",
      "author_association": "NONE",
      "body": "Concept ACK: @BlockchainCommons and a number of our patrons are very interested in supporting new message signing approach. ",
      "user": {
        "login": "ChristopherA",
        "id": 69103,
        "node_id": "MDQ6VXNlcjY5MTAz",
        "avatar_url": "https://avatars.githubusercontent.com/u/69103?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ChristopherA",
        "html_url": "https://github.com/ChristopherA",
        "followers_url": "https://api.github.com/users/ChristopherA/followers",
        "following_url": "https://api.github.com/users/ChristopherA/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ChristopherA/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ChristopherA/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ChristopherA/subscriptions",
        "organizations_url": "https://api.github.com/users/ChristopherA/orgs",
        "repos_url": "https://api.github.com/users/ChristopherA/repos",
        "events_url": "https://api.github.com/users/ChristopherA/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ChristopherA/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703025553",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "mentioned",
      "id": 3836096343,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzgzNjA5NjM0Mw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3836096343",
      "actor": {
        "login": "BlockchainCommons",
        "id": 38142380,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjM4MTQyMzgw",
        "avatar_url": "https://avatars.githubusercontent.com/u/38142380?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/BlockchainCommons",
        "html_url": "https://github.com/BlockchainCommons",
        "followers_url": "https://api.github.com/users/BlockchainCommons/followers",
        "following_url": "https://api.github.com/users/BlockchainCommons/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/BlockchainCommons/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/BlockchainCommons/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/BlockchainCommons/subscriptions",
        "organizations_url": "https://api.github.com/users/BlockchainCommons/orgs",
        "repos_url": "https://api.github.com/users/BlockchainCommons/repos",
        "events_url": "https://api.github.com/users/BlockchainCommons/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/BlockchainCommons/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-03T01:41:47Z"
    },
    {
      "event": "commented",
      "id": 703054906,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzA1NDkwNg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703054906",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-03T06:25:04Z",
      "updated_at": "2020-10-03T06:25:04Z",
      "author_association": "MEMBER",
      "body": "> I think it's ok to have a different digest (tagged hash) for the new message signing, I am just saying that legacy message signing is described in the document a bit unclear (I think).\r\n\r\nOH! That is definitely an error on my end. I'll fix the legacy description.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703054906",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3836282822,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzNjI4MjgyMg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3836282822",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-03T06:33:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3836285718,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzNjI4NTcxOA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3836285718",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-03T06:37:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3836289872,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzNjI4OTg3Mg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3836289872",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-03T06:43:36Z"
    },
    {
      "event": "commented",
      "id": 703056658,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzA1NjY1OA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703056658",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-03T06:44:11Z",
      "updated_at": "2020-10-03T06:44:30Z",
      "author_association": "MEMBER",
      "body": "Dropped 992c5e3 tentatively. Will cherry-pick if we decide this should replace BIP322 after all.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703056658",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "reviewed",
      "id": 501544541,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTQ0NTQx",
      "url": null,
      "actor": null,
      "commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-501544541",
      "submitted_at": "2020-10-03T13:00:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "reviewed",
      "id": 501544633,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTQ0NjMz",
      "url": null,
      "actor": null,
      "commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-501544633",
      "submitted_at": "2020-10-03T13:02:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "reviewed",
      "id": 501545700,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTQ1NzAw",
      "url": null,
      "actor": null,
      "commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-501545700",
      "submitted_at": "2020-10-03T13:21:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "reviewed",
      "id": 501546086,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTQ2MDg2",
      "url": null,
      "actor": null,
      "commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-501546086",
      "submitted_at": "2020-10-03T13:27:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3838474329,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzODQ3NDMyOQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3838474329",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T04:44:52Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3838949725,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzODk0OTcyNQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3838949725",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T07:30:12Z"
    },
    {
      "event": "reviewed",
      "id": 501824921,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODI0OTIx",
      "url": null,
      "actor": null,
      "commit_id": "aa6ceaf8c0f5ebbd164f8e292d8b465aeba80e54",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-501824921",
      "submitted_at": "2020-10-05T08:25:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3839383996,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzOTM4Mzk5Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3839383996",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T09:10:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3839407402,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzOTQwNzQwMg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3839407402",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T09:15:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3839416691,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzOTQxNjY5MQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3839416691",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T09:17:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3839418244,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzgzOTQxODI0NA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3839418244",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T09:17:47Z"
    },
    {
      "event": "reviewed",
      "id": 501869354,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODY5MzU0",
      "url": null,
      "actor": null,
      "commit_id": "2a8b599e32c2dcce6dfa9f965365cc383ce08ee9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-501869354",
      "submitted_at": "2020-10-05T15:37:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "commented",
      "id": 703771311,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzc3MTMxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703771311",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T17:19:38Z",
      "updated_at": "2020-10-05T17:19:38Z",
      "author_association": "MEMBER",
      "body": "This seems like it should just be a revision to BIP 322?\r\n\r\nP.S. I still think this whole concept is misguided since it doesn't address the conceptual problems with legacy signmessage.",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703771311",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 703905342,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzkwNTM0Mg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703905342",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T21:42:59Z",
      "updated_at": "2020-10-05T21:42:59Z",
      "author_association": "MEMBER",
      "body": "> This seems like it should just be a revision to BIP 322?\r\n\r\nPeople seem to have differing opinions, but I am inclined to agree with you.\r\n\r\n> P.S. I still think this whole concept is misguided since it doesn't address the conceptual problems with legacy signmessage.\r\n\r\nYeah, I know. I haven't seen any concrete suggestions on how to make it to your liking, though. My channels are open, as the Lightning folks would say..",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703905342",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3842574010,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0MjU3NDAxMA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842574010",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T21:51:35Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3842575317,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0MjU3NTMxNw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842575317",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T21:52:02Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T21:56:54Z",
      "updated_at": "2020-10-05T21:56:54Z",
      "source": {
        "issue": {
          "id": 715189224,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NDk4MTQwNTAy",
          "url": "https://api.github.com/repos/bitcoin/bips/issues/1005",
          "repository_url": "https://api.github.com/repos/bitcoin/bips",
          "labels_url": "https://api.github.com/repos/bitcoin/bips/issues/1005/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1005/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bips/issues/1005/events",
          "html_url": "https://github.com/bitcoin/bips/pull/1005",
          "number": 1005,
          "state": "closed",
          "state_reason": null,
          "title": "bip-325: correct placement of challenge",
          "body": "In https://github.com/bitcoin/bips/pull/1003#discussion_r499466365 (where I adopt the approach here), it is pointed out that the message signature going into the scriptPubKey of the spending transaction is weird.\r\n\r\nIt should go into the scriptSig and/or scriptWitness, and the scriptPubKey for the spending tx is OP_RETURN.",
          "user": {
            "login": "kallewoof",
            "id": 250224,
            "node_id": "MDQ6VXNlcjI1MDIyNA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kallewoof",
            "html_url": "https://github.com/kallewoof",
            "followers_url": "https://api.github.com/users/kallewoof/followers",
            "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
            "organizations_url": "https://api.github.com/users/kallewoof/orgs",
            "repos_url": "https://api.github.com/users/kallewoof/repos",
            "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/kallewoof/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 3,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bips/pulls/1005",
            "html_url": "https://github.com/bitcoin/bips/pull/1005",
            "diff_url": "https://github.com/bitcoin/bips/pull/1005.diff",
            "patch_url": "https://github.com/bitcoin/bips/pull/1005.patch"
          },
          "closed_at": "2020-10-08T04:33:02Z",
          "created_at": "2020-10-05T21:56:54Z",
          "updated_at": "2020-10-08T04:33:02Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "renamed",
      "id": 3842605344,
      "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50Mzg0MjYwNTM0NA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842605344",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T22:02:44Z",
      "rename": {
        "from": "BIP: signmessage (replaces BIP-322)",
        "to": "BIP-322: switch to using tx based approach"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3842617760,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0MjYxNzc2MA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842617760",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T22:06:57Z"
    },
    {
      "event": "commented",
      "id": 703929675,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzkyOTY3NQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703929675",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T22:47:58Z",
      "updated_at": "2020-10-05T22:47:58Z",
      "author_association": "MEMBER",
      "body": "@kallewoof Something like this https://dpaste.com/5P6QXZGD7",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703929675",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "mentioned",
      "id": 3842722437,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mzg0MjcyMjQzNw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842722437",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T22:47:58Z"
    },
    {
      "event": "subscribed",
      "id": 3842722439,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM4NDI3MjI0Mzk=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842722439",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-05T22:47:58Z"
    },
    {
      "event": "commented",
      "id": 703960511,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzk2MDUxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703960511",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T00:30:48Z",
      "updated_at": "2020-10-06T00:30:48Z",
      "author_association": "MEMBER",
      "body": "@luke-jr Going through your diff and commenting on stuff:\r\n\r\n1. I added the background because people actually had no idea what this thing was supposed to be doing. Not sure removing it is the right approach.\r\n2. I like/agree with the clarifications in the motivation; adopting. I will also adopt the \"invoice address\" terminology.\r\n3. Requiring message_challenge to be `OP_TRUE` for proof of funds is a good idea, yep. They're proving by signing the inputs after all, as long as the signatures are actually committing to the bip-322 input (is this guaranteed?).\r\n4. Isn't this \"additional inputs should be included\"? `+When a proof of funds is being created, additional outputs should be included for virtually spending transaction outputs of desired value.`\r\n5. I don't like having all the deterministic cruft in the virtual transactions be embedded in the proof, but you're right that in its current form, the proof of funds aspect is not fully covered. What if the proof is the message signature followed by an optional transaction which adds proof of fund inputs? If present, the virtual to_sign transaction uses that transaction as its base and appends the to_spend vin (no need for the OP_RETURN output since there are 1+ outputs already).\r\n6. I'm totally cool with the rest, e.g. Policy -> Upgradable.\r\n\r\nPushing a to-squash for comparison.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703960511",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "mentioned",
      "id": 3842939923,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mzg0MjkzOTkyMw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842939923",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T00:30:48Z"
    },
    {
      "event": "subscribed",
      "id": 3842939926,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM4NDI5Mzk5MjY=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842939926",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T00:30:48Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3842945625,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0Mjk0NTYyNQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842945625",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T00:33:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3842949216,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0Mjk0OTIxNg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842949216",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T00:35:43Z"
    },
    {
      "event": "commented",
      "id": 703963507,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzk2MzUwNw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703963507",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T00:41:54Z",
      "updated_at": "2020-10-06T00:41:54Z",
      "author_association": "MEMBER",
      "body": "I removed the background because it was wrong and I didn't see an obvious way to fix it. Current signed messages don't prove you have the private key.\r\n\r\nI don't care strongly how the signatures are serialised, but I don't think more than two elements (message+signature) should be required. Any other serialisation I could think of quickly, however, seemed to increase complexity excessively.",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703963507",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 703963956,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzk2Mzk1Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703963956",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T00:43:31Z",
      "updated_at": "2020-10-06T00:43:31Z",
      "author_association": "MEMBER",
      "body": "Oh, and note that serialising the entire transactions leaves a lot of room for future extension... Minimising it might not.",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703963956",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3842997701,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0Mjk5NzcwMQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842997701",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:01:11Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3842998886,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0Mjk5ODg4Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3842998886",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:01:46Z"
    },
    {
      "event": "commented",
      "id": 703969041,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzk2OTA0MQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703969041",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:02:27Z",
      "updated_at": "2020-10-06T01:02:27Z",
      "author_association": "MEMBER",
      "body": "Serializing the entire thing means you need to do that extra step as the verifier to ensure it actually contains the necessary stuff, but it seems like it's probably worth it.\r\n\r\nI have removed the Background for now.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703969041",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3843004215,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0MzAwNDIxNQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3843004215",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:04:21Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3843009324,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0MzAwOTMyNA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3843009324",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:07:13Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3843021031,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0MzAyMTAzMQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3843021031",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:13:02Z"
    },
    {
      "event": "commented",
      "id": 703972020,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwMzk3MjAyMA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/703972020",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:13:54Z",
      "updated_at": "2020-10-06T01:13:54Z",
      "author_association": "MEMBER",
      "body": "With everything included, there are several foot-gun points, so I clarified what validators need to check, beyond the actual tx validation.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-703972020",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3843028425,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0MzAyODQyNQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3843028425",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:16:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3843042119,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0MzA0MjExOQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3843042119",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-06T01:23:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3848583455,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg0ODU4MzQ1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3848583455",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-07T05:15:30Z"
    },
    {
      "event": "commented",
      "id": 704704397,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwNDcwNDM5Nw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/704704397",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-07T05:36:58Z",
      "updated_at": "2020-10-07T05:36:58Z",
      "author_association": "MEMBER",
      "body": "Note: a discussion on how to handle OP_CLTV/CSV was made on IRC, resulting in a pushed additional section and two added outcomes (`valid_in_future` and `inconclusive_in_future`).\r\n\r\nThere are some parts that may need discussion, in particular:\r\n1. What to do when a CLTV/CSV is encountered in the `to_spend` transaction.\r\n2. What to do when a CLTV/CSV is encountered in one of the proof-of-fund inputs.\r\n3. Whether 1 and 2 above should be considered equivalent or not.\r\n\r\nRight now,\r\n1. Unconditionally set \"in_future\" flag (valid becomes valid_in_future; inconclusive becomes inconclusive_in_future).\r\n2. If the CLTV/CSV condition(s) are not met, set the \"in_future\" flag.\r\n3. Equivalent.\r\n",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-704704397",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 708936884,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwODkzNjg4NA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/708936884",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-15T06:44:56Z",
      "updated_at": "2020-10-15T06:44:56Z",
      "author_association": "MEMBER",
      "body": "@luke-jr I think this is mergeable, but would like if you took a last look at the latest addition (CSV/CLTV).",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-708936884",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "mentioned",
      "id": 3879843553,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mzg3OTg0MzU1Mw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3879843553",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-15T06:44:57Z"
    },
    {
      "event": "subscribed",
      "id": 3879843559,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM4Nzk4NDM1NTk=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3879843559",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-15T06:44:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3880026456,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4MDAyNjQ1Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3880026456",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-15T07:35:47Z"
    },
    {
      "event": "commented",
      "id": 708961871,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwODk2MTg3MQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/708961871",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-15T07:36:29Z",
      "updated_at": "2020-10-15T13:43:38Z",
      "author_association": "MEMBER",
      "body": "~Pushed a change to the `to_spend` transaction: the first output's nValue was originally set to 0, but is now set to the sum of all inputs (which is zero when no additional inputs exist).~",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-708961871",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-15T12:48:54Z",
      "updated_at": "2020-10-15T12:48:54Z",
      "source": {
        "issue": {
          "id": 722304650,
          "node_id": "MDExOlB1bGxSZXF1ZXN0NTA0MDc4MDAw",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20154",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20154/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20154/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20154/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/20154",
          "number": 20154,
          "state": "closed",
          "state_reason": null,
          "title": "BIP-322 support",
          "body": "This is my WIP on BIP 322 support. It is based on the updated BIP which significantly changes how message signing is done.\r\n",
          "user": {
            "login": "kallewoof",
            "id": 250224,
            "node_id": "MDQ6VXNlcjI1MDIyNA==",
            "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/kallewoof",
            "html_url": "https://github.com/kallewoof",
            "followers_url": "https://api.github.com/users/kallewoof/followers",
            "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
            "organizations_url": "https://api.github.com/users/kallewoof/orgs",
            "repos_url": "https://api.github.com/users/kallewoof/repos",
            "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/kallewoof/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 135946,
              "node_id": "MDU6TGFiZWwxMzU5NDY=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/GUI",
              "name": "GUI",
              "color": "02d7e1",
              "default": false
            },
            {
              "id": 149424,
              "node_id": "MDU6TGFiZWwxNDk0MjQ=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Wallet",
              "name": "Wallet",
              "color": "08a781",
              "default": false
            },
            {
              "id": 98279177,
              "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
              "name": "RPC/REST/ZMQ",
              "color": "0052cc",
              "default": false
            },
            {
              "id": 241832923,
              "node_id": "MDU6TGFiZWwyNDE4MzI5MjM=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Utils/log/libs",
              "name": "Utils/log/libs",
              "description": "",
              "color": "5319e7",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": true,
          "active_lock_reason": "resolved",
          "comments": 2,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20154",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/20154",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/20154.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/20154.patch"
          },
          "closed_at": "2020-12-29T06:17:00Z",
          "created_at": "2020-10-15T12:48:53Z",
          "updated_at": "2022-02-15T11:01:29Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3881435353,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4MTQzNTM1Mw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3881435353",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-15T13:02:13Z"
    },
    {
      "event": "commented",
      "id": 709389654,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTM4OTY1NA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709389654",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-15T15:07:05Z",
      "updated_at": "2020-10-15T18:30:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "To determine if 'in the future' flag should be present will require knowledge of whether CLTV/CSV opcodes will actually be executed in the script given particular witness data.\r\n\r\nExecuting the script with CLTV/CSV will require the to_sign transaction to have locktime / sequence to be set accordingly, and the signature would need to be made over the transaction with these fields set.\r\n\r\nChecking that CLTV/CSV was actually executed would require additional instrumentation of the interpreter, or running the interpreter two times for each opcode: first with transaction locktime / sequence set for CLTV/CSV to be always successful, and then to always fail (and also likely to need distinct signatures for each variant).\r\n\r\nI doubt that handling CLTV/CSV is needed at all for the simple \"signature for the address\" case. Just say that if your script has these opcodes, you should use \"proof of funds\" feature.\r\n\r\nThe \"need to set relevant tx fields in to_sign\" issue is still there for \"proof of funds\" case, so I think it should be specified how checking \"the CLTV and/or CSV conditions are not yet met\" means that nLockTime on to_sign transaction has to be set for CLTV and that \"proof of funds\" UTXOs should specify correct sequences.",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709389654",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3884707534,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NDcwNzUzNA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3884707534",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T06:06:29Z"
    },
    {
      "event": "commented",
      "id": 709820486,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTgyMDQ4Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709820486",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T06:07:50Z",
      "updated_at": "2020-10-16T06:07:50Z",
      "author_association": "MEMBER",
      "body": "Writing code for this, I realize it's really foot-gunnery, so I added a validation section specifying what a validator must do.\r\n\r\n@dgpv Fair points. What if the wording was changed to say the in_future part is optional? I.e. the verifier *may* check if there is a time lock encumbrance, and if it does, it may reflect this using the in_future flag. Would love to hear Murch's thoughts as he brought this up initially.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709820486",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "mentioned",
      "id": 3884711246,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50Mzg4NDcxMTI0Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3884711246",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T06:07:50Z"
    },
    {
      "event": "subscribed",
      "id": 3884711250,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM4ODQ3MTEyNTA=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3884711250",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T06:07:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3884717863,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NDcxNzg2Mw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3884717863",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T06:10:10Z"
    },
    {
      "event": "commented",
      "id": 709849852,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTg0OTg1Mg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709849852",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T06:46:18Z",
      "updated_at": "2020-10-16T06:50:15Z",
      "author_association": "CONTRIBUTOR",
      "body": "> What if the wording was changed to say the in_future part is optional?\r\n\r\nEven if it is optional, it still have to be specified.\r\n\r\nFor example, current spec says `nLockTime = 0` on `to_sign` transaction, but for proof-of-funds when scripts has CLTV, `nLockTime` has to be set accordingly. For the spec to be consistent, it has to account for this.\r\n\r\nIt seems that the prover need to to set certain transaction fields on `to_sign` and Validator has to check them (is nLockTime in the future according to current chain ?)\r\n\r\nFor \"signature for the address\" case, if the verifier chooses to support the `in_future` flag, the prover has to set `nLockTime`/`nSequence` fields on `to_sign` before signing, and the verifier needs to set them to the same values, and these values need to be communicated. Of course they can be communicated as a full transaction, and then verifier would need to validate the transaction to check that other fields are as written in the spec. It seems as in this case the complexity gets closer to the 'proof of funds' case, and also the data to be exchanged is the same (except the `to_sign` transaction passed from prover to verifier does not contain real inputs).\r\n\r\nIt seems to me that it is easier to introduce a degenerate 'no inputs' proof-of-funds case where prover passes the signed transaction to the verifier, and the verifier validates and then verifies.\r\n\r\nThe simple \"signature for the address\" case then becomes a further simplified case where the `to_sign` transaction is static.\r\n\r\nLooks like there are three cases:\r\n\r\n1) The full \"proof of funds\": multiple dynamic `to_spend` (taken from blockchain) and a dynamic `to_sign` (provided by the prover)\r\n\r\n2) The complex case of \"signature for the address\": single static `to_spend` and a dynamic `to_sign` (provided by the prover)\r\n\r\n3) The simple case of \"signature for the address\": single static `to_spend` and single static `to_sign`, only the signature provided by the prover, and put by the verifier into the input of `to_sign`\r\n\r\nIt makes sense to make the case 3 mandatory and other two optional, but they need to be thoroughly specified anyway.\r\n\r\nIt might make sense to specify the case 3 in one BIP and the other two (more complex) cases in another BIP, so that a simple \"signature for the address/script without fancy opcodes\" spec can become complete and be adopted earlier",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709849852",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709859022,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTg1OTAyMg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709859022",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T06:56:14Z",
      "updated_at": "2020-10-16T06:57:16Z",
      "author_association": "CONTRIBUTOR",
      "body": ">  so that a simple \"signature for the address/script without fancy opcodes\" spec can become complete and be adopted earlier\r\n\r\nI think this is the most practical case where the lack of modern \"signature for invoice address\" standard causes pain for people, and the \"proof of funds\" and \"proof of invoice address with fancy script\" are much less profound cases. ",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709859022",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709868936,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTg2ODkzNg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709868936",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T07:12:33Z",
      "updated_at": "2020-10-16T07:12:33Z",
      "author_association": "MEMBER",
      "body": "> For example, current spec says `nLockTime = 0` on `to_sign` transaction, but for proof-of-funds when scripts has CLTV, `nLockTime` has to be set accordingly. For the spec to be consistent, it has to account for this.\r\n\r\nAh, yes you're right. I'll update the spec to reflect this.\r\n\r\n> For \"signature for the address\" case, if the verifier chooses to support the `in_future` flag, the prover has to set `nLockTime`/`nSequence` fields on `to_sign` before signing, and the verifier needs to set them to the same values, and these values need to be communicated. Of course they can be communicated as a full transaction, and then verifier would need to validate the transaction to check that other fields are as written in the spec. It seems as in this case the complexity gets closer to the 'proof of funds' case, and also the data to be exchanged is the same (except the `to_sign` transaction passed from prover to verifier does not contain real inputs).\r\n\r\nCurrently, the values are communicated as the two transaction pairs serialized as normal, which means the signer can set an arbitrary `nLockTime` and the verifier can just adopt/check that.\r\n\r\n> It seems to me that it is easier to introduce a degenerate 'no inputs' proof-of-funds case where prover passes the signed transaction to the verifier, and the verifier validates and then verifies.\r\n\r\nThis was the initial approach. The reason it's now the two transactions is that it becomes a lot more complex to have multiple types. For instance, if I prove with no additional inputs (\"signature for the address\") you get a signature only, but when I prove with inputs, you get a signature and the inputs, and now you have to decide if those should include the virtual input, and you get complexities when signing where you have to put it in and then remove it, unless you keep it there.\r\n\r\nYes, proofs are a little bigger, and you need deserialization code even for the non-PoF case, but you need that anyway, cause you need to be able to independently generate the sighash.\r\n\r\n> Looks like there are three cases:\r\n> \r\n> 1. The full \"proof of funds\": multiple dynamic `to_spend` (taken from blockchain) and a dynamic `to_sign` (provided by the prover)\r\n> 2. The complex case of \"signature for the address\": single static `to_spend` and a dynamic `to_sign` (provided by the prover)\r\n> 3. The simple case of \"signature for the address\": single static `to_spend` and single static `to_sign`, only the signature provided by the prover, and put by the verifier into the input of `to_sign`\r\n> \r\n> It makes sense to make the case 3 mandatory and other two optional, but they need to be thoroughly specified anyway.\r\n> \r\n> It might make sense to specify the case 3 in one BIP and the other two (more complex) cases in another BIP, so that a simple \"signature for the address/script without fancy opcodes\" spec can become complete and be adopted earlier\r\n\r\nIt feels like it wouldn't be useful to have 1-2 unless they were a non-optional part of the specification. Even 3 would require you to have most of the functionality that is required by 1 (serialization, signature verification, transactions, etc).\r\n\r\n(As a sidenote, I'm still wondering if it should optionally allow for \"help\" transactions, i.e. taken from the (U)TXO set or wallet. This would help when proving for a spent outpoint, and when giving a proof to a verifier who doesn't have access to the UTXO set.)",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709868936",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3884921424,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NDkyMTQyNA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3884921424",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T07:15:04Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3885016125,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NTAxNjEyNQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3885016125",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T07:39:48Z"
    },
    {
      "event": "commented",
      "id": 709882803,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTg4MjgwMw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709882803",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T07:41:25Z",
      "updated_at": "2020-10-16T07:41:25Z",
      "author_association": "MEMBER",
      "body": "> Checking that CLTV/CSV was actually executed would require additional instrumentation of the interpreter, or running the interpreter two times for each opcode: first with transaction locktime / sequence set for CLTV/CSV to be always successful, and then to always fail (and also likely to need distinct signatures for each variant).\r\n\r\nBtw, I may be mistaken, but I believe the CLTV/CSV checks will succeed, but the locktime/sequence values in the transaction itself will determine if it is in the future or not.\r\n\r\nIn other words, the check will succeed, but the lock time will be e.g. 100 blocks from now, or 7 days in the future.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709882803",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3885152414,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NTE1MjQxNA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3885152414",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T08:12:01Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3885169311,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NTE2OTMxMQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3885169311",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T08:16:18Z"
    },
    {
      "event": "commented",
      "id": 709912919,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTkxMjkxOQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709912919",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T08:43:00Z",
      "updated_at": "2020-10-16T08:44:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Btw, I may be mistaken, but I believe the CLTV/CSV checks will succeed, but the locktime/sequence values in the transaction itself will determine if it is in the future or not.\r\n\r\n> In other words, the check will succeed, but the lock time will be e.g. 100 blocks from now, or 7 days in the future.\r\n\r\nWhen the prover provides the `to_sign` transaction with locktime/sequence fields already set, the verifier that just executes the script will not know if the script is only spendable in the future. To know that, they will need a way to detect that CLTV/CSV in the script is executing. If the verifier only has one `to_sign` (already signed) transaction from the prover, then without instrumented script interpreter, they won't know if the script can fail with different locktime/sequence.\r\n\r\nOn the other hand, they can just assume that if the `to_sign` transaction has locktime or any input sequence set to non-zero, the script _can_ conatin CLTV/CSV, and therefore they shall set `in_the_future` flag to true, regardless of whether these opcodes are actually present/executed.\r\n\r\nThere seems to be no need to set these fields on `to_sign` for any other purpose, so maybe the spec can say something like \"if nLocktime or any of nSequence for the inputs are not zero on the `to_spend` virtual transaction, the in_future flag is set to true\"",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709912919",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709916962,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTkxNjk2Mg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709916962",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T08:51:03Z",
      "updated_at": "2020-10-16T08:56:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Currently, the values are communicated as the two transaction pairs serialized as normal, which means the signer can set an arbitrary nLockTime and the verifier can just adopt/check that.\r\n\r\nFor the simplest \"sign for address\" case where only message, script, and witness is required to be communicated it may be more convenient to send just that data, without sending redundant transaction data. The transaction data is redundant in this case because it can be constructed by the prover. Why spend space to send `prevout.hash` of `to_spend` transaction if it is known to be all-zeroes ? (edit: the simplest case I'm talking about here is also \"no fancy opcodes\" case, but even with CLTV/CSV, nLocktime/nSequence can be optionally added without other \"static\" tx parts)\r\n\r\nThere may be usecases when the number of characters to display the proof is limited by the medium",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709916962",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709923493,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTkyMzQ5Mw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709923493",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T09:03:52Z",
      "updated_at": "2020-10-16T09:03:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "> but when I prove with inputs, you get a signature and the inputs, and now you have to decide if those should include the virtual input\r\n\r\nIf the \"sig for address\" and \"proof of funds\" are distinct cases, there should be no confusion - in the first case you have virtual input, in the second case you'r not. Or alternatively, always have virtual input, but do not sign it for the \"proof of funds\" case. The verifier are concerned with proof for individual inputs, nothing bad happens if they would check the witness of the inputs when `to_sign` is \"partially signed\" (no sig for virtual input) - they won't be able to broadcast the tx anyway, so no need for it to be fully signed",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709923493",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709926402,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTkyNjQwMg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709926402",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T09:09:42Z",
      "updated_at": "2020-10-16T09:12:27Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Yes, proofs are a little bigger, and you need deserialization code even for the non-PoF case, but you need that anyway, cause you need to be able to independently generate the sighash.\r\n\r\nTo generate a sighash you only need serialization code, not deserialization. (re \"this is the same conceptually\" - yes, but unifying ser/deser usually requires a language powerful enough and some effort to engineer this)",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709926402",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709938634,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTkzODYzNA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709938634",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T09:33:45Z",
      "updated_at": "2020-10-16T09:36:47Z",
      "author_association": "MEMBER",
      "body": "> When the prover provides the `to_sign` transaction with locktime/sequence fields already set, the verifier that just executes the script will not know if the script is only spendable in the future.\r\n\r\nI believe you've got it wrong: OP_CSV and OP_CLTV put constraints on the transaction's locktime. If they fail, it means the locktime is too low. The locktime is enforced outside of the transaction *script* check, because a transaction with a locktime in the future may not be put into a block. So simply looking at the locktime of the transaction is sufficient to know if it's spendable now or not.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709938634",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709942624,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTk0MjYyNA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709942624",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T09:42:04Z",
      "updated_at": "2020-10-16T09:42:04Z",
      "author_association": "MEMBER",
      "body": "You're right that providing the two transactions and everything for a simple address proof is overkill. I'll switch it to optionally allow only the script witness for cases without proof of funds.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709942624",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3885541018,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NTU0MTAxOA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3885541018",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T09:47:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3885541950,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NTU0MTk1MA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3885541950",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T09:48:09Z"
    },
    {
      "event": "commented",
      "id": 709948097,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTk0ODA5Nw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709948097",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T09:54:16Z",
      "updated_at": "2020-10-16T10:09:32Z",
      "author_association": "CONTRIBUTOR",
      "body": "> It feels like it wouldn't be useful to have 1-2 unless they were a non-optional part of the specification. Even 3 would require you to have most of the functionality that is required by 1 (serialization, signature verification, transactions, etc).\r\n\r\n1-2 add complexity because they have more dynamic parts. The case 3 may set the basis for the functionality requirements, but uses this functionality in fewer ways because more of the data is static.\r\n\r\nHaving the basic case specified in one spec, and then further extend it in a separate spec for other use-cases seems to me like an adequate way to manage complexity. I'm talking more about spec complexity than implementation complexity. The simple spec without extra details (details that are relevant only to non-mainstream cases) is likely to be better understood and implemented. For example, for the \"case 3 only\", the spec do not need to say anything about locktime/sequence other than \"they are zero\".",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709948097",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709950036,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTk1MDAzNg==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709950036",
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T09:58:36Z",
      "updated_at": "2020-10-16T09:58:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "> So simply looking at the locktime of the transaction is sufficient to know if it's spendable now or not.\r\n\r\nThat's right, but this only works if you know the current height of the blockchain.\r\n\r\nIf you don't know the current height, you can only assume that transaction _may_ be unspendable. This may be sufficient, as I said in\r\n\r\n> On the other hand, they can just assume that if the to_sign transaction has locktime or any input sequence set to non-zero, the script can conatin CLTV/CSV, and therefore they shall set in_the_future flag to true, regardless of whether these opcodes are actually present/executed.\r\n",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709950036",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "commented",
      "id": 709960583,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcwOTk2MDU4Mw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/709960583",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T10:20:59Z",
      "updated_at": "2020-10-16T10:20:59Z",
      "author_association": "MEMBER",
      "body": "> I'm talking more about spec complexity than implementation complexity.\r\n\r\nSo am I. The spec grew in a way I disliked which is why I aborted. I've now pivoted back, as you can see in the latest revision.\r\n\r\nSplitting into two specs may be the best course of action in the end - for now, I've split the validation for the two types into two paragraphs..\r\n",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-709960583",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3885724455,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50Mzg4NTcyNDQ1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3885724455",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T10:35:22Z"
    },
    {
      "event": "reviewed",
      "id": 510399174,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwMzk5MTc0",
      "url": null,
      "actor": null,
      "commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-510399174",
      "submitted_at": "2020-10-16T11:54:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "reviewed",
      "id": 510405194,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNDA1MTk0",
      "url": null,
      "actor": null,
      "commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-510405194",
      "submitted_at": "2020-10-16T12:03:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "reviewed",
      "id": 510408726,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNDA4NzI2",
      "url": null,
      "actor": null,
      "commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-510408726",
      "submitted_at": "2020-10-16T12:08:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "commented",
      "id": 710274498,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcxMDI3NDQ5OA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/710274498",
      "actor": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-16T17:29:44Z",
      "updated_at": "2020-10-16T17:29:44Z",
      "author_association": "NONE",
      "body": "Hey, I just wanted to clarify: I did bring up the question what would happen if the script contained CSV/CLTV, but it was more from a \"what breaks this\"-kinda perspective. My intention would be to have the proposal sufficiently robust that it doesn't mislead verifiers about spendability in the case of locktime, i.e. something like \"may only be spendable in the future\" seems reasonable. It may be interesting to chat with people at Lightning Labs that are working on Lightning Loop whether they have ideas. Being able to sign messages including HTLCs may be of interest to them.",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-710274498",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "reviewed",
      "id": 510673828,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjczODI4",
      "url": null,
      "actor": null,
      "commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#pullrequestreview-510673828",
      "submitted_at": "2020-10-16T18:23:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6NzVlYzk2MzFlZmZjNTI0MzY0Y2RlZDVjM2VmZjAyZTRlMjdlYmY5Yw==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "tree": {
        "sha": "800311b7d6a06bc6bef5461c0f34b926687b0343",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/800311b7d6a06bc6bef5461c0f34b926687b0343"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 800311b7d6a06bc6bef5461c0f34b926687b0343\nparent 60bfc4bb53dbff6795f7c02a10c9e9e31907be26\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1601706540 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1603523355 +0900\n\nBIP-322: switch to tx based approach\n\nCo-authored-by: Stepan Snigirev <stepan.snigirev@mpq.mpg.de>\nCo-authored-by: Luke Dashjr <luke_github1@dashjr.org>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExCr/fGGz5EoUVM01V692LbM1MyIFAl+T0xsACgkQV692LbM1\nMyLHvQ//SNgHa/UOEijARZ9nvyd04+Sg9tPiv5LWpzZkhGYhAitJVwAD7v5sdqV7\n4dRI1z0DC2k53blzItPPG19uUh6QQ9WSleVLKcKtTsVUp7xaEhUWfypkwdXPxhIo\njFGowqKWszMzw6dxvfDInZQUjQ1MYSdLS11V8SgjJQeZi+zhUtbOFAGJih4h4tvT\nsdJERlFMsscvVZuPsFAVDQGVPp58tpkAPWKvHH0ITo2StxO0fCqLGXWP5oV4NUeS\nxzhOAwTWWvy/7CXvI2WfhJUf21Xwm/YoHKztATTWG/2uShB1z1u/prFc79Sy0q39\nFjcOv7+OzNp7muCI91lWhLoYa6JbU41satvA5q+JyAgBiKXP1/RbUn23gaASym8P\nxoXqiEH4uJkAEnngz4CduU3KWV2e3a43b5HbDNqOxdE3Mf+xugCEBiLnStabw4vh\nN4UWW4sVgTri42X1XvGbVVP9/dTT1JyR8HGW4GW0WbAitBQaBtJxQwDH0AxjWGNx\nWq3DTJ4p/f54plL5bxlVsJgsy6gSF81ga49mhob9edEUs/8M942nmoEoVU53BW+a\ngeaAOAgpt5zBu47CTWVl3O2AZDbr3fLp1fkx0+7pxMXYxnxEbWJ1SGvHxUaDseb3\n3kNUKe43YEfq2Kple1QxpZWHXA3r30lSH8Cu4drKt3e2AyB+oXk=\n=YikH\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/60bfc4bb53dbff6795f7c02a10c9e9e31907be26",
          "sha": "60bfc4bb53dbff6795f7c02a10c9e9e31907be26",
          "html_url": "https://github.com/bitcoin/bips/commit/60bfc4bb53dbff6795f7c02a10c9e9e31907be26"
        }
      ],
      "message": "BIP-322: switch to tx based approach\n\nCo-authored-by: Stepan Snigirev <stepan.snigirev@mpq.mpg.de>\nCo-authored-by: Luke Dashjr <luke_github1@dashjr.org>",
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2020-10-24T07:09:15Z"
      },
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2020-10-03T06:29:00Z"
      },
      "sha": "75ec9631effc524364cded5c3eff02e4e27ebf9c"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 3916426269,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MzkxNjQyNjI2OQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3916426269",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-24T07:09:30Z"
    },
    {
      "event": "commented",
      "id": 715837556,
      "node_id": "MDEyOklzc3VlQ29tbWVudDcxNTgzNzU1Ng==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/715837556",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-24T07:11:16Z",
      "updated_at": "2020-10-24T07:11:16Z",
      "author_association": "MEMBER",
      "body": "@luke-jr There may be more changes, but this PR has grown pretty large, and people are still looking at the outdated version, so I suggest we merge this.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1003#issuecomment-715837556",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1003"
    },
    {
      "event": "mentioned",
      "id": 3916427398,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MzkxNjQyNzM5OA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3916427398",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-24T07:11:16Z"
    },
    {
      "event": "subscribed",
      "id": 3916427399,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDM5MTY0MjczOTk=",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3916427399",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-24T07:11:16Z"
    },
    {
      "event": "merged",
      "id": 3916743917,
      "node_id": "MDExOk1lcmdlZEV2ZW50MzkxNjc0MzkxNw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3916743917",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "7e3284dafda168da34888977dbf4a55519b0c54d",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/7e3284dafda168da34888977dbf4a55519b0c54d",
      "created_at": "2020-10-24T13:18:21Z"
    },
    {
      "event": "closed",
      "id": 3916743918,
      "node_id": "MDExOkNsb3NlZEV2ZW50MzkxNjc0MzkxOA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3916743918",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-24T13:18:21Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 3924097076,
      "node_id": "MDE5OkhlYWRSZWZEZWxldGVkRXZlbnQzOTI0MDk3MDc2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/3924097076",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2020-10-27T06:03:16Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/498058387",
      "pull_request_review_id": 500101465,
      "id": 498058387,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA1ODM4Nw==",
      "diff_hunk": "@@ -937,7 +937,7 @@ Those proposing changes should consider that ultimately consent may rest with th\n | Generic Signed Message Format",
      "path": "README.mediawiki",
      "position": null,
      "original_position": 1,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fc7479dffabb597ea3e15edaf56b51d278994753",
      "in_reply_to_id": null,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You'll have to add `|- style=\"background-color: #ffcfcf\"` two lines above this one",
      "created_at": "2020-10-01T08:06:40Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r498058387",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/498058387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 937,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/498076223",
      "pull_request_review_id": 500125046,
      "id": 498076223,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3NjIyMw==",
      "diff_hunk": "@@ -937,7 +937,7 @@ Those proposing changes should consider that ultimately consent may rest with th\n | Generic Signed Message Format",
      "path": "README.mediawiki",
      "position": null,
      "original_position": 1,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fc7479dffabb597ea3e15edaf56b51d278994753",
      "in_reply_to_id": 498058387,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, done",
      "created_at": "2020-10-01T08:36:24Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r498076223",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/498076223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 937,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499146022",
      "pull_request_review_id": 501544541,
      "id": 499146022,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0NjAyMg==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 28,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Isn't it \"there's no standard way to get from pubkey to the address\" rather than \"no pubkey to recover from the resulting signature\" ?\r\n\r\nSurely the signature could be of recoverable type, and if a prover and verifier use the same script template, the verifier can reconstruct the address and check (if all the other info such as other pubkeys are known to verifier and the template can be filled completely)",
      "created_at": "2020-10-03T13:00:39Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499146022",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499146022"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499146182",
      "pull_request_review_id": 501544633,
      "id": 499146182,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0NjE4Mg==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 24,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it should read \"`V` can check\" rather than \"`V` can prove\", as it is the prover who proves, and the verifier who verifies (checks)",
      "created_at": "2020-10-03T13:02:31Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499146182",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499146182"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499147484",
      "pull_request_review_id": 501545700,
      "id": 499147484,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0NzQ4NA==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):\n+\n+1. Valid, if it is a successful spend according to the current consensus rules (sometimes called \"policy\").\n+2. Inconclusive, if it is a successful spend according to consensus rules, but NOT according to policy rules\n+3. Invalid, if it is not a successful spend according to consensus rules\n+\n+A proof is the base64-encoding of the message_signature as is. A validator takes the to be proven pubkey and the proof and transforms it to virtual transactions as described above.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems to me that it should be \"to be proven script and the message\" rather than \"pubkey\".\r\n\r\nThe \"to_spend\" transaction contains a hash of the message in the input and the script \"message_challenge\" in the ouptut. If no standard script templates are defined that would receive only one pubkey, then the verifier will need to know the script and how to insert the pubkey there, along with a way to construct witness to spend the script (miniscript could help, although won't cover all possible scripts).",
      "created_at": "2020-10-03T13:21:21Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499147484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499147484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499147986",
      "pull_request_review_id": 501546086,
      "id": 499147986,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0Nzk4Ng==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 66,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the signature check is performed by the script interpreter, it will honor sighash flags. I think the document should specify that the signature must include SIGHASH_ALL flag, otherwise signature with SIGHASH_NONE would verify with any `message_challenge`",
      "created_at": "2020-10-03T13:27:46Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499147986",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499147986"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499148878",
      "pull_request_review_id": 501546871,
      "id": 499148878,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE0ODg3OA==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 66,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147986,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also, `scriptSig` is not included in segwit signature hash, rather the script is included. It may not be clear for the implementors how they should make the signature commit to `message_hash`. I think the spec should say that the signature should be over sighash calculated with:\r\n```\r\nscript = OP_0 PUSH32[ message_hash ]\r\nhash_type = SIGHASH_ALL\r\namount = 0\r\nsigversion = SIGVERSION_WITNESS_V0\r\n```\r\n\r\n(witness sigversion will avoid stripping `CODESEPARATOR` that happens with sighash calculating with `sigversion = SIGVERSION_BASE`)",
      "created_at": "2020-10-03T13:41:25Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499148878",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499148878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499341056",
      "pull_request_review_id": 501716042,
      "id": 499341056,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MTA1Ng==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 28,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499146022,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "With a p2pkh there is a pubkey hash, and with p2sh there isn't. Yes, there may be one or multiple keys embedded in the script hash, but there's no standardized way of determining that, as opposed to the p2pkh case.\r\n\r\nEdit: more importantly, the recoverable ECDSA signature can recover only one pubkey, so a multisig key, for example, doesn't actually work.",
      "created_at": "2020-10-05T04:29:54Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499341056",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499341056"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499341156",
      "pull_request_review_id": 501716172,
      "id": 499341156,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MTE1Ng==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 24,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499146182,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point, yeah. Changing.",
      "created_at": "2020-10-05T04:30:31Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499341156",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499341156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 24,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499342077",
      "pull_request_review_id": 501717351,
      "id": 499342077,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MjA3Nw==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):\n+\n+1. Valid, if it is a successful spend according to the current consensus rules (sometimes called \"policy\").\n+2. Inconclusive, if it is a successful spend according to consensus rules, but NOT according to policy rules\n+3. Invalid, if it is not a successful spend according to consensus rules\n+\n+A proof is the base64-encoding of the message_signature as is. A validator takes the to be proven pubkey and the proof and transforms it to virtual transactions as described above.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147484,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, you're right. Added 'message'.",
      "created_at": "2020-10-05T04:35:49Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499342077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499342077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499342205",
      "pull_request_review_id": 501717539,
      "id": 499342205,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MjIwNQ==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):\n+\n+1. Valid, if it is a successful spend according to the current consensus rules (sometimes called \"policy\").\n+2. Inconclusive, if it is a successful spend according to consensus rules, but NOT according to policy rules\n+3. Invalid, if it is not a successful spend according to consensus rules\n+\n+A proof is the base64-encoding of the message_signature as is. A validator takes the to be proven pubkey and the proof and transforms it to virtual transactions as described above.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147484,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure what you mean by the second part though -- I think the spending transaction's witness data should be enough, no? I need to write the reference implementation to verify though.",
      "created_at": "2020-10-05T04:36:39Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499342205",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499342205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499343337",
      "pull_request_review_id": 501718923,
      "id": 499343337,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0MzMzNw==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 66,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147986,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, yep. I think requiring it to be SIGHASH_ALL is beneficial, since this also supports proof of funds.",
      "created_at": "2020-10-05T04:43:11Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499343337",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499343337"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499349060",
      "pull_request_review_id": 501726087,
      "id": 499349060,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM0OTA2MA==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 66,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147986,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For some reason I didn't see your 2nd response until now. I added a note that they must use `SIGHASH_ALL`, which commits to the message hash as expected. What do you think?",
      "created_at": "2020-10-05T05:13:10Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499349060",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499349060"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499414061",
      "pull_request_review_id": 501810589,
      "id": 499414061,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxNDA2MQ==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 28,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499146022,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That was exactly my point in regards to the phrase \"because there is no pubkey to recover from the resulting signature.\" -- It does not convey the correct meaning. The correct meaning is along the lines of \"there's no standardized way of determining ...\", \"there's no standard way to get from recovered pubkey to the address\"",
      "created_at": "2020-10-05T08:06:11Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499414061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499414061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499416484",
      "pull_request_review_id": 501813790,
      "id": 499416484,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQxNjQ4NA==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):\n+\n+1. Valid, if it is a successful spend according to the current consensus rules (sometimes called \"policy\").\n+2. Inconclusive, if it is a successful spend according to consensus rules, but NOT according to policy rules\n+3. Invalid, if it is not a successful spend according to consensus rules\n+\n+A proof is the base64-encoding of the message_signature as is. A validator takes the to be proven pubkey and the proof and transforms it to virtual transactions as described above.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147484,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe I do not fully get what data the prover would provide. Do they provide the full script (including the pubkeys) and the witness data to satisfy this script, that will contain any needed signatures ? Will it be the verifier's job to check that the script matches some template that prover and verifier agree beforehand ?",
      "created_at": "2020-10-05T08:10:40Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499416484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499416484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499424318",
      "pull_request_review_id": 501824921,
      "id": 499424318,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNDMxOA==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can check that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 47,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "aa6ceaf8c0f5ebbd164f8e292d8b465aeba80e54",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `SignatureHash` function in Core does not take anything from scriptSig. It takes the `scriptCode` as the supplied argument, and later uses it in the hashing.\r\n\r\nAFAIU this `scriptSig = OP_0 PUSH32[ message_hash ]` is intended to convey that the message hash will be committed to as part of the script supplied to `SignatureHash`. But as `SignatureHash` does not use the contents of `scriptSig` in the input at all, and only uses the script that is supplied as argument, I believe that it would be more clear to state this explicitly. This is what I meant in an earlier message. The document should just specify all the relevant arguments to `SignatureHash`, roughly: `SignatureHash(CScript([OP_0, message_hash]), tx_to_spend, 0 /* nIn */, SIGHASH_ALL, 0 /* amount */, SigVersion::WITNESS_V0)`",
      "created_at": "2020-10-05T08:25:18Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499424318",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499424318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499424877",
      "pull_request_review_id": 501825632,
      "id": 499424877,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNDg3Nw==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 66,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147986,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Moved the conversation about the rest to the `vin[0].scriptSig = OP_0 PUSH32[ message_hash ]` line.",
      "created_at": "2020-10-05T08:26:12Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499424877",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499424877"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499426615",
      "pull_request_review_id": 501827936,
      "id": 499426615,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQyNjYxNQ==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can check that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 47,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "aa6ceaf8c0f5ebbd164f8e292d8b465aeba80e54",
      "in_reply_to_id": 499424318,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(edited the above message, added sigversion as the parameter to SignatureHash)\r\n\r\nThe way to calculate the hash that will be signed need to be unambiguous. If we choose to use `SigVersion::WITNESS_V0` for sigversion, then `amount` should be fixed, because it will affect the hash.",
      "created_at": "2020-10-05T08:29:10Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499426615",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499426615"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499444032",
      "pull_request_review_id": 501850628,
      "id": 499444032,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ0NDAzMg==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 28,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499146022,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I see what you mean, changing.",
      "created_at": "2020-10-05T08:58:19Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499444032",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499444032"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499448357",
      "pull_request_review_id": 501856390,
      "id": 499448357,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ0ODM1Nw==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):\n+\n+1. Valid, if it is a successful spend according to the current consensus rules (sometimes called \"policy\").\n+2. Inconclusive, if it is a successful spend according to consensus rules, but NOT according to policy rules\n+3. Invalid, if it is not a successful spend according to consensus rules\n+\n+A proof is the base64-encoding of the message_signature as is. A validator takes the to be proven pubkey and the proof and transforms it to virtual transactions as described above.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147484,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The prover provides the `message_signature`:\r\n\r\n1. Prover and verifier establish `message` and `address`.\r\n2. Prover generates the transactions, signs the second one, and takes the signature (witness data) and base64 encodes that and gives it to verifier.\r\n3. Verifier base64-decodes, regenerates the two transactions, with the signature in place.\r\n4. Verifier then verifies the transactions, in the same way Signet does it.",
      "created_at": "2020-10-05T09:05:46Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499448357",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499448357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499450509",
      "pull_request_review_id": 501859254,
      "id": 499450509,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1MDUwOQ==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can check that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 47,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "aa6ceaf8c0f5ebbd164f8e292d8b465aeba80e54",
      "in_reply_to_id": 499424318,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We do not actually sign this transaction, we sign the transaction spending it.",
      "created_at": "2020-10-05T09:09:24Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499450509",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499450509"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499451571",
      "pull_request_review_id": 501860708,
      "id": 499451571,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1MTU3MQ==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):\n+\n+1. Valid, if it is a successful spend according to the current consensus rules (sometimes called \"policy\").\n+2. Inconclusive, if it is a successful spend according to consensus rules, but NOT according to policy rules\n+3. Invalid, if it is not a successful spend according to consensus rules\n+\n+A proof is the base64-encoding of the message_signature as is. A validator takes the to be proven pubkey and the proof and transforms it to virtual transactions as described above.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147484,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To be even more clear, the way this is meant to be done is exactly like the Signet approach, except I'm disallowing scriptSigs and only allowing script witness, where Signet allows both types.\r\n\r\nI.e. the signet block signature is the equivalent of the proof by the prover here, the block hash in Signet is the equivalent of the message hash here, and the block challenge in Signet is the equivalent of the prover's address.",
      "created_at": "2020-10-05T09:11:15Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499451571",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499451571"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499455389",
      "pull_request_review_id": 501865708,
      "id": 499455389,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1NTM4OQ==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):\n+\n+1. Valid, if it is a successful spend according to the current consensus rules (sometimes called \"policy\").\n+2. Inconclusive, if it is a successful spend according to consensus rules, but NOT according to policy rules\n+3. Invalid, if it is not a successful spend according to consensus rules\n+\n+A proof is the base64-encoding of the message_signature as is. A validator takes the to be proven pubkey and the proof and transforms it to virtual transactions as described above.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147484,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, I believe I understand now:\r\n\r\nThe witness data will include the script, if the `scriptPubKey` in the to_spend transaction is p2sh or p2wsh. And the because the prover and verifier agreed on a certain address beforehand, they agreed on the exact script, too.",
      "created_at": "2020-10-05T09:17:12Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499455389",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499455389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499463049",
      "pull_request_review_id": 501869354,
      "id": 499463049,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2MzA0OQ==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can check that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 47,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "aa6ceaf8c0f5ebbd164f8e292d8b465aeba80e54",
      "in_reply_to_id": 499424318,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "So it will be included (committed to) in the sighash via txid in the prevout of to_sign transaction. And all the arguments to the `SignatureHash` except signature type can be derived from the `message_challenge` script to_spend transaction structure.\r\nIt is clear to me now, thanks.",
      "created_at": "2020-10-05T09:28:28Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499463049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499463049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499466365",
      "pull_request_review_id": 501869354,
      "id": 499466365,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2NjM2NQ==",
      "diff_hunk": "@@ -0,0 +1,174 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can check that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address wrapping a single pubkey, as there is no standardized way of comparing the recovered pubkey with the input, and it is impossible to sign for any address that is not derived from a single pubkey, with no other encumbrances.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 62,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "a47de99c8afe3d2d069ae480477b218cdb26de10",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why is message_signature is put in the output ?\r\n\r\nIIUC, `message_signature` is supposed to be provided as base64-encoded proof, not included in the transaction itself.\r\n\r\nIf the signature is over this exact \"to_sign\" transaction, it cannot be included at the time of signing, because there will be a circular dependency (the sighash will be dependent on the output, which have to include the signature)",
      "created_at": "2020-10-05T09:33:29Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499466365",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499466365"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499467654",
      "pull_request_review_id": 501881332,
      "id": 499467654,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2NzY1NA==",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions.\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature\n+\n+It may include other inputs, to facilitate a proof of funds.\n+\n+A message signature is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the following steps (also see Consensus and standard flags section further down):\n+\n+1. Valid, if it is a successful spend according to the current consensus rules (sometimes called \"policy\").\n+2. Inconclusive, if it is a successful spend according to consensus rules, but NOT according to policy rules\n+3. Invalid, if it is not a successful spend according to consensus rules\n+\n+A proof is the base64-encoding of the message_signature as is. A validator takes the to be proven pubkey and the proof and transforms it to virtual transactions as described above.",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 72,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "fe91069e93221455a7e8c5ee7c6bac10e90f37f9",
      "in_reply_to_id": 499147484,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yup!",
      "created_at": "2020-10-05T09:35:27Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499467654",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499467654"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 72,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499890096",
      "pull_request_review_id": 502443637,
      "id": 499890096,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg5MDA5Ng==",
      "diff_hunk": "@@ -0,0 +1,174 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Generic Signed Message Format\n+  Author: Karl-Johan Alm <karljohan-alm@garage.co.jp>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-10-01\n+  License: CC0-1.0\n+  Replaces: 322\n+</pre>\n+\n+== Abstract ==\n+\n+A standard for interoperable generic signed messages based on the Bitcoin Script format.\n+\n+== Background ==\n+\n+* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n+* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n+* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n+* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can check that <code>P</code> has the private key associated with <code>A</code>.\n+\n+The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n+\n+While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address wrapping a single pubkey, as there is no standardized way of comparing the recovered pubkey with the input, and it is impossible to sign for any address that is not derived from a single pubkey, with no other encumbrances.\n+\n+== Motivation ==\n+\n+The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n+\n+== Specification ==\n+\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n+\n+Let there be two virtual transactions to_spend and to_sign.\n+\n+The \"to_spend\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n+\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP????-signed-message\", and message_challenge is the to be proven (public) key script.\n+\n+The \"to_sign\" transaction is:\n+\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_signature",
      "path": "bip-signmessage-redone.mediawiki",
      "position": null,
      "original_position": 62,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "a47de99c8afe3d2d069ae480477b218cdb26de10",
      "in_reply_to_id": 499466365,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That looks like an oopsie (that is also repeated in BIP-325). Good catch, fixing!",
      "created_at": "2020-10-05T21:45:40Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r499890096",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/499890096"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506337570",
      "pull_request_review_id": 510399174,
      "id": 506337570,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMzNzU3MA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 108,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Simple proofs are not only without inputs, but also without scripts that require `nVersion`, `nLockTime` and/or `nSequence` to be set to non-zero values",
      "created_at": "2020-10-16T11:54:14Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506337570",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506337570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506344983",
      "pull_request_review_id": 510405194,
      "id": 506344983,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0NDk4Mw==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once\n+# reconstruct the to_spend' and to_sign' transactions, based on the specification above, copying the version, lock time, and sequence values\n+# verify that to_spend = to_spend', that to_sign has at least 1 input, has exactly 1 output, and that to_sign.vin[0] = to_sign'.vin[0]\n+# optional: set the \"in_future\" flag if the transaction's lock time is in the future according to consensus rules\n+# in \"coins\", a mapping of outpoints (hash, vout) to coins (scriptPubKey, amount), let coins(to_spend.txid, 0) = (to_spend.vout[0], 0)",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 128,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The next sentence uses the phrase \"coins map\". I think using it here would make this easier to read: ``Establish a \"coins map\": a mapping of outpoints (hash, vout) to coins (scriptPubKey, amount), initialized to coins(to_spend.txid, 0) => (to_spend.vout[0].scriptPubKey, 0)``",
      "created_at": "2020-10-16T12:03:32Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506344983",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506344983"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506349229",
      "pull_request_review_id": 510408726,
      "id": 506349229,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM0OTIyOQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once\n+# reconstruct the to_spend' and to_sign' transactions, based on the specification above, copying the version, lock time, and sequence values\n+# verify that to_spend = to_spend', that to_sign has at least 1 input, has exactly 1 output, and that to_sign.vin[0] = to_sign'.vin[0]\n+# optional: set the \"in_future\" flag if the transaction's lock time is in the future according to consensus rules\n+# in \"coins\", a mapping of outpoints (hash, vout) to coins (scriptPubKey, amount), let coins(to_spend.txid, 0) = (to_spend.vout[0], 0)\n+# for each proof of fund input, set the corresponding values in the coins map; abort if the input cannot be found\n+# check the signature of each input using consensus rules, then upgradable rules\n \n-While omitted below, ERROR is returned if an unforeseen error occurs at any point in the process. A concrete example of this is if a legacy proof is given as input to a non-legacy address; the deserialization of the proof will fail in this case, and this should result in an ERROR result.\n+To validate a simple proof, the following steps must be taken:",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 133,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think simple proof have to come first, so if the reader is only interested in basic \"simple proof\" usecase, they will be presented with it immediately, rather than read a long list of items and then realize \"hey, I do not need all that, I only need these two items\"",
      "created_at": "2020-10-16T12:08:51Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506349229",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506349229"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506624681",
      "pull_request_review_id": 510673828,
      "id": 506624681,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYyNDY4MQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 16,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nA standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as the owner of an invoice address.\r\n```\r\n\r\n\"Recipient\" feels a bit odd in the context, because one could sign a message before ever receiving a payment to an address. I must admit that \"owner\" doesn't feel great either, but it's the best I have for \"person in control of the private key corresponding to the invoice address in question\".",
      "created_at": "2020-10-16T17:36:15Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506624681",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506624681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506630238",
      "pull_request_review_id": 510673828,
      "id": 506630238,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYzMDIzOA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 23,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nThe current message signing standard only works for P2PKH (1...) invoice addresses. We propose to extend and generalize the standard by using a Bitcoin Script based approach. This approach minimizes the burden for implementers as message signing can be expected to be part of a library or project that includes Bitcoin Script interpreters already.\r\n```",
      "created_at": "2020-10-16T17:45:12Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506630238",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506630238"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506635556",
      "pull_request_review_id": 510673828,
      "id": 506635556,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYzNTU1Ng==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.",
      "path": "bip-0322.mediawiki",
      "position": 27,
      "original_position": 27,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure I understand this sentence. My impression was that the signer has to have access to the private key to create a signature for the message. Since the current standard only supports messages for P2PKH, would that then not be equivalent to being able to spend funds locked to the address invoice? I'm also not sure what you are trying to express with \"implement this invoice\". If that just means \"spend funds from the address\", it would be best to repeat the same terminology for the same procedure. Being a bit repetitive in a technical text is acceptable for clarity's sake.",
      "created_at": "2020-10-16T17:54:25Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506635556",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506635556"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506638641",
      "pull_request_review_id": 510673828,
      "id": 506638641,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYzODY0MQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.",
      "path": "bip-0322.mediawiki",
      "position": 99,
      "original_position": 99,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nWhen a proof of funds is being created, additional inputs MUST be included for virtually spending transaction outputs of desired value.\r\n```\r\nIt is not clear to me how the proof of funds would work if the inclusion of the additional funds is optional. Wouldn't that have to be a requirement?",
      "created_at": "2020-10-16T17:59:55Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506638641",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506638641"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506639225",
      "pull_request_review_id": 510673828,
      "id": 506639225,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjYzOTIyNQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.",
      "path": "bip-0322.mediawiki",
      "position": 111,
      "original_position": 111,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nA validator must verify that the to_sign transaction is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\r\n```\r\n\r\nLet's avoid \"it\" and err on repeating the exact data that needs to be valid.",
      "created_at": "2020-10-16T18:00:55Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506639225",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506639225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506640743",
      "pull_request_review_id": 510673828,
      "id": 506640743,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0MDc0Mw==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 120,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nTo validate a proof of funds, the following steps must be taken:\r\n```\r\nWe should always use the same term to refer to the same concept.",
      "created_at": "2020-10-16T18:04:04Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506640743",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506640743"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506641160",
      "pull_request_review_id": 510673828,
      "id": 506641160,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0MTE2MA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 108,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nProofs of funds are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\r\n```\r\nLet's use the same term for this concept consistently.",
      "created_at": "2020-10-16T18:04:57Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506641160",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506641160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506643597",
      "pull_request_review_id": 510673828,
      "id": 506643597,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0MzU5Nw==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 124,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n# verify that the to_sign transaction uses all inputs covered by the proof of funds exactly once\r\n```",
      "created_at": "2020-10-16T18:09:38Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506643597",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506643597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506645531",
      "pull_request_review_id": 510673828,
      "id": 506645531,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0NTUzMQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once\n+# reconstruct the to_spend' and to_sign' transactions, based on the specification above, copying the version, lock time, and sequence values\n+# verify that to_spend = to_spend', that to_sign has at least 1 input, has exactly 1 output, and that to_sign.vin[0] = to_sign'.vin[0]\n+# optional: set the \"in_future\" flag if the transaction's lock time is in the future according to consensus rules",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 127,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I would propose that we choose to either not cover locktime at all (i.e. have the spec fail to make a determination), or explicitly state how it should be treated. I would worry that optional features in a standard would otherwise lead to variable behavior that could cause compatibility issues later on.",
      "created_at": "2020-10-16T18:13:23Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506645531",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506645531"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506647531",
      "pull_request_review_id": 510673828,
      "id": 506647531,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY0NzUzMQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once\n+# reconstruct the to_spend' and to_sign' transactions, based on the specification above, copying the version, lock time, and sequence values\n+# verify that to_spend = to_spend', that to_sign has at least 1 input, has exactly 1 output, and that to_sign.vin[0] = to_sign'.vin[0]\n+# optional: set the \"in_future\" flag if the transaction's lock time is in the future according to consensus rules\n+# in \"coins\", a mapping of outpoints (hash, vout) to coins (scriptPubKey, amount), let coins(to_spend.txid, 0) = (to_spend.vout[0], 0)\n+# for each proof of fund input, set the corresponding values in the coins map; abort if the input cannot be found\n+# check the signature of each input using consensus rules, then upgradable rules\n \n-While omitted below, ERROR is returned if an unforeseen error occurs at any point in the process. A concrete example of this is if a legacy proof is given as input to a non-legacy address; the deserialization of the proof will fail in this case, and this should result in an ERROR result.\n+To validate a simple proof, the following steps must be taken:\n \n-# Verify Script with flags=consensus flags (currently P2SH, DERSIG, NULLDUMMY, CLTV, CSV, WITNESS), scriptSig=script sig, scriptPubKey=scriptPubKey, witness=witness, and sighash=sighash\n-# Return INVALID if verification fails\n-# Verify Script with flags=standard flags (above plus STRICTENC, MINIMALDATA, etc.), scriptSig=script sig, scriptPubKey=scriptPubKey, witness=witness, and sighash=sighash\n-# Return VALID if verification succeeds, otherwise return INCONCLUSIVE\n+# construct the to_spend and to_sign transactions, based on the specification above\n+# check the signature using consensus rules, then upgradable rules\n \n == Legacy format ==\n \n-The legacy format is restricted to the legacy P2PKH address format.\n+The legacy format is restricted to the legacy P2PKH invoice address format.\n \n-Any other input (i.e. non-P2PKH address format) must be signed using the new format described above.\n+Any other input (i.e. non-P2PKH invoice address format) must be signed using the new format described above.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 148,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps it should be recommended here to prefer the general format even for P2PKH going forth.",
      "created_at": "2020-10-16T18:17:29Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506647531",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506647531"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506683551",
      "pull_request_review_id": 510750080,
      "id": 506683551,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MzU1MQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 16,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506624681,
      "user": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A custodian might allow customers to sign messages with their designated deposit addresses, but the customers may not control the keys and just receive the promise of being able to withdraw equivalent amount in the future (potentially from completely unrelated UTXO).\r\n\r\nIt seems to me that \"committing to a message as the intended recipient of the funds to be sent to the invoice address\" would be more fitting description",
      "created_at": "2020-10-16T19:36:25Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506683551",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506683551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506706223",
      "pull_request_review_id": 510779440,
      "id": 506706223,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwNjIyMw==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 16,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506624681,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Excellent point! I like the rephrasing, but think it could be put a bit more succinctly: \"committing to a message as the intended recipient of funds sent to the invoice address\".",
      "created_at": "2020-10-16T20:29:19Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r506706223",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/506706223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511328866",
      "pull_request_review_id": 516164763,
      "id": 511328866,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyODg2Ng==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 108,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506337570,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added \"or time locks\".",
      "created_at": "2020-10-24T06:45:35Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511328866",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511328866"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511328958",
      "pull_request_review_id": 516164831,
      "id": 511328958,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyODk1OA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once\n+# reconstruct the to_spend' and to_sign' transactions, based on the specification above, copying the version, lock time, and sequence values\n+# verify that to_spend = to_spend', that to_sign has at least 1 input, has exactly 1 output, and that to_sign.vin[0] = to_sign'.vin[0]\n+# optional: set the \"in_future\" flag if the transaction's lock time is in the future according to consensus rules\n+# in \"coins\", a mapping of outpoints (hash, vout) to coins (scriptPubKey, amount), let coins(to_spend.txid, 0) = (to_spend.vout[0], 0)",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 128,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506344983,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sounds good",
      "created_at": "2020-10-24T06:46:43Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511328958",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511328958"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511328984",
      "pull_request_review_id": 516164855,
      "id": 511328984,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyODk4NA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once\n+# reconstruct the to_spend' and to_sign' transactions, based on the specification above, copying the version, lock time, and sequence values\n+# verify that to_spend = to_spend', that to_sign has at least 1 input, has exactly 1 output, and that to_sign.vin[0] = to_sign'.vin[0]\n+# optional: set the \"in_future\" flag if the transaction's lock time is in the future according to consensus rules\n+# in \"coins\", a mapping of outpoints (hash, vout) to coins (scriptPubKey, amount), let coins(to_spend.txid, 0) = (to_spend.vout[0], 0)\n+# for each proof of fund input, set the corresponding values in the coins map; abort if the input cannot be found\n+# check the signature of each input using consensus rules, then upgradable rules\n \n-While omitted below, ERROR is returned if an unforeseen error occurs at any point in the process. A concrete example of this is if a legacy proof is given as input to a non-legacy address; the deserialization of the proof will fail in this case, and this should result in an ERROR result.\n+To validate a simple proof, the following steps must be taken:",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 133,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506349229,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Of course, swapped.",
      "created_at": "2020-10-24T06:47:07Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511328984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511328984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 81,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329244",
      "pull_request_review_id": 516165026,
      "id": 511329244,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTI0NA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 16,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506624681,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Changed!",
      "created_at": "2020-10-24T06:50:36Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511329244",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329244"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 16,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329665",
      "pull_request_review_id": 516165264,
      "id": 511329665,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTY2NQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.",
      "path": "bip-0322.mediawiki",
      "position": 27,
      "original_position": 27,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506635556,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I can forward the message to Fred, who owns the keys, and he signs it and hands it back to me. Now I don't have the keys myself, but I am able to produce that signature for you, because Fred allows me. He may not allow me to send from a UTXO associated with that invoice address though, but that's another story.",
      "created_at": "2020-10-24T06:55:40Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511329665",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329665"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329806",
      "pull_request_review_id": 516165359,
      "id": 511329806,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTgwNg==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.",
      "path": "bip-0322.mediawiki",
      "position": 99,
      "original_position": 99,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506638641,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Well, to turn it around, if I give you a proof and it has inputs, it's a proof of funds for those inputs. If you ask me for a proof of funds for input A and I give you one for input B, it's the same as if I gave you a proof for bc1qA when you asked for bc1qB.\r\n\r\nIn that sense, I think \"should\" is correct, since it's up to the prover to put in what the verifier is asking for.",
      "created_at": "2020-10-24T06:57:51Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511329806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329918",
      "pull_request_review_id": 516165421,
      "id": 511329918,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTkxOA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.",
      "path": "bip-0322.mediawiki",
      "position": 111,
      "original_position": 111,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506639225,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No they also have to make sure both of them are valid, because the prover could give a to_spend transaction that e.g. doesn't include the challenge.",
      "created_at": "2020-10-24T06:59:13Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511329918",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329918"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329941",
      "pull_request_review_id": 516165438,
      "id": 511329941,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTk0MQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 120,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506640743,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point, yeah",
      "created_at": "2020-10-24T06:59:33Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511329941",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511329941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511330290",
      "pull_request_review_id": 516165668,
      "id": 511330290,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMDI5MA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once\n+# reconstruct the to_spend' and to_sign' transactions, based on the specification above, copying the version, lock time, and sequence values\n+# verify that to_spend = to_spend', that to_sign has at least 1 input, has exactly 1 output, and that to_sign.vin[0] = to_sign'.vin[0]\n+# optional: set the \"in_future\" flag if the transaction's lock time is in the future according to consensus rules",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 127,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506645531,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it may make sense to not make this optional now that we've split out into two types of proofs (simple proofs and PoF).",
      "created_at": "2020-10-24T07:04:18Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511330290",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511330290"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 76,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511330631",
      "pull_request_review_id": 516165894,
      "id": 511330631,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMDYzMQ==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.\n \n-The signature is generated as follows:\n+=== Validation ===\n \n-# Derive the private key privkey for the scriptPubKey; FAIL if not VALID\n-# Generate and return a signature sig with privkey=privkey, sighash=sighash\n-\n-=== Verifying ===\n+To validate a proof with additional inputs, the following steps must be taken:\n \n-Verify a proof, given a standard flags value, a script sig, an optional witness, and a derived sighash as described above.\n+# deserialize the to_spend and to_sign transactions from the proof, and fail if the proof contains extraneous bytes\n+# verify that any additional inputs being proven (proof of funds) are included as inputs in the to_sign transaction, exactly once\n+# reconstruct the to_spend' and to_sign' transactions, based on the specification above, copying the version, lock time, and sequence values\n+# verify that to_spend = to_spend', that to_sign has at least 1 input, has exactly 1 output, and that to_sign.vin[0] = to_sign'.vin[0]\n+# optional: set the \"in_future\" flag if the transaction's lock time is in the future according to consensus rules\n+# in \"coins\", a mapping of outpoints (hash, vout) to coins (scriptPubKey, amount), let coins(to_spend.txid, 0) = (to_spend.vout[0], 0)\n+# for each proof of fund input, set the corresponding values in the coins map; abort if the input cannot be found\n+# check the signature of each input using consensus rules, then upgradable rules\n \n-While omitted below, ERROR is returned if an unforeseen error occurs at any point in the process. A concrete example of this is if a legacy proof is given as input to a non-legacy address; the deserialization of the proof will fail in this case, and this should result in an ERROR result.\n+To validate a simple proof, the following steps must be taken:\n \n-# Verify Script with flags=consensus flags (currently P2SH, DERSIG, NULLDUMMY, CLTV, CSV, WITNESS), scriptSig=script sig, scriptPubKey=scriptPubKey, witness=witness, and sighash=sighash\n-# Return INVALID if verification fails\n-# Verify Script with flags=standard flags (above plus STRICTENC, MINIMALDATA, etc.), scriptSig=script sig, scriptPubKey=scriptPubKey, witness=witness, and sighash=sighash\n-# Return VALID if verification succeeds, otherwise return INCONCLUSIVE\n+# construct the to_spend and to_sign transactions, based on the specification above\n+# check the signature using consensus rules, then upgradable rules\n \n == Legacy format ==\n \n-The legacy format is restricted to the legacy P2PKH address format.\n+The legacy format is restricted to the legacy P2PKH invoice address format.\n \n-Any other input (i.e. non-P2PKH address format) must be signed using the new format described above.\n+Any other input (i.e. non-P2PKH invoice address format) must be signed using the new format described above.",
      "path": "bip-0322.mediawiki",
      "position": null,
      "original_position": 148,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506647531,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This was discussed in an earlier draft of this proposal, and then people were opposing the conclusion (that was to use legacy for P2PK(H)). I'm going to push for using the new format and see what people think, so:\r\n\r\n> New proofs should use the new format for all invoice address formats, including P2PKH.\r\n>\r\n> The legacy format MAY be used, but must be restricted to the legacy P2PKH invoice address format.\r\n",
      "created_at": "2020-10-24T07:08:41Z",
      "updated_at": "2020-10-24T07:09:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r511330631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/511330631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/514601184",
      "pull_request_review_id": 520130501,
      "id": 514601184,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMTE4NA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.",
      "path": "bip-0322.mediawiki",
      "position": 99,
      "original_position": 99,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506638641,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Still a bit on the fence for this one. Obviously, the challenged does not have to fulfill a challenge, but responding with other information instead seems a bit pointless. :)",
      "created_at": "2020-10-29T22:21:40Z",
      "updated_at": "2020-10-29T22:21:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r514601184",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/514601184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/514602518",
      "pull_request_review_id": 520132119,
      "id": 514602518,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMjUxOA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.",
      "path": "bip-0322.mediawiki",
      "position": 111,
      "original_position": 111,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506639225,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems to me that it was not completely clear what is encompassed by \"it\" in that sentence. \"It\" is singular, so if this \"it\" refers to more than one item that needs to be validated, it may be helpful to explicitly list all the items again.",
      "created_at": "2020-10-29T22:25:13Z",
      "updated_at": "2020-10-29T22:25:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r514602518",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/514602518"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/514904278",
      "pull_request_review_id": 520414897,
      "id": 514904278,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwNDI3OA==",
      "diff_hunk": "@@ -13,119 +13,99 @@\n \n == Abstract ==\n \n-A standard for interoperable generic signed messages based on the Bitcoin Script format.\n-\n-== Background ==\n-\n-* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.\n-* <code>P</code> wants to prove that they own the private key <code>k</code> associated with a given address <code>A</code> (which in turn is derived from the pubkey <code>kG</code>).\n-* Let <code>V</code> generate a message <code>M</code> and hand this to <code>P</code>.\n-* <code>P</code> generates a signature <code>S</code> by signing the message <code>M</code> using <code>k</code>. Given <code>S</code>, <code>V</code> can prove that <code>P</code> has the private key associated with <code>A</code>.\n-\n-The astute reader will notice that the above is missing a critical part, namely the pubkey <code>kG</code>, without which the verifier cannot actually verify the message. The current message signing standard solves this via a cryptographic trick, wherein the signature <code>S</code> above is a special \"recoverable signature\" type. Given the message <code>M</code> and the signature <code>S</code>, it is then possible to recover the pubkey <code>kG</code>. The system thus derives the address for the pubkey <code>kG</code>, and if it does not match <code>A</code>, the proof is deemed invalid.\n-\n-While this is a neat trick, it unnecessarily restricts and complicates the message signing mechanism; for instance, it is currently not possible to sign a message for a P2SH address, because there is no pubkey to recover from the resulting signature.\n+A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as a recipient of an invoice address.\n \n == Motivation ==\n \n-The current message signing standard only works for P2PKH (1...) addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n-\n-== Specification ==\n+The current message signing standard only works for P2PKH (1...) invoice addresses. By extending it to use a Bitcoin Script based approach, it could be made more generic without causing a too big burden on implementers, who most likely have access to Bitcoin Script interpreters already.\n \n-A new structure <code>SignatureProof</code> is added, which is a simple serializable scriptSig & witness container.\n+Additionally, the current message signing only proves that the message has been committed to by the recipient of a given invoice address.\n+It does not prove anything about the invoice address itself, nor that the signer has access to the private keys used to implement this invoice.\n+More importantly, it does not prove ownership nor access to any funds, even if the same private key would be a valid signer for spending them - and this is a commonly desired use case.\n \n-=== SignatureProof container ===\n+== Specification ==\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Type\n-!Length\n-!Name\n-!Comment\n-|-\n-|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data\n-|-\n-|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data\n-|-\n-|VarInt||1-8||witlen||Number of entries in witness stack\n-|-\n-|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors, each one prepended with a varint of its size\n-|}\n+This BIP follows the specification of BIP-325 challenges and solutions (see Signet comparison below).\n \n-In some cases, the scriptsig or wit may be empty. If both are empty, the proof is incomplete.\n+Let there be two virtual transactions to_spend and to_sign.\n \n-=== Result Codes ===\n+The \"to_spend\" transaction is:\n \n-A verification call will return a result code according to the table below.\n+    nVersion = 0\n+    nLockTime = 0\n+    vin[0].prevout.hash = 0000...000\n+    vin[0].prevout.n = 0xFFFFFFFF\n+    vin[0].nSequence = 0\n+    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]\n+    vin[0].scriptWitness = []\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = message_challenge\n \n-{|class=\"wikitable\" style=\"text-align: center;\"\n-|-\n-!Code\n-!Description\n-|-\n-|INCOMPLETE||Empty proof.\n-|-\n-|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.\n-|-\n-|VALID||The proof was valid.\n-|-\n-|INVALID||The proof was invalid\n-|-\n-|ERROR||An error was encountered\n-|}\n+where message_hash is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = \"BIP0322-signed-message\", and message_challenge is the to be proven (public) key script.\n+For proving funds, message_challenge shall be simply OP_TRUE.\n \n-== Signing and Verifying ==\n+The \"to_sign\" transaction is:\n \n-If the challenge consists of an address is in the P2PKH (legacy) format, sign using the legacy format (further information below). Otherwise continue as stated below.\n+    nVersion = 0 or as appropriate (e.g. 2, for time locks)\n+    nLockTime = 0 or as appropriate (for time locks)\n+    vin[0].prevout.hash = to_spend.txid\n+    vin[0].prevout.n = 0\n+    vin[0].nSequence = 0 or as appropriate (for time locks)\n+    vin[0].scriptWitness = message_signature\n+    vout[0].nValue = 0\n+    vout[0].scriptPubKey = OP_RETURN\n \n-For both cases, generate a sighash based on the given scriptPubKey and message as follows:\n+When a proof of funds is being created, additional inputs should be included for virtually spending transaction outputs of desired value.\n \n-# Define the message pre-image as the sequence \"Bitcoin Signed Message:\\n\" concatenated with the message, encoded in UTF-8 using Normalization Form Compatibility Decomposition (NFKD)\n-# Let sighash = sha256(sha256(scriptPubKey || pre-image))\n+* All signatures must use the SIGHASH_ALL flag.\n+* The proof is considered valid, inconclusive, or invalid based on whether the to_sign transaction is a valid spend of the to_spend transaction or not, according to the rules specified in the \"Consensus and standard flags\" section below.\n+* It may (optionally) be encumbered with the in_future flag, according to the rules specified in the \"Locktime and Sequence\" section below, in which case we refer to the result in text form as \"valid_in_future\", \"inconclusive_in_future\", etc.\n \n-A private key may be used directly to sign a message. In this case, its P2WPKH bech32 address shall be derived, and used as the input.\n+Proofs with additional inputs are the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation, and proofs without additional inputs (simple proofs) are the base64-encoding of the to_sign script witness.\n \n-=== Signing ===\n+A validator must verify it is valid and meets the description of virtual transactions as specified above. See \"Validation\" below.",
      "path": "bip-0322.mediawiki",
      "position": 111,
      "original_position": 111,
      "commit_id": "75ec9631effc524364cded5c3eff02e4e27ebf9c",
      "original_commit_id": "d8b4049d3430e4f188d58f32b3585a672c6df10d",
      "in_reply_to_id": 506639225,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It refers to \"the proof\" which is both transactions together, which is why it's singular. But you're right it could use clarification: #1028",
      "created_at": "2020-10-30T07:01:35Z",
      "updated_at": "2020-10-30T07:01:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1003#discussion_r514904278",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/514904278"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1003"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 66,
      "original_line": 66,
      "side": "RIGHT"
    }
  ]
}